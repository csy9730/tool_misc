# 编程常见概念 


* 变量
* 函数
* 面向对象
* 面向过程
* 命令式编程
* 函数式编程
* 回调
* 环境

## 面向对象
### 变量生存周期
对象的周期：
1. ini 初始化环节
2. cfg  配置环节
3. input&output 输入与输出的核心流程
4. reset 复位状态信息，清除缓存
5. deinit 析构环节

相关的变量包括
* initArg，控制对象的超参数，元信息，例如type，template
* cfg，配置参数，用于控制对象的参数，例如ini/json配置文件
* inputBuffer，输入参数以及缓存m
* outputBuffer，输出参数以及缓存
* statusVar，状态变量,尽量隐藏不被用户感知
* tempVar /autoVariant，无名变量/自动变量，不知道如何分类的变量
* env 环境变量，生存周期大于对象，不可更改
* weakref 外部变量的弱引用，可更改，避免调用空指针错误
* strongref 外部变量的强引用，可更改，需要避免泄漏

1. 主要影响initArg
2. 主要影响cfg
3. 主要影响输入和输出和状态变量和auto变量
4. 影响状态变量，清除缓存
5. 全部清除

## callback

回调函数概念： 包括 调用函数，回调函数，调用环境。回调函数概念用于描述两个个体/两个层次之间的交互，重点在于单个个体无法单独完成函数功能，需要两个个体/层次交互完成
1. 注册回调函数
2. 使用回调函数



信号槽机制与回调函数功能上类似，但提供更灵活的绑定。
* 发出者，
* 发出者的发出信号
* 接收者,
* 接收者的触发动作函数


其实回调、委托、通知、监听、广播等本质上是一样的，只是不同语言的不同实现用不同的术语来表达。

callback 一词本来用于打电话。你可以打电话（call）给别人，也可以留下电话号码，让别人回电话（callback）。计算机领域相对较新，一些日常词汇被引进，表达类似概念。call 和 callback 在计算机领域翻译成“调用”和“回调”。
回调函数是你写一个函数，让预先写好的系统来调用。你调用系统的函数，是直调。让系统调用你的函数，就是回调。但假如满足于这种一句话结论，是不会真正明白回调的应用场景。

回调函数可以看成，让别人做事，传进去的额外信息。
A 让 B 做事，根据粒度不同，可以理解成 A 函数调用 B 函数，或者 A 类使用 B 类，或者 A 组件使用 B 组件，或者A应用调用B系统库等等。反正就是 A 叫 B 做事。
当B做这件事情的时候，会发现B自己靠自己无法完成，有些东西一定是A配合才能完成的。就需要 A 从外面传进来，或者 B 做着做着再向外面申请。对于 B 来说，一种被动得到信息，一种是主动去得到信息。有些人给这两种方式一个术语，叫信息的压送（ push），和信息的拉取（ pull）。

例如，A委托B帮他买东西，B打开淘宝，挑选东西放入购物车，推送到A眼前，由A来完成


### 数据结构
数据分为： 
* value
* type
* domain
* auto/static/extern/
* variable:const/constexpr/mutable/volatile
* misc: restrict/register
* struct
* reference/pointer

值语义，指的是对象的拷贝与原对象无关，就像拷贝int一样，C++的常用类型数据等都是值语义。
对象语义，指的是面向对象意义下的对象，是禁止拷贝的。
C++中引用分为强引用和弱引用，jsva中引用又多了软引用/虚引用。

强引用Strong Reference
当对象被创建时，计数为1；每创建一个变量引用该对象时，该对象的计数就增加1；当上述变量销毁时，对象的计数减1，当计数为0时，这个对象也就被析构了。
弱引用(Weak Reference)不更改引用计数，类似普通指针。

强引用类似一个实体，需要自行释放。弱引用行为是一个指针，需要考虑避免调用空指针/垂悬指针（指向对象先于指针被释放，则该指针为垂悬指针）。
软引用，介于强引用和弱引用之间，通常用来做高速缓存。
虚引用，给一个对象添加一个即将被垃圾回收的标志，以便程序在对象回收之前采取行动。

在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
#### COW
思想是只有当修改string的时候再为这个修改操作重新生成一个拷贝，如果只是复制，那么就是共享这个数据。COW的实现机制是用一个引用计数，初始值是1，每次赋值的时候都会加1。当修改的时候，如果count > 1， 则会重新申请空间并复制，并且count--（因为正在修改的这个之前肯定是引用了这个数据），然后如果count = 0， 则释放原来内存。
#### SSO
(small string optimization)
因为COW的弊端（除了上面提到的，还有其他的，比如多线程问题），新版本的编译器大多放弃了COW，而使用了SSO。SSO思想是立刻复制，同时有一个优化就是当字符串较短时，直接将其数据放到栈中，而不是在堆中动态申请内存，避免了申请空间的开销。
#### string_view
string_view 是C++17所提供的用于处理只读字符串的轻量对象。这里后缀 view 的意思是只读的视图。

### evaluation
eager evaluation (及早求值)
及早求值，也被称为贪婪求值（greedy evaluation）或严格求值，是多数传统编程语言的求值策略。
lazy evaluation (惰性求值)
对于惰性求值的编程语言，由于记忆化（memoization）特性，求值过程与之不同。
使用写时复制机制COW（copy on write）。
Lazy Fetching: 模型会自动从缓存中取得需要的数据
deep copy & swallow copy


SFINAE和type traits
Copy Elision

c with class, c with std, c with 引用, c with auto
### POD
POD（Plain Old Data，普通旧数据）类型是从 C++11 开始引入的概念，Plain 代表一个对象是一个普通类型，Old 代表一个对象可以与 C 兼容。通俗地讲，一个类、结构、共用体对象或非构造类型对象能通过二进制拷贝（如 memcpy()）后还能保持其数据不变正常使用的就是POD类型的对象。严格来讲，一个对象既是普通类型（Trivial Type）又是标准布局类型（Standard-layout Type）那么这个对象就是 POD 类型。
如果类或结构包含某些 C++ 语言功能，如虚拟基类、 虚函数、 具有不同的访问控制的成员，则不同编译器会有不同的布局实现，具体取决于编译器对代码的优化方式，比如实现内存对齐，减少访存指令周期。例如，如果类具有虚函数，该类的所有实例都会包含一个指向虚函数表的指针，那么这个对象就不能直接通过二进制拷贝的方式传到其它语言编程的程序中使用。
当类或结构体同时满足如下几个条件时是普通类型：
1. 没有虚函数或虚基类；
2. 由C++编译器提供默认的特殊成员函数（默认的构造函数、拷贝构造函数、移动构造函数、赋值运算符、移动赋值运算符和析构函数）；
3. 数据成员同样需要满足条件1和条件2。

当类或结构体同时满足如下几个条件时是标准布局类型：
（1）没有虚函数或虚基类；
（2）所有非静态数据成员都具有相同的访问说明符；比如都是private/public/protected
（3）在继承体系中最多只有一个类中有非静态数据成员；
（4）子类中的第一个非静态成员的类型与其基类不同；

一个对象既是普通类型（Trivial Type）又是标准布局类型（Standard-layout Type）那么这个对象就是POD类型。为什么我们需要 POD 类型满足这些条件呢，POD 类型在源码层级的操作上兼容于 ANSI C。POD 对象与 C 语言中的对象具有一些共同的特性，包括初始化、复制、内存布局与寻址：
（1）可以使用字节赋值，比如用 memset、memcpy 对 POD 类型进行赋值操作；
（2）对 C 内存布局兼容，POD 类型的数据可以使用 C 函数进行操作且总是安全的；
（3）保证了静态初始化的安全有效，静态初始化可以提高性能，如将 POD 类型对象放入 BSS 段默认初始化为 0。


Plain Old Java Object

### 非侵入式设计和侵入式设计
 首先，我们考察一下何谓intrusive。典型的intrusive实现是继承特定的基类, 或者实现特定的接口. 在抽象的意义上说, intrusive意味着在基础结构中预留了一些特殊的,专用的结构, 这些结构对于基础功能而言不仅仅是无用的, 甚至是有害的, 例如影响性能或者模糊了原有的概念结构, 而系统整体的后期扩展能力也受到这些预设的结构通道的限制.
non-intrusive设计的基本特点是尽量利用基础结构的元素, 而不是引入额外的特殊结构.
例如，我们可能需要对类A的对象做引用计数，这里有两种基本可能性：将计数功能纳入类A的设计内（侵入式引用计数设计，此时类A的对象中包含了与引用计数有关的要素，这显然是与类A所要表示的概念无关的东西），或者将计数功能放在类A之外（非侵入式引用计数）。
1.  在Person类中加入一个统计的方法。（侵入式：因为统计方法并不属于设计这个类时的概念，而是Person类想要表示的概念无关的东西。）
2. 将计数功能放在类外。（非侵入式设计：这个功能在类之外，没有侵入到这个类的内部。）
方法1中类需要继承一些Counter的类，使得系统离不开框架。
方法2中类需要实现一些Counter的接口，使得系统可以框架。

从类的编写者角度来看，察觉不到框架的存在。方便的迁移和重用。但与用户代码的交互可能会复杂一些。
侵入式设计有时候表现为客户端需要继承框架中的类，而非侵入式设计则表现为客户端实现框架提供的接口。

spring这种非侵入式的框架，都是利用反射和动态调用来实例化的，代码中没有任何与spring交叉的类，哪怕把spring的jar全部去了，你的代码不受任何影响，加上其他的框架后可以继续运行。
非侵入式设计总是和Spring这样的IoC容器或者AOP技术联系在一起。

## misc
消息发送，虚模板函数，字符串，输入输出，格式化，序列化， locale，全局变量，模板表达式，组合子解析器，allocator，智能指针，程序运行时，抽象工厂访问者等模式

COM（COM--Component Object Model，即组件对象模型，它是微软提出的一套开发软件的方法与规范。

### mock
mock测试
mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。（这里包括很多，比如呀数据库、依赖的服务等等）

### misc
编程的演化就是coder使用的语言和工具库不断失去对编程环境的控制权。
汇编支持寄存器操作。
编译器隐藏了不同硬件平台上代码不同的实现方法。
c语言支持指针，内存布局，提供了函数并自行切换上下文。
c++需要自行管理对象的生命周期。
gc（gabage collect）支持语言，可以自己发现废弃对象，自行回收对象。
IoC容器避免对象之间互相依赖，避免管理生命周期
操作系统提供的多进程，避免了用户切换程序上下文。
操作系统提供的多线程，避免了用户切换线程上下文。


### IoC& DI
控制反转IoC (Inversion of Control)和依赖注入DI(Dependency Injection)，是一种设计思想。

传统的的对象控制方法， 在用户的入口函数中创建(new)对象类，设置执行参数，然后执行，然后释放对象。
依赖反转的对象控制方法。

应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。

所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。
所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
 Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。

 （感觉像一个全局的，唯一的一个工厂对象，输入配置（对象名），可以提供想要的对象，）
 A对象需要B对象作为工具执行某项功能，而B对象的生命周期和A对象的生命周期不同，（B对象可能先于A对象释放而更换另一个B对象），为了避免A对象管理B对象生命周期，通过第三方对象（IoC容器）管理B对象，A对象只需要向IoC容器提交B类的申请，IoC容器将会提供B对象交给A对象。
 * IoC容器的执行机制是同步还是异步？
 * 注册B对象时间是什么时点？（B对象原型proto)
 * IoC生成B对象的时点和交给A对象的时点？(new & ownership)

 控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，


### 面向切面编程（AOP模块）

钩子Hook是指对一些方法进行拦截，具体一点来说就是程序运行中，创建代理对象，然后把原始对象替换为代理对象。可以完全篡改原有的行为。
代理模式:代理模式也能够做到装饰器的功能，但是实现的过程是不一致的，代理模式是切切实实的写了一个类，装饰器是运行期生成的一个类。动态代理模式？
装饰器模式（Decorator ）对原有对类进行了一次装饰，并且增添了新对功能。常用于如权限控制，内容过滤，请求管理，缓存结果等等。
event condition（filter） ， trigger/handler，库作者通过提前定义触发事件，交给开发者定义触发事件，也能实现切面操作。
signal & slot信号槽机制，比事件机制更细。
Event 的含义比signal更大，颗粒度更大。



AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
方法通过 类似装饰器/钩子，通过在主要事务函数注册触发点，在触发点执行指定的边缘事务。
触发点有 前置通知，后置通知，环绕通知。
### 动态加载
插件化技术：也叫动态加载技术，将整个app拆分成很多模块，这些模块包括一个宿主和多个插件，每个模块都是一个apk，插件模块无需安装，由宿主模块动态加载。
插件化主要解决两个问题：代码加载与资源加载。
动态语言（脚本）天然支持动态加载技术，静态语言天然上不支持，C/C++语言可以通过动态加载dll实现。

###　事件循环
libevent
