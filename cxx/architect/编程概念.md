# 编程常见概念 


* 变量
* 函数
* 面向对象
* 面向过程
* 命令式编程
* 函数式编程
* 回调
* 环境

## 面向对象
### 变量生存周期
对象的周期：
1. ini 初始化环节
2. cfg  配置环节
3. input&output 输入与输出的核心流程
4. reset 复位状态信息，清除缓存
5. deinit 析构环节

相关的变量包括
* initArg，控制对象的超参数，元信息，例如type，template
* cfg，配置参数，用于控制对象的参数，例如ini/json配置文件
* inputBuffer，输入参数以及缓存m
* outputBuffer，输出参数以及缓存
* statusVar，状态变量,尽量隐藏不被用户感知
* tempVar /autoVariant，无名变量/自动变量，不知道如何分类的变量
* env 环境变量，生存周期大于对象，不可更改
* weakref 外部变量的弱引用，可更改，避免调用空指针错误
* strongref 外部变量的强引用，可更改，需要避免泄漏

1. 主要影响initArg
2. 主要影响cfg
3. 主要影响输入和输出和状态变量和auto变量
4. 影响状态变量，清除缓存
5. 全部清除

## callback

回调函数概念： 包括 调用函数，回调函数，调用环境。回调函数概念用于描述两个个体/两个层次之间的交互，重点在于单个个体无法单独完成函数功能，需要两个个体/层次交互完成
1. 注册回调函数
2. 使用回调函数



信号槽机制与回调函数功能上类似，但提供更灵活的绑定。
* 发出者，
* 发出者的发出信号
* 接收者,
* 接收者的触发动作函数


其实回调、委托、通知、监听、广播等本质上是一样的，只是不同语言的不同实现用不同的术语来表达。

callback 一词本来用于打电话。你可以打电话（call）给别人，也可以留下电话号码，让别人回电话（callback）。计算机领域相对较新，一些日常词汇被引进，表达类似概念。call 和 callback 在计算机领域翻译成“调用”和“回调”。
回调函数是你写一个函数，让预先写好的系统来调用。你调用系统的函数，是直调。让系统调用你的函数，就是回调。但假如满足于这种一句话结论，是不会真正明白回调的应用场景。

回调函数可以看成，让别人做事，传进去的额外信息。
A 让 B 做事，根据粒度不同，可以理解成 A 函数调用 B 函数，或者 A 类使用 B 类，或者 A 组件使用 B 组件，或者A应用调用B系统库等等。反正就是 A 叫 B 做事。
当B做这件事情的时候，会发现B自己靠自己无法完成，有些东西一定是A配合才能完成的。就需要 A 从外面传进来，或者 B 做着做着再向外面申请。对于 B 来说，一种被动得到信息，一种是主动去得到信息。有些人给这两种方式一个术语，叫信息的压送（ push），和信息的拉取（ pull）。

例如，A委托B帮他买东西，B打开淘宝，挑选东西放入购物车，推送到A眼前，由A来完成


### 数据结构
数据分为： 
* value
* type
* domain
* auto/static/extern/
* variable:const/constexpr/mutable/volatile
* misc: restrict/register
* struct
* reference/pointer

值语义，指的是对象的拷贝与原对象无关，就像拷贝int一样，C++的常用类型数据等都是值语义。
对象语义，指的是面向对象意义下的对象，是禁止拷贝的。
C++中引用分为强引用和弱引用，jsva中引用又多了软引用/虚引用。

强引用Strong Reference
当对象被创建时，计数为1；每创建一个变量引用该对象时，该对象的计数就增加1；当上述变量销毁时，对象的计数减1，当计数为0时，这个对象也就被析构了。
弱引用(Weak Reference)不更改引用计数，类似普通指针。

强引用类似一个实体，需要自行释放。弱引用行为是一个指针，需要考虑避免调用空指针/垂悬指针（指向对象先于指针被释放，则该指针为垂悬指针）。
软引用，介于强引用和弱引用之间，通常用来做高速缓存。
虚引用，给一个对象添加一个即将被垃圾回收的标志，以便程序在对象回收之前采取行动。

在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
#### COW
思想是只有当修改string的时候再为这个修改操作重新生成一个拷贝，如果只是复制，那么就是共享这个数据。COW的实现机制是用一个引用计数，初始值是1，每次赋值的时候都会加1。当修改的时候，如果count > 1， 则会重新申请空间并复制，并且count--（因为正在修改的这个之前肯定是引用了这个数据），然后如果count = 0， 则释放原来内存。
#### SSO
(small string optimization)
因为COW的弊端（除了上面提到的，还有其他的，比如多线程问题），新版本的编译器大多放弃了COW，而使用了SSO。SSO思想是立刻复制，同时有一个优化就是当字符串较短时，直接将其数据放到栈中，而不是在堆中动态申请内存，避免了申请空间的开销。
#### string_view
string_view 是C++17所提供的用于处理只读字符串的轻量对象。这里后缀 view 的意思是只读的视图。


eager evaluation (及早求值)
及早求值，也被称为贪婪求值（greedy evaluation）或严格求值，是多数传统编程语言的求值策略。
lazy evaluation (惰性求值)
对于惰性求值的编程语言，由于记忆化（memoization）特性，求值过程与之不同。
使用写时复制机制COW（copy on write）。
Lazy Fetching

deep copy & swallow copy


SFINAE和type traits
Copy Elision
decltype(auto)

std::string的COW，SSO，view

c with class, c with std, c with 引用, c with auto
### POD
Plain Old Java Object
### 非侵入式设计和侵入式设计
 首先，我们考察一下何谓intrusive。典型的intrusive实现是继承特定的基类, 或者实现特定的接口. 在抽象的意义上说, intrusive意味着在基础结构中预留了一些特殊的,专用的结构, 这些结构对于基础功能而言不仅仅是无用的, 甚至是有害的, 例如影响性能或者模糊了原有的概念结构, 而系统整体的后期扩展能力也受到这些预设的结构通道的限制.
non-intrusive设计的基本特点是尽量利用基础结构的元素, 而不是引入额外的特殊结构.
例如，我们可能需要对类A的对象做引用计数，这里有两种基本可能性：将计数功能纳入类A的设计内（侵入式引用计数设计，此时类A的对象中包含了与引用计数有关的要素，这显然是与类A所要表示的概念无关的东西），或者将计数功能放在类A之外（非侵入式引用计数）。
1.  在Person类中加入一个统计的方法。（侵入式：因为统计方法并不属于设计这个类时的概念，而是Person类想要表示的概念无关的东西。）
2. 将计数功能放在类外。（非侵入式设计：这个功能在类之外，没有侵入到这个类的内部。）
方法1中类需要继承一些Counter的类，使得系统离不开框架。
方法2中类需要实现一些Counter的接口，使得系统可以框架。

从类的编写者角度来看，察觉不到框架的存在。方便的迁移和重用。但与用户代码的交互可能会复杂一些。
侵入式设计有时候表现为客户端需要继承框架中的类，而非侵入式设计则表现为客户端实现框架提供的接口。

spring这种非侵入式的框架，都是利用反射和动态调用来实例化的，代码中没有任何与spring交叉的类，哪怕把spring的jar全部去了，你的代码不受任何影响，加上其他的框架后可以继续运行。

非侵入式设计总是和Spring这样的IoC容器或者AOP技术联系在一起。

## misc
消息发送，虚模板函数，字符串，输入输出，格式化，序列化， locale，全局变量，模板表达式，组合子解析器，allocator，智能指针，程序运行时，抽象工厂访问者等模式

COM（COM--Component Object Model，即组件对象模型，它是微软提出的一套开发软件的方法与规范。

### mock
mock测试
mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。（这里包括很多，比如呀数据库、依赖的服务等等）