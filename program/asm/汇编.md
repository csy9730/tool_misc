# 汇编

## 通用寄存器
### 8086CPU16位寄存器
最初的8086CPU提供4个16位通用寄存器：AX，BX，CX 和DX。

这些寄存器都可以分解成两个8位寄存器。例如：AX寄存器可以分解成AH和AL寄存器

#### SI 和DI
这有两个16位指针寄存器：SI 和DI 。通常它们都是当作指针来使用，但是在许多情况下也可以像通用寄存器一样使用。但是，它们不可以分解成8位寄存器。
#### BP和SP 
16位BP和SP 寄存器用来指向机器语言堆栈里的数据，被各自称为基址寄存器和堆栈指针寄存器。这些将在以后讨论。

#### CS，DS，SS 和ES
16位CS，DS，SS 和ES 寄存器是段寄存器。它们指出程序不同部分所使用的内存。
CS代表代码段，DS 代表数据段，SS 代表堆栈段和ES代表附加段。ES当作一个暂时段寄存器来使用。这些寄存器的细节描述在后面的文章中。
#### IP
指令指针寄存器(IP) 与CS寄存器一起使用来跟踪CPU下一条执行指令的地址。通常，当一条指令执行时，IP提前指向内存里的下一条指令。
#### FLAGS
FLAGS寄存器储存了前面指令执行结果的重要信息。这些结果在寄存器里以单个的位储存。例如：如果前面指令执行结果是0，Z位为1，反之为0。并不是所有指令都修改FLAGS里的位，查看附录里的表看单个指令是如何影响FLAGS寄存器的。

### 80386 32位寄存器
80386及以后的处理器扩展了寄存器。例如：16位AX寄存器扩展成了32位。为了向后兼容，AX依然表示16位寄存器而EAX 用来表示扩展的32位寄存器。AX是EAX 的低16位就像AL是AX(EAX)的低8位一样。但是没有直接访问EAX 高16位的方法。其它的扩展寄存器是EBX，ECX，EDX，ESI 和EDI 。

- EAX
- EBX
- ECX
- EDX
- EDI
- ESI
- EBP
- ESP

许多其它类型的寄存器同样也扩展了。BP变成了EBP；SP 变成了ESP；FLAGS变成了EFLAGS， 而IP变成了EIP。但是，不同于指针寄存器和通用寄存器，在32位保护模式下(下面将讨论的)只有这此寄存器的扩展形式被使用。
#### FS和GS
在80386里，段寄存器依然是16位的。这儿有两个新的段寄存器：FS和GS。它们名字并不代表什么。它们是附加段寄存器(像ES一样)。术语中字的一个定义为CPU数据寄存器的大小。

对于80x86家族，这个术语现在有一点混乱了。在表1.2里，可以看到字被定义成两个字节。它是当8086第一次发行时被定义成这样的。当80386开发出来后，它被决定依旧保持这个字定义不改变，即使寄存器的大小已经改变了。


### 指令操作数
机器代码指令拥有个数和类型不同的操作数；然而，通常每个指令有几个固定的操作数(0到3个)。操作数可以有下面的类型：

寄存器: 这些操作数直接指向CPU寄存器里的内容。

内存: 这些操作数指向内存里的数据。数据的地址可能是硬编码到指令里的常量或可能直接使用寄存器的值计算得到。距离段的起始地址的偏移值即为此地址。

立即数: 这些操作数是指令本身列出的固定的值。它们储存在指令本身(在代码段)，而不在数据段。

暗指的操作数: 这些操作数没有明确显示。例如：往寄存器或内存增加1的加法指令。1是暗指的。


## 基本指令
### MOVMOV
最基本指令是MOV 指令。它将数据从一个地方移到另一个地方(像高级语言里面的赋值操作一样)。它携带两个操作数：
```
mov dest (目的操作数), src(源操作数)
```
src指定的数据拷贝到了dest。一个指令的两个操作数不能同时是内存操作数。这就指出了一个汇编古怪的地方。通常，对于各种各样指令的使用都有某些强制性的规定。操作数必须是同样的大小。AX里的值就不能储存到BL 里去。

``` asm
mov eax,3; eax=3
mov bx,ax; bx=ax

add eax,4; eax=eax+4
add al,ah; al=al+ah

sub bx,10; bx=bx-10

inc ecx; ecx++
dec dl;dl--
```
### 立即数
- byte 字节
- word 字 2字节
- double word 双字 4字节
- q word 四字 8字节，可以保存双精度浮点数

### 分支

#### JMP
JMP (jump的简称)指令产生无条件分支。它唯一的参数通常是一个指向分支指向的指令的代码标号。汇编器和连接器将用指令的正确地址来替代这个标号。这又是一个乏味的操作数，通过这个，汇编器使得程序员的日子不好过。能认识到在JMP指令后的指令不会被执行，除非另一条分支指令
指向它，是非常重要的。
#### 条件跳转
- JZ/JNZ ZF=1，JZ跳转；ZF=0,JNZ跳转
- JO/JNO OF
- JS/JNS 
- JC/JNC
- JP/JNP


``` c
if ( EAX == 0 )
  EBX = 1;
else
  EBX = 2;
```

``` asm
cmp eax,0
jz thenblock
mov ebx,2
jmp next
thenblock:
	mov ebx,1
next:
```

#### 循环指令

loop


#### call 指令
第三行的call指令用来调用函数。
#### ret 指令
ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。


#### push 指令
根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。

#### pop 指令
pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。
