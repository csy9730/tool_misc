# 汇编

## 通用寄存器


- 通用寄存器
  - 16位 AX，BX，CX 和DX
    - AX Accumulator，累加寄存器，算数运算的主要寄存器；
    - BX (Base)，基址寄存器；
    - CX(Count)，计数寄存器，串操作、循环控制的计数器；
    - DX (Data)，数据寄存器。乘法和除法结果会使用DX
  - 32位 EAX，EBX，ECX 和EDX 属于16位的扩展
  - SI DI BP和SP 
    - SI(Source Index)：源变址寄存器；
    - DI(Destination Index)：目的变址寄存器；
    - SP (stack pointer)：堆栈寄存器；(指向栈顶，可以增长)
    - BP(base pointer)：基址指针寄存器 (指向栈底)
- 段寄存器 CS，DS，SS 和ES
    - CS（Code Segment）：代码段寄存器；存放当前正在运行的程序代码所在段的段基值
    - DS（Data Segment）：数据段寄存器；存放数据段的段基值。
    - SS（Stack Segment）：堆栈段寄存器；即存放堆栈段的段基值
    - ES（Extra Segment）：附加段寄存器。
- 控制寄存器
  - 指令指针寄存器(IP) 与CS寄存器 配合使用，IP是不允许修改的.
  - FLAGS
- New
  - FS和GS寄存器是从386开始才有的. FS主要用来指向 Thread Information Block(TIB).


### SP BP
堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，**但SP是要指向栈顶的，是不能随便乱改的**，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址．一般除了保存数据外,可以作为指针寄存器用于存储器寻址,此时它默认搭配的段寄存器是SS-堆栈段寄存器.BP是16位的,再扩充16位就是EBP,用于32位编程环境的.一般高级语言的参数传递等等,转换为汇编后经常由BP/EBP来负责寻址\处理.

SP,BP一般与段寄存器SS 联用，以确定堆栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可 作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。
~~可以理解成 [BP*0xffff + BP + SP]~~

堆栈段寄存器SS：指出当前堆栈的底部地址，即存放堆栈段的段基值。

``` asm
// 在函数进入时：
push bp     // 保存bp指针
mov bp,sp  // 将sp指针传给bp，此时bp指向sp的基地址。
                  // 这个时候，如果该函数有参数，则[bp + 2*4]则是该子函数的第一个参数，[bp+3*4]则是该子函数的 第二个参数，以此类推，有多少个参数则[bp+(n-1)*4]。
.....
.....
// 函数结束时：
mov sp,bp  // 将原sp指针传回给sp
pop bp       // 恢复原bp的值。
ret              // 退出子函数
```

### 8086CPU16位寄存器
最初的8086CPU提供4个16位通用寄存器：AX，BX，CX 和DX。

这些寄存器都可以分解成两个8位寄存器。例如：AX寄存器可以分解成AH和AL寄存器

#### SI 和DI
这有两个16位指针寄存器：SI 和DI 。通常它们都是当作指针来使用，但是在许多情况下也可以像通用寄存器一样使用。但是，它们不可以分解成8位寄存器。

BX，SI，DI 会默认使用 DS 段寄存器

SP BP 会默认使用 SS 段寄存器

SI叫做源索引寄存器, DI叫做目的索引寄存器. 正如它们的命名, SI通常指向源数组, DI通常指向目的数组. 他们通常被用来成块地移动数据, 比如移动数组或结构体. SI和DI通常和DS和ES一起使用.

#### BP和SP 
16位BP和SP 寄存器用来指向机器语言堆栈里的数据，被各自称为基址寄存器和堆栈指针寄存器。这些将在以后讨论。

#### CS，DS，SS 和ES
16位CS，DS，SS 和ES 寄存器是段寄存器。它们指出程序不同部分所使用的内存。
CS代表代码段，DS 代表数据段，SS 代表堆栈段和ES代表附加段。ES当作一个暂时段寄存器来使用。这些寄存器的细节描述在后面的文章中。

~~ES 类似DS，作为DS的后备使用？DS和ES配合指向源段和目的段，实现拷贝~~
#### IP
指令指针寄存器(IP) 与CS寄存器一起使用来跟踪CPU下一条执行指令的地址。通常，当一条指令执行时，IP提前指向内存里的下一条指令。

#### FLAGS
FLAGS寄存器储存了前面指令执行结果的重要信息。这些结果在寄存器里以单个的位储存。例如：如果前面指令执行结果是0，Z位为1，反之为0。并不是所有指令都修改FLAGS里的位，查看附录里的表看单个指令是如何影响FLAGS寄存器的。


### 80386 32位寄存器
80386及以后的处理器扩展了寄存器。例如：16位AX寄存器扩展成了32位。为了向后兼容，AX依然表示16位寄存器而EAX 用来表示扩展的32位寄存器。AX是EAX 的低16位就像AL是AX(EAX)的低8位一样。但是没有直接访问EAX 高16位的方法。其它的扩展寄存器是EBX，ECX，EDX，ESI 和EDI 。

- EAX
- EBX
- ECX
- EDX
- EDI
- ESI
- EBP
- ESP

许多其它类型的寄存器同样也扩展了。BP变成了EBP；SP 变成了ESP；FLAGS变成了EFLAGS， 而IP变成了EIP。但是，不同于指针寄存器和通用寄存器，在32位保护模式下(下面将讨论的)只有这此寄存器的扩展形式被使用。
#### FS和GS
在80386里，段寄存器依然是16位的。这儿有两个新的段寄存器：FS和GS。它们名字并不代表什么。它们是附加段寄存器(像ES一样)。术语中字的一个定义为CPU数据寄存器的大小。

对于80x86家族，这个术语现在有一点混乱了。在表1.2里，可以看到字被定义成两个字节。它是当8086第一次发行时被定义成这样的。当80386开发出来后，它被决定依旧保持这个字定义不改变，即使寄存器的大小已经改变了。


### 指令操作数
机器代码指令拥有个数和类型不同的操作数；然而，通常每个指令有几个固定的操作数(0到3个)。操作数可以有下面的类型：

寄存器: 这些操作数直接指向CPU寄存器里的内容。

内存: 这些操作数指向内存里的数据。数据的地址可能是硬编码到指令里的常量或可能直接使用寄存器的值计算得到。距离段的起始地址的偏移值即为此地址。

立即数: 这些操作数是指令本身列出的固定的值。它们储存在指令本身(在代码段)，而不在数据段。

暗指的操作数: 这些操作数没有明确显示。例如：往寄存器或内存增加1的加法指令。1是暗指的。


## 基本指令
### MOV
最基本指令是MOV 指令。它将数据从一个地方移到另一个地方(像高级语言里面的赋值操作一样)。它携带两个操作数：
```
mov dest (目的操作数), src(源操作数)
```
src指定的数据拷贝到了dest。一个指令的两个操作数不能同时是内存操作数。这就指出了一个汇编古怪的地方。通常，对于各种各样指令的使用都有某些强制性的规定。操作数必须是同样的大小。AX里的值就不能储存到BL 里去。

``` asm
mov eax,3; eax=3
mov bx,ax; bx=ax

add eax,4; eax=eax+4
add al,ah; al=al+ah

sub bx,10; bx=bx-10

inc ecx; ecx++
dec dl;dl--
```
### 立即数
- byte 字节
- word 字 2字节
- double word 双字 4字节
- q word 四字 8字节，可以保存双精度浮点数

### 分支

#### JMP
JMP (jump的简称)指令产生无条件分支。它唯一的参数通常是一个指向分支指向的指令的代码标号。汇编器和连接器将用指令的正确地址来替代这个标号。这又是一个乏味的操作数，通过这个，汇编器使得程序员的日子不好过。能认识到在JMP指令后的指令不会被执行，除非另一条分支指令
指向它，是非常重要的。
#### 条件跳转
- JZ/JNZ ZF=1，JZ跳转；ZF=0,JNZ跳转
- JO/JNO OF
- JS/JNS 
- JC/JNC
- JP/JNP


``` c
if ( EAX == 0 )
  EBX = 1;
else
  EBX = 2;
```

``` asm
cmp eax,0
jz thenblock
mov ebx,2
jmp next
thenblock:
	mov ebx,1
next:
```

#### 循环指令

loop


#### call 指令
第三行的call指令用来调用函数。
#### ret 指令
ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。


#### push 指令
根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。

#### pop 指令
pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。
