## [编译原理---递归下降分析法](https://www.cnblogs.com/youxin/archive/2013/03/18/2965723.html)

2013-03-18 11:55  [youxin](https://www.cnblogs.com/youxin/)  阅读(4756)  评论(0)  [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=2965723)  [收藏](javascript:void(0))  [举报](javascript:void(0))

所谓递归下降法 (recursive descent method)，是指对文法的每一非终结符号，都根据相应产生式各候选式的结构，为其编写一个子程序 (或函数)，用来识别该非终结符号所表示的语法范畴。例如，对于产生式E′→+TE′，可写出相应的子程序如下：

```
exprprime( ){if (match (PLUS)){advance( );term( );exprprime( );}}
```





​     其中： 函数match()的功能是，以其实参与当前正扫视的符号 (单词)进行匹配，若成功则回送true，否则回送false；函数advance()是一个读单词子程序，其功能是从输入单词串中读取下一个单词，并将它赋给变量Lookahead;term则是与非终结符号T相对应的子程序。诸如上述这类子程序的全体，便组成了所需的自顶向下的语法分析程序。
​     应当指出，由于一个语言的各个语法范畴 (非终结符号)常常是按某种递归方式来定义的，此种特点也就决定了这组子程序必然以相互递归的方式进行调用，因此，在实现递归下降分析法时，应使用支持递归调用的语言来编写程序。所以，通常也将上述方法称为递归子程序法。     例42对于如下的文法

```
G［statements］:
statements→expression; statements |ε
expression→term expression′
expression′→+term expression′ |ε
term→factor term′
term′→*factor term′ |ε
factor→numorid | (expression)
```



通过对其中各非终结符号求出相应的FIRST集和FOLLOW集 (计算FIRST集和FOLLOW集的方法后面再做介绍)，可以验证，此文法为一LL(1)文法，故可写出递归下降语法分析程序如程序41所示(其中，在文件lex.h里，将分号、加号、乘号、左括号、右括号、输入结束符及运算对象分别命名为SEMI，PLUS，TIMES，LP，RP，EOI及NUMORID，并指定了它们的内部码；此外，还对外部变量yytext，yyleng及yylineno进行了说明)。

程序 G\[statements\]的递归下降语法分析程序

```cpp


/* Basic parser, shows the structure but there's no code generation */

#include <stdio.h>
#include "lex.h"

statements ( )
{
/* statements → expression SEMI
 *| expression SEMI statements
*/

	expression( );

	if (match (SEMI))
		advance( );
	else
		fprintf (stderr, "%d: Inserting missing semicolon＼n", yylineno);

	if (!match (EOI))
		statements ( );/* Do another statement. */
}

expression( )
{
/* expression → term expression′ */

	term( );
	exprprime( );
}

exprprime( )
{
/* expression′ → PLUS term expression′
 *| epsilon
 */

	if (match (PLUS))
	{
		advance ( )；
		term( )；
		exprprime( );
	}
}

term( )
{
/* term → factor term′ */

	factor( )；
	termprime( );
}

termprime( )
{
/* term′→TIMES factor term′
 *| epsilon
 */

	if (match (TIMES))
	{
		advance( );
		factor( );
		termprime( );
	}
}

factor( )
{
/* factor → NUMORID
 *| LP expression RP
 */

	if (match (NUMORID))
		advance( );

	else if (match (LP))
	{
		advance( );
		expression( );
		if (match(RP))
			advance( );
		else
			fprintf (stderr, "%d: Mismatched parenthesis＼n", yylineno);
	}else
		fprintf (stderr, "%d： Number or identifier expected＼n", yylineno);
}
```






利用程序41进行语法分析时，我们约定，如果当前的输入符号不是应出现的符号 (例如，对于第37行，当前的输入符号不是加号)，则用相应的ε产生式进行推导。另外，上述程序有两个比较明显的缺点： 一是频繁的递归调用将使工作效率大为降低；二是缺乏较完善的语法检查和出错处理。这可通过适当改写文法和扩充程序的功能来改善。例如，可将原文法改写为如下的文法

```
G′［statements］:
statements→{expression;}
expression→term{+term}
term→factor{*factor}
factor→numorid | (expression)*
```

此时，对一些子程序的递归调用就可用一段代码的重复执行来代替。于是，对于文法G′［statements］，可写出改进的递归下降分析程序如程序42所示。
程序 42改进的递归下降语法分析程序

```cpp
/* Revised parser */

#include <stdio.h>
#include "lex.h"

voidfactor(void);
voidterm(void);
voidexpression(void);

statements( )
{
/* statements → expression SEMI | expression SEMI statements */

	while (!match (EOI))
	{
		expression( );

		if (match (SEMI))
			advance( );
		else
			fprintf (stderr, "%d: Inserting missing semicolon＼n", yylineno);
	}
}

voidexpression( )
{
/* expression → term expression′
 * expression′ → PLUS term expression′ | epsilon
 */

	if (!legallookahead (NUMORID, LP,0))
		return;

	term( );
	while (match (PLUS))
	{
		advance( );
		term( );
	}
}

voidterm( )
{
	if (!legallookahead (NUMORID, LP,0))
		return;

	factor( );
	while (match (TIMES))
	{
		advance( );
		factor( );
	}
}

voidfactor( )
{
	if (!legallookahead (NUMORID, LP,0))
		return;

	if (match (NUMORID))
		advance( );
	else if (match (LP))
	{
		advance( );
		expression( );
		if (match (RP))
			advance( );
		else
			fprintf (stderr, "%d: Mismatched parenthesis＼n", yylineno);
	}else
		fprintf (stderr, "%d: Number or identifier expected＼n", yylineno);
}
```



在程序42的expression( )、term( )及factor( )等三个函数中，都调用了一个名为legallookahead的函数。此函数的实参是相应非终结符FIRST集合中的各个元素，并且用一个0作为最后一个实参，其功能是： 检查当前的输入符号是否属于相应非终结符的FIRST集，若是其中的元素，则继续进行语法分析；否则，除报错外，还逐个删除输入串中的符号，直到出现属于该FIRST集中的某个符号为止。
     下面，我们列出函数legallookahead的代码如程序43所示。
     程序 43函数legallookahead



```cpp
#include <stdarg.h>

#define MAXFIRST 16
#define SYNCHSEMI

intlegallookahead (firstarg)
intfirstarg;
{
/* Simple error detection and recovery. Arguments are a 0terminated list of
 * those tokens that can legitimately come next in the input. If the list is
 * empty, the end of file must come next. Print an error message if
 * necessary. Error recovery is performed by discarding all input symbols
 * until one that's in the input list is found
 *
 * Return true if there's no error or if we recovered from the error,
 * false if we can't recover.
 */

	valistargs;
	inttok;
	intlookaheads ［MAXFIRST］, *p=lookaheads, *current;
	interrorprinted=0;
	intrval=0；

	vastart (args, firstarg);

	if (!firstarg)
	{
		if(match (EOI))
		rval =1;
	}
	else
	{
		*p++=firstarg;
		while ((tok=vaarg(args, int)) && p＜&lookaheads［MAXFIRST］)
		*++p=tok;

		while (!match (SYNCH))
		{
			for (current = lookaheads; current ＜ p; ++currrent)
				if (match (*current))
				{
					rval = 1;
					goto exit;
				}

			if (!errorprinted)
			{
				fprintf (stderr, "Line %d: Syntax error＼n", yylineno);
				errorprinted = 1;
			}

			advance( );
		}
	}

	exit;
	vaend (args)
	return rval;
}
```



---恢复内容结束---



[好文要顶](javascript:void(0);) 

