# 模板元编程


### 模板基础

### 默认参数

### 数组长度模板
整数也可以作为模板参数

``` cpp
#include <iostream>

template <int N>
void show_times(std::string msg) {
    for (int i = 0; i < N; i++) {
        std::cout << msg << std::endl;
    }
}

int main() {
    show_times<1>("one");
    show_times<3>("three");
    show_times<4>("four");
}
```


上面我们提到了整数作为模板参数，那c++为什么要支持整数作为模板参数呢，你可能会想，模板只需要支持 class T 不就行了？反正 int N 可以作为函数的参数传入，模板还不支持浮点。
`template <int N> void func();`和`void func(int N);`一个是模板参数，一个是函数参数，有什么区别？有很大区别！

`template <int N> `传入的 N，是一个编译期常量，每个不同的 N，编译器都会单独生成一份代码，从而可以对他做单独的优化。
而 `func(int N)`，则变成运行期常量，编译器无法自动优化，只能运行时根据被调用参数 N 的不同。
比如 `show_times<0>() `编译器就可以自动优化为一个空函数。因此模板元编程对高性能编程很重要。
通常来说，模板的内部实现需要被暴露出来，除非使用特殊的手段，否则，定义和实现都必须放在头文件里。
但也正因如此，如果过度使用模板，会导致生成的二进制文件大小剧增，编译变得很慢等。


### enable_if
std::enable_if 顾名思义，满足条件时类型有效。作为选择类型的小工具，其广泛的应用在 C++ 的模板元编程（meta programming）中。它的定义也异常的简单：
``` cpp
template <bool, typename T=void>
struct enable_if {
};

template <typename T>
struct enable_if<true, T> {
  using type = T;
};
```
~~第一个结构是泛化，第二个是特化?由于有true特化，泛化也退化成false特化情况~~


enable_if_t就是enable_if::type的重定义


在模板实例化时， 对于一个模板调用可能有多个函数匹配，编译器发现一组匹配之后，兴冲冲的使用改组匹配，却在函数体内出现了编译错误，导致匹配全盘失败。

这种情况应该使用enable_if，enable_if 可以提前拒绝错误匹配参数，避免进入函数体发现编译错误；然后才能发现其他无错误的匹配。

可以用于
- 类型偏特化
- 函数返回匹配
- 函数参数匹配



``` cpp
template <typename T, typename = typename std::enable_if<std::is_integral<T>::value>::type>
bool is_even(T t) {
  return !is_odd(t);
}
// 第二个 typename省略了类型名，第三个typename强调表达式时type，
// std::is_integral<>::value 是 类型运算。
// enable_if判断成功时，enable_if实例结构含有type定义
// enable_if判断失败时，enable_if实例结构是空结构，没有type定义
```

``` cpp
template <typename T>
typename std::enable_if<std::is_integral<T>::value, bool>::type
is_odd(T t) {
  return bool(t%2);
}
// 匹配成功就返回bool类型
```

### 全特化

在一个模板类既有全特化又有偏特化还有本身的情况下，匹配的优先级是

全特化>偏特化>原来那个

### partial specializations
偏特化


模板函数不直接支持特化。**函数模板不支持偏特化，但由于可以对函数进行重载，所以可以达到类似与模板偏特化的效果**。

### is_integral
定义于头文件 <type_traits>	

``` cpp
template< class T >
struct is_integral;
```


static is_integral::value  , 如果 T 是整数类型，则为true，否则为 false


(since C++11)
检查 T 是否为整数类型。提供等于 true 的成员常 value ，如果 T 是类型 bool 、 char 、 char8_t (C++20 起)、 char16_t 、 char32_t 、 wchar_t 、 short 、 int 、 long 、 long long 或任何实现定义的扩展整数类型，包括任何有符号、无符号和 cv 限定的变体。否则， value 等于 false 。

is_integral 或 is_integral_v (C++17 起)添加特化的程序的行为是未定义的。


编译器通过类型运算，实现元编程。支持结构的静态类型定义，不占内存空间。支持名字空间的类型定义。

is_integral

``` cpp
template< class T >
inline constexpr bool is_integral_v = is_integral<T>::value;
```


#### Example
``` cpp
#include <iostream>
#include <iomanip>
#include <type_traits>
 
class A {};
 
enum E : int {};
 
template <class T>
T f(T i)
{
    static_assert(std::is_integral<T>::value, "Integral required.");
    return i;
}
 
#define SHOW(...) std::cout << std::setw(29) << #__VA_ARGS__ << " == " << __VA_ARGS__ << '\n'
 
int main()
{
    std::cout << std::boolalpha;
 
    SHOW( std::is_integral<A>::value );
    SHOW( std::is_integral_v<E> );
    SHOW( std::is_integral_v<float> );
    SHOW( std::is_integral_v<int> );
    SHOW( std::is_integral_v<const int> );
    SHOW( std::is_integral_v<bool> );
    SHOW( f(123) );
}
```


```
   std::is_integral<A>::value == false
        std::is_integral_v<E> == false
    std::is_integral_v<float> == false
      std::is_integral_v<int> == true
std::is_integral_v<const int> == true
     std::is_integral_v<bool> == true
                       f(123) == 123
```

### typename
### typename
typename = int 这种语法的意义是什么？
最近看C++代码，遇到好几次下面这种声明方式：
``` cpp
template <typename T， typename = int>

class tc{

xxxx

};
```
其中`typename=int` 这种语法是什么意思？

如果写成  `template<typename T, typename N=int>`
你就懂了吧？其实这就是缺省类型的定义，但是这个地方省略掉了 N，也许是因为这后边的定义里并没有用到N。简单说，这里用到的知识点是：当一个参数不被使用时，可以把参数名称省略掉。类似的，函数也可以使用类似形式：`void func(int a, int ) { return a; }`
该函数中的第二参数没有被使用，所以可以不写参数名称。



### SFINAE
"Substitution Failure Is Not An Error"


This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error.

This feature is used in template metaprogramming.

### 模板递归

## misc


[SFINAE: Substitution Failure Is Not An Error](https://en.cppreference.com/w/cpp/language/sfinae)