
# 左值(lvalue)和右值(rvalue)
## 左值、右值
在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。

左值(Lvalue) →→ Location
表示内存中可以寻址，可以给它赋值(const类型的变量例外)
右值Rvalue) →→ Read
表示可以知道它的值（例如常数）

1) 对于基础类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰(cv-qualitification ignored)
2) 对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。


左值符号 &
右值符号 &&
在C++中，临时对象不能作为左值，但是可以作为常量引用，const &。
C++ 11中的std::move可将左值引用转化成右值引用。


## 右值、将亡值
在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。

C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。

将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

通过右值引用，这个将亡的右值又“重获新生”，它的生命周期与右值引用类型变量的生命周期一样，只要这个右值引用类型的变量还活着，那么这个右值临时量就会一直活着，这是一重要特性，可利用这一点会一些性能优化，避免临时对象的拷贝构造和析构。

## 左值引用&右值引用
左值引用包括常量左值引用和非常量左值引用。非常量左值引用只能接受左值，不能接受右值；常量左值引用是一个“万能”的引用类型，可以接受左值（常量左值、非常量左值）、右值。不过常量左值所引用的右值在它的“余生”中只能是只读的。
``` c++
int &a = 2;       // 非常量左值引用 绑定到 右值，编译失败
 
int b = 2;        // b 是非常量左值
const int &c = b; // 常量左值引用 绑定到 非常量左值，编译通过
 
const int d = 2;  // d 是常量左值
const int &e = d; // 常量左值引用 绑定到 常量左值，编译通过
const int &f =2;  // 常量左值引用 绑定到 右值，编译通过
```
右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。比如：

``` c++
int a;
int &&r1 = a;             // 编译失败
int &&r2 = std::move(a);  // 编译通过
```
## 
universal references
### 引用折叠规则


