# [C++ 虚析构函数](https://www.cnblogs.com/justinyo/archive/2013/04/14/3020677.html)

类型需要虚析构函数的另外一个特征 是该类型具有指针成员或引用成员。如果有指针成员和引用成员，则该类型通常需要实现析构函数以及拷贝操作。

 

通常，一个实现了析构函数的类型同时也需要实现拷贝构造函数与拷贝复制函数。

 

作为一个经验法则：

如果你有一个带有虚函数功能的类，则它需要一个虚析构函数，原因如下：

 

\1. 如果一个类有虚函数功能，它经常作为一个基类使用。

 

2.如果它是一个基类，它的派生类经常使用new来分配。

 

3.如果一个派生类对象使用new来分配，并且通过一个指向它的基类的指针来控制，那么它经常通过一个指向它的基类的指针来删除它（如果基类没有虚析构函数，结果将是不确定的，实际发生时，派生类的析构函数永远不会被调用）。

基类有虚析构函数的话，最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。

 

在C++中，不能声明虚构造函数,但可以声明虚析构函数。多态性是指不同的对象对同一消息有不同的行为特性。虚函数作为运行时多态性的基础，主要是针对对象的，而构造函数是在对象产生之前运行的，因此虚构造函数是没有意义的。

   析构函数的功能是在该类对象消亡之前进行一些必要的清理工作，析构函数最好都是virtual的。

   首先解释一下虚构函数和指针之间是如何交互的，以及虚析构函数的具体含义。例如以下代码，其中SomeClass是含有非virtual析构函数的一个类：

   SomeClass *p= new SomeClass;

   . . . . . .

   delect p;

为p调用delect时，会自动调用SomeClass类的析构函数。现在，再来看看将析构函数标记为virtual之后，会发生什么事情。

   描述析构函数与虚函数机制的交互时，最简单的表述是：将所有析构函数都视为具有相同的名字（即使它们并非真的同名）。例如，假定Derived类是Base类的一个派生类，并假定Base类中的析构函数标记为virtual。现在来分析以下代码：

　　Base *pBase= new Derived;

   . . . . . .

   delect pBase;

为Base调用delect时,会调用一个析构函数。由于Base类中的析构函数标记为virtual，而且指向的对象属于Derived类型，所以会调用Base类中的析构函数。

　　应注意的一点是，将析构函数标记为virtual后，派生类所有的析构函数都自动成为virtual的（不管时候用virtual来标记它们）。同样地，这种行为就好象所有析构函数都具有相同的名字（即使事实上不同名）。

　　下面说的是将所有析构函数都标记为virtual的好处。假定Base类有一个指针类型的成员变量pB,Base类的构造函数会创建由pB指向的一个动态变量，而Base类的析构函数会删除pB指向的动态变量。另外，假定Base类没有标记为virtual，并假定Derived类(它从Base派生)有一个指针类型的成员变量pD,Derived类的构造函数会创建有pD指向的一个动态变量，而Derived类的析构函数会删除pD指向的动态变量。分析一下以下代码：

　　Base *pBase= new Derived;

   . . . . . .

   delect pBase;

由于基类中的析构函数没有标记为virtual，所以只会调用Base类的析构函数。它会将pB指向的动态变量占用的内存返还给自由存储。但是，对于pD指向的动态变量来说，它占用的内存永远不会返还给自由存储（除非程序终止）。

　　另一方面，如果基类Base的析构函数标记为virtual，那么为pBase调用delect时，就会调用Derived类的析构函数（因为指向的对象属于Derived类型）。Derived类的析构函数会删除pD指向的动态变量，再自动调用基类Base的析构函数。后者会删除pB指向的动态变量。因此，将基类析构函数标记为virtual之后，所有内存都能成功地由自由存储回收。为了准备好迎接这种情况，最好总是将析构函数标记为virtual。

　　虚析构函数的工作方式是从最深的派生类的析构函数依次调用其基类的析构函数，直至初始基类的析构函数得到调用为止。

标签: [C/C++语法](https://www.cnblogs.com/justinyo/tag/C%2FC%2B%2B语法/)