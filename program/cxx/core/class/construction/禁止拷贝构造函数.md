# 禁止拷贝构造函数

陈尘  于 2017-10-21 00:15:04 发布  1994  收藏 2
分类专栏： C++学习 文章标签： c++
版权

C++学习
专栏收录该内容
2 篇文章0 订阅
订阅专栏
拷贝构造函数在四种情况下被调用：

1、对象以值传递的方式传入函数参数
2、对象以值传递的方式从函数返回
3、新建一个对象并将其初始化为同类现有对象

如果我们没有显式的定义并实现拷贝构造函数，编译器会生成一个默认的拷贝构造函数。这种默认有时候会带来一些不利的影响，因为默认拷贝构造函数是对非静态类成员的简单逐一拷贝（拷贝构造函数没有处理静态数据成员），此时若有指针等，会有意想不到的麻烦，也就是浅复制的局限所在。

如果想要阻止系统自动生成可能不利的默认拷贝构造函数，可以自己对拷贝构造函数进行定义，如深复制（如果类中包含了使用new初始化的指针，应当定义一个拷贝构造函数，以复制指向的数据，而不是指针）。

除了自定义拷贝构造函数外，有的时候还需要重载赋值运算符，因为编译器依然会默认生成一个浅复制的赋值运算符。

但是在实际的开发中，我们往往不希望一个对象进行拷贝，此时如果在不自定义拷贝构造函数的同时，阻止编译器生成默认拷贝构造函数呢？

（1）声明一个私有拷贝构造函数
首先，所有的编译器生成的函数都是公有的（public），如果将拷贝构造函数和赋值运算符重载声明为private，那么将一举两得，第一阻止了编译器自己生成默认构造函数，第二private权限将使得该函数无法被外部自动调用。

但是，上述方法仅仅阻止了类外部的调用，类的成员函数和友元函数依然可以调用拷贝构造函数。假如我们没有去定义这两个讨厌的函数，那么就能解决这个问题，因为调用时编译器会出现链接错误（而不是编译错误）。

（2）继承一个uncopyable类
C++的编译在链接之前，如果我们能在编译期解决这个问题，会节省不少的时间，要想在编译期解决问题，就需要人为制造一些bug。我们声明一个专门阻止拷贝的基类uncopyable。

```cpp
class uncopyable{
protected:
    uncopyable(){}
    ~uncopyable(){}
private:
    uncopyable(const uncopyable&);
    uncopyable& operator=(const uncopyable&);
}
```



接下来，我们的类只要继承uncopyable，如果要发生拷贝，编译器都会尝试调用基类的拷贝构造函数或者赋值运算符，但是因为这两者是私有的，会出现编译错误。
————————————————
版权声明：本文为CSDN博主「陈尘」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/chenych27/article/details/78300708