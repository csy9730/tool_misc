# vector 子类 父类

C++ vector中如何存放一个基类的不同派生类？
可以不通过指针来实现吗？ 


vector假定了每个元素的存放大小都是sizeof(T)，而不同派生类的大小可能是不同的。当然啦大小不同也可以用variant来包一包，但这个时候你存的其实是一个新的类型，类型擦除的效果不存在了。就算大小都相同，你也要考虑放入容器时发生的类型转换问题，因为vector的元素类型是Father，所有传入的元素都会被转化/构造为Father，而对于它的派生类，这个路径一般是Son隐式转化为Father，然后做copy/move，实际上所有的元素都已经是事实上的Father了。当然你也可以不用vector，自己搞一个不做类型转换的容器，inplace构造，但既然你都写容器了，不碰指针是不可能了。

作者：XZiar
链接：https://www.zhihu.com/question/349405536/answer/847290166
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

如果你只是不想出现Father*，那用unique_ptr<Father>不好吗？只要你有虚析构函数。

既然你在使用C++，你必须以更底层的方式思考这个问题：std::vector存储的内容，内存布局是连续的，而且每个物体的内存尺寸必须相同。所以，如果在vector容器里存储对象的本体而不是指针，显然只能存一种类型，因为不同类型的尺寸无法保证一样

### tagged union

总结一下：一派实现是 tagged union，也即 variant，这样基于值的语义就能完成；但是缺点是每派生出一种新的类型，variant 的类型参数里就要多加一种，显然这样的代码难以维护另一派，也是唯一比较现实点的方案就是基于指针语义了。只不过各种具体的实现方案相对比也是良莠不齐。vector<Base*> 是最差劲的一种，你必须手动管理好 new 出的指针，否则一不小心就忘了 delete，造成内存泄露了。vector<智能指针> 是限定必须完全使用 STL，不引入外部库的条件下，比较可行的方案，但也不够理想。最好的还是 boost 的 ptr_vector，它就是为了解决 std::vector 仅基于值语义的痛点而设计出的基于指针语义的容器，最为适合这样的场景

作者：IceBear
链接：https://www.zhihu.com/question/349405536/answer/848812510
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。