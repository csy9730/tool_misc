# vector

vector 的底层实现是array，通过重新分配内存，复制，清理内存的方法实现扩容。

由于存在扩容机制，导致指针的可能失效。

为了支持快速的随机访问，vector将元素连续存储。

当添加新的元素时，容器必须分配新的内存空间来存储改变后的元素。将已有的元素从旧位置移动到新空间中，然后添加新元素。释放原有的存储空间。这样的操作性能较差，难以应对连续的不断增长。

故为了避免这个问题，采用了可以减少容器重新分配空间的策略。在分配新的空间时，容器会申请比需求更大的内存空间，作为备用。这种操作效率很高，vector的增长速度可以超过list或deque。在当迫不得已的时候分配新的内存给容器。
## api

WARNING: STL容器并非是线程安全的。


#### size
size表示已经保存的元素数目；
#### capacity
而capacity表示不分配新的内存空间下，最多可保存的元素数目。
#### swap
swap操作不会对任何元素进行拷贝，删除插入，可以在常数时间内完成操作。故指向容器的迭代器，引用，指针在swap操作之后不会失效。

#### assign
由于赋值运算符要求左边和右边的运算对象具有相同的类型。所以定义assign的成员，允许从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。

#### 插入
``` cpp
push_front()
push_back()
insert();
```
#### 删除
``` cpp
c.pop_back()      // 删除末尾的元素。
c.pop_front()     //  删除第一个元素。
```
#### emplace

c++11引入了emplace等操作。对应原有的push等操作。当调用一个emplace成员函数时，将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素，避免了拷贝。传递的参数必须与元素类型的构造函数相对应。

### misc

**Q**: “vector”: 不是“std”的成员

**A**:


``` cpp
#include<vector>

std::vector<int> a;

```