# malloc


## malloc

malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。

其函数原型为`void *malloc(unsigned int size)`；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。

如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用`free()`函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。

关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。它能向系统申请分配一个长度为num_bytes（或size）个字节的内存块。

一般它需和free函数配对使用。free函数能释放某个动态分配的地址，表明不再使用这块动态分配的内存了，实现把之前动态申请的内存返还给系统。
### 工作机制
malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表的功能。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。

Linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。

### 与new的区别
从本质上来说，malloc（Linux上具体实现可以参考man malloc，glibc通过brk()&mmap()实现）是libc里面实现的一个函数，如果在source code中没有直接或者间接include过stdlib.h，那么gcc就会报出`error：‘malloc’ was not declared in this scope`。如果生成了目标文件（假定动态链接malloc），如果运行平台上没有libc（Linux平台，手动指定LD_LIBRARY_PATH到一个空目录即可），或者libc中没有malloc函数，那么会在运行时（Run-time）出错。new则不然，是c++的关键字，它本身不是函数。new不依赖于头文件，c++编译器就可以把new编译成目标代码（g++4.6.3会向目标中插入_Znwm这个函数，另外，编译器还会根据参数的类型，插入相应的构造函数）。

在使用上，malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。而 malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。另外有一点不能直接看出的区别是，malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。
## calloc

C 库函数 `void *calloc(size_t nitems, size_t size)` 分配所需的内存空间，并返回一个指向它的指针。malloc 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。

声明
下面是 calloc() 函数的声明。

`void *calloc(size_t nitems, size_t size)`

- 参数
  - nitems -- 要被分配的元素个数。
  - size -- 元素的大小。
- 返回值
  - 该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。

## realloc

`void* realloc(void* ptr, unsigned newsize);`



### free的sizeof计算
一般来说，c/c++在申请内存的时候，需要new/delete、malloc/free必须配对使用。c语言调用malloc申请内存的时候，需要调用free释放内存。free是如何知道应该释放多少内存的呢？free在释放内存的时候，会根据传入的地址往前偏移4个字节，这个4个字节保存了需要释放的内存字节数。new与delete同理。当delete的时候，也是根据传入的指针，往前偏移4个字节，得到需要释放的内存字节数。陈硕说不一定是4个字节，具体需要跟具体的内存对齐相关。（通常的编译器都是把n放在前面，至少占size_t，而且按class/struct的要求对齐，因此不一定是4字节。）
