[一曲挽歌](https://www.cnblogs.com/yiquwange/)

## [FPGA基础——锁存器latch](https://www.cnblogs.com/yiquwange/p/15160529.html)

**一、是什么**

​    锁存器是一种在异步时序电路系统中，对输入信号电平敏感的单元，用来存储信息。一个锁存器可以存储1bit的信息，通常，锁存器会多个一起出现，如4位锁存器，8位锁存器。

​    锁存器在数据未锁存时，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号有效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入是透明的。

**二、锁存器与寄存器的区别：**

​    两者都是基本存储单元，单锁存器是电平触发的存储器，触发器是边沿触发的存储器。本质是，两者的基本功能是一样的，都可以存储数据。意思是说一个是组合逻辑的，一个是在时序电路中用的，时钟触发的。

 **三、锁存器的危害：**     

- 对毛刺敏感，不能异步复位，所以上电以后处于不确定的状态；
- Latch会使静态时序分析变得非常复杂；
- 在PLD芯片中，基本的单元是由查找表和触发器组成的，若生成锁存器反而需要更多的资源。

   第三条也是最基本的原因。

**四、产生的原因** 

   上面说了那没多只是觉得网上的没把锁存器说明白。下面的才是重点。

**在时序逻辑中，不完整的 if…else… 结构并不会生成锁存器**，而组合逻辑中不完整的 if…else… 结构就会生成锁存器。

> 1，case
>
> 2，if-------else if
>
> 3，always@（敏感信号表）

**五、解决**

1.case——————加default：

> 关于defalut的情况：一是可以 default：data=1‘bx；这个x表示未知，在综合时可以避免产生锁存器。在仿真时是红线表示。  二是 default：data=0；这样产生一个默认的情况。

2.if——————一定要有else语句。

3.always————如是说道：在赋值表达式右边参与赋值的信号都必须在always@（敏感电平列表）中列出。

> 如果在赋值表达式右端引用了敏感电平列表中没有列出的信号，那么在综合时，将会为该没有列出的信号隐含地产生一个透明锁存器。

\4. 赋初值。

 

**六、怎么看到锁存器**

![img](https://img-blog.csdn.net/20170314203546352)

![img](https://img-blog.csdn.net/20170314203350586)

当然，ISE会对锁存提出警告。

一位网友指出：FPGA是一种基于查找表形式工作的，而锁存器相当于存在一个没有直接说明的状态，保持之前的值造成了锁存。

 

**七、只要语句完整就不会有锁存器吗**

  在很多情况下，我们希望某个值保值其原有值，既不一定是0，也不一定是1，只需要保持。比如下面代码：

```
always @ (a or data_in)
    if(a) 
　　    data_out=data_in;
    else 
　　    data_out=data_out;
```

  这个时候if/else文件是完整，但是依然产生了锁存器，因为我们这个电路所描述的功能就是一个锁存器。其实语句不完整和else data_out=data_out;是一样的。在这里，我所希望的就是保持数值，但这种情况可以通过增加一个寄存器来保持，也不应该生成一个锁存器。

最后，锁存器只存在于组合电路中，在时序电路上是不存在的。

 

原文链接：[关于verilog中if与case语句不完整产生锁存器的问题](https://blog.csdn.net/qq_36126787/article/details/62054204?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

分类: [FPGA基础](https://www.cnblogs.com/yiquwange/category/1952563.html)