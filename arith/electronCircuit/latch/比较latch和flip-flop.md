触发器：flipflop，锁存器：latch，寄存器：register

#### 锁存器

锁存器是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值，尽当锁存器处于使能状态时，输出才会随着数据输入发生变化。

#### 触发器

触发器是边沿敏感的存储单元，数据存储的动作有某一信号的上升或者下降沿进行同步的。

#### 寄存器

寄存器用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储1位二进制数，所以由N个锁存器或触发器可以构成N位寄存器。 触发器是在时钟的沿进行数据的锁存的，而锁存器是用电平使能来锁存数据的。所以触发器的Q输出端在每一个时钟沿都会被更新，而锁存器只能在使能电平有效器件才会被更新。 有一些教科书里的触发器实际是锁存器。在FPGA设计中建议如果不是必须那么应该尽量使用触发器而不是锁存器。

钟控D触发器其实就是D锁存器，边沿D触发器才是真正的D触发器，钟控D触发器在使能情况下输出随输入变化，边沿触发器只有在边沿跳变的情况下输出才变化







### 比较

20、D 触发器和D 锁存器的区别。
两 个锁存器可以构成一个触发器,归根到底还是dff是边沿触发的，而latch是电平触发的。锁存器的输出对输入透明的，输入是什么，输出就是什么，这就是 锁存器不稳定的原因，而触发器是由两个锁存器构成的一个主从触发器，输出对输入是不透明的，必须在时钟的上升/下降沿才会将输入体现到输出，所以能够消除 输入的毛刺信号。

21、latch和filp-flop的异同
都 是时序逻辑，但latch受所有的输入信号控制，只要输入信号变化，latch就变化。也正因为如此，latch很容易出毛刺。flip-flop是触发 器，只有在被时钟触发时才采样当前的输入，产生输出。如果使用门电路来搭建latch和ff，则latch消耗的门资源比ff要少。但是你用的如果是 fpga，那么内部一般带DFF单元，反而用触发器更好。

22、latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的
行为级描述中latch一般是由于if货case逻辑表述不完全产生的。
异同：
1、latch由电平触发，非同步控制。在使能信号有效时latch相当于通路，在使能信号无效时latch保持输出状态。DFF由时钟沿触发，同步控制。
2、latch容易产生毛刺（glitch），DFF则不易产生毛刺。
3、 如果使用门电路来搭建latch和DFF，则latch消耗的门资源比DFF要少，这是latch比DFF优越的地方。所以，在ASIC中使用 latch的集成度比DFF高，但在FPGA中正好相反，因为FPGA中没有标准的latch单元，但有DFF单元，一个LATCH需要多个LE才能实 现。
4、latch将静态时序分析变得极为复杂。



一般的设计规则是：在绝大多数设计中避免产生latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用D触发器的地方，就不用latch。
有 些地方没有时钟，也只能用latch了。比如现在用一个clk接到latch的使能端(假设是高电平使能),这样需要的setup时间，就是数据在时钟的 下降沿之前需要的时间，但是如果是一个DFF，那么setup时间就是在时钟的上升沿需要的时间。这就说明如果数据晚于控制信号的情况下，只能用 latch,这种情况就是，前面所提到的latch timing borrow。基本上相当于借了一个高电平时间。也就是说，latch借的时间也是有限的。

关 于latch的讨论 latch和flip-flop都是时序逻辑，区别为：latch同其所有的输入信号相关，当输入信号变化时latch就变化，没有时钟端；flip- flop受时钟控制，只有在时钟触发时才采样当前的输入，产生输出。当然因为二者都是时序逻辑，所以输出不但同当前的输入相关还同上一时间的输出相关。
latch缺点：
1、没有时钟端，不受系统同步时钟的控制，无法实现同步操作；
2、对输入电平敏感，受布线延迟影响较大，很难保证输出没有毛刺产生；



在 xilinx和altera器件的slice和LE中都能够同时支持生产d-latch和d-ff，在这一层面上二者有什么区别暂时没有想到。如果使用门 电路来搭建latch和ff，则latch消耗的门资源比ff要少，这是latch比ff优越的地方。 latch的最大缺点就是没有时钟端，和当前我们尽可能采用时序电路的设计思路不符。 latch是电平触发，相当于有一个使能端，且在激活之后（在使能电平的时候）相当于导线了，随输出而变化，在非使能状态下是保持原来的信号，这就可以看 出和flip-flop的差别，其实很多时候latch是不能代替ff的 1.latch对毛刺敏感
2.在ASIC中使用latch的集成度比DFF高，但在FPGA中正好相反，因为FPGA中没有标准的latch单元，但有DFF单元，一个LATCH需要多个LE才能实现
3.latch将静态时序分析变得极为复杂
\4. 目前latch只在极高端电的路中使用，如intel 的P4等CPU。 FPGA中有latch单元，寄存器单元就可以配置成latch单元，在xilinx v2p的手册将该单元成为register/latch单元，附件是xilinx半个slice的结构图。其它型号和厂家的FPGA没有去查证。——个人 认为xilinx是能直接配的而altera或许比较麻烦，要几个LE才行，然而也非xilinx的器件每个slice都可以这样配置
altera的只有DDR接口中有专门的latch单元，一般也只有高速电路中会采用latch的设计。
altera的LE是没有latch的结构的
又查了sp3和sp2e，别的不查了，手册上说支持这种配置。有关altera的表述wangdian说的对，altera的ff不能配置成latch，它使用查找表来实现latch，

一般的设计规则是：在绝大多数设计中避免产生ＬＡＴＣＨ．
它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出．
latch最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。
所以，只要能用D触发器的地方，就不用latch。
有些地方没有时钟，也只能用latch了。

很简单一个例子来说明:
比 如现在用一个clk接到latch的使能端(假设是高电平使能),这样需要的setup时间,就是数据在时钟的下降沿之前需要的时间,但是如果是一个 DFF,那么setup时间就是在时钟的上升沿需要的时间.这就说明如果数据晚于控制信号的情况下，只能用latch,这种情况就是,前面所提到的 latch timing borrow.基本上相当于借了一个高电平时间.也就是说，latch借的时间也是有限的.

对latch进行STA的分析其实也是可以,但是要对工具相当熟悉才行.不过很容易出错.当前PrimeTime,是支持进行latch分析的.现在一些综合工具内置的STA分析功能也支持,比如RTL compiler, Design Compiler.
除了ASIC里可以节省资源以外。
我感觉latch这个东西在同步设计里出现的可能还是挺小的吧，
现在处理过程中大都放在ff里打一下，
影响不太大吧

 

标签： 无标签latch与DFF的区别 收集了一下网上资源，总结如下：1、latch由电平触发，非同步控制。在使能信号有效时latch相当于通路，在使能信号无效时latch保持输出状 态。DFF由时钟沿触发，同步控制。2、latch容易产生毛刺（glitch），DFF则不易产生毛刺。3、如果使用门电路来搭建latch和DFF， 则latch消耗的门资源比DFF要少，这是latch比DFF优越的地方。所以，在ASIC中使用latch的集成度比DFF高，但在FPGA中正好相 反，因为FPGA中没有标准的latch单元，但有DFF单元，一个LATCH需要多个LE才能实现。4、latch将静态时序分析变得极为复杂。 一般的设计规则是：在绝大多数设计中避免产生latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch最大的危害在于不能过 滤毛刺。这对于下一级电路是极其危险的。所以，只要能用D触发器的地方，就不用latch。 有些地方没有时钟，也只能用latch了。比如现在用一个clk接到latch的使能端(假设是高电平使能),这样需要的setup时间，就是数据在时钟 的下降沿之前需要的时间，但是如果是一个DFF，那么setup时间就是在时钟的上升沿需要的时间。这就说明如果数据晚于控制信号的情况下，只能用 latch,这种情况就是，前面所提到的latch timing borrow。基本上相当于借了一个高电平时间。也就是说，latch借的时间也是有限的。 在if语句和case不全很容易产生latch，需要注意。VIA题目这两个代码哪个综合更容易产生latch：
代码1
always@(enable or ina or inb)
begin
if(enable)
begin
data_out = ina;
end
else
begin
data_out = inb;
end
end
代码2
input[3:0] data_in;
always@(data_in)
begin
case(data_in)
0 : out1 = 1'b1;
1,3 : out2 = 1'b1;
2,4,5,6,7 : out3 = 1'b1;
default: out4 = 1'b1;
endcase
end
答案是代码2在综合时更容易产生latch。





***\*（二）\****

***\*![img](https://img-blog.csdn.net/20170223144613854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaF9raW5nb25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
\****

***\*
\****

***\*（三）\****



FPGA设计中总是讲到要避免使用latch，那么使用latch到底有什么坏处呢？这个问题想了很久也没有得到一个令自己满意的答案，这里我先把自己的一些看法表述一下，请大家就这个问题讨论讨论。
latch和flip-flop都是时序逻辑，区别为：latch同其所有的输入信号相关，当输入信号变化时latch就变化，没有时钟端；flip-flop受时钟控制，只有在时钟触发时才采样当前的输入，产生输出。当然因为二者都是时序逻辑，所以输出不但同当前的输入相关还同上一时间的输出相关。
latch缺点：
1、没有时钟端，不受系统同步时钟的控制，无法实现同步操作；
2、对输入电平敏感，受布线延迟影响较大，很难保证输出没有毛刺产生；
在xilinx和altera器件的slice和LE中都能够同时支持生产d-latch和d-ff，在这一层面上二者有什么区别暂时没有想到。如果使用门电路来搭建latch和ff，则latch消耗的门资源比ff要少，这是latch比ff优越的地方。

\------------------------------------------------

简单回答就是Latch是异步电路，flip-flop是同步电路
既然是同步电路，肯定有clock端了，而latch就没有
但是在IC设计中，latch相对flip-flop只占用其三分之一的硅
面积。
register一般是由Latch or flip-flop实现的