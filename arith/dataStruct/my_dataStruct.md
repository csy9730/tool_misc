# my data struct


|--|address|key|index|value|node|
|--|--|--|--|--|--|
|array|`&p[index]`|-|全局索引|v|
|vector|`&p[index]`|--|全局索引|v| |
|deque|`*p++`|--|相对索引|v| |
|list|node|--|-|v|一个结点|
|dblist|node|--|-|v|一前一后，两个结点|
|tree|node|--|--|v|多个结点|
|hash|`p[hash(v)]`|--|--|v|-|


数据结构的核心

跳表和树类似，都是多层索引。
跳表是一层实链表，多层索引指针。跳表横向访问相当于访问树的兄弟结点，多叉树的多个子结点。

区别在于，
- 树的上层索引也能取值，可以避免部分深度访问
- 跳表的上层索引只是纯索引，作为指针不存储值。

二叉树，对应
LSM Tree
### tree

- binary tree 二叉树
- heap
- BST 
  - BST 只适用于静态场景，无法在插入，删除结点时保证左右树平衡
  - AVL 保证左右树平衡，性能较低
  - RB tree 保证左右树接近平衡，性能较AVL高
- b-tree

#### 数组二叉树
传统的二叉树是使用链表的形式,其优点是便于插入和删除,但是查找速度很慢,占用空间也很大.所以现在用数组的形式来构建二叉树,节点存在数组中,而不是由引用相连,节点在数组中的位置对应它在树中的位置,下标为0 的节点为根节点,下标为1是根的左节点,2为根节点的右节点,依次类推,从左到右的顺序存储树的每一层,包括空节点

```
         0，
    1,         2
  3, 4,     5,   6
7,8,9,10,11,12,13,14
```
大多数情况下用数组表示树不是很有效率,除非是完全二叉树.但是普通的二叉树,特别是有很多空节点的.会有很多空洞,浪费存储空间.用数组表示树,删除节点是很费时费力的.



#### BST
二叉排序树(Binary Sort Tree,BST)又称为二叉查找树


- 如果左子树不为空，则左子树上所有结点的值均小于根结点的值。
- 如果右子树不为空，则右子树上所有结点的值均大于根结点的值。
- 左、右子树也分别为二叉排序树。
- 树中没有值相同的结点。(????)

如果用中序遍历来遍历二叉排序树，则遍历结果是一个递增的序列。


#### heap

二叉堆是一种完全二叉树，分大根堆、小根堆两种，子结点总是大于或小于父结点。
大根堆，顾名思义，根是最大的，每个子结点都要小于父结点，不区分左右儿子谁大谁小，也不必保证某个“孙子结点”一定要小于另一个“儿子结点”。

小根堆恰恰相反，根是最小的，每个子结点都要大于父结点，不区分左右儿子谁大谁小，也不必保证某个“孙子结点”一定要大于另一个“儿子结点”。

大根堆只确保父结点大于子结点，不维护左右结点的大小，所以顺序非常薄弱，只能确保根结点最大。

适合用于维护最大值。

#### B-Tree
B-Tree作为一个平衡多路查找树(m-叉)
