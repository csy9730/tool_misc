# 对数组排序后，获取排序前元素索引

### 写在前面

最近基本都在弄实验室的事情，自己设计了两个算法，有大把的数据需要跑，大把的模型需要渲染。。。
在设计的算法中，有一个需求是，对一个double数组OriArray进行排序，排序之后记为SortedArray，现在需要获取SortedArray数组中的每个元素在原始数组OriArray中的索引。
这个需求如果在OC中实现的话蛮简单的，把<原索引，数组元素>作为键值对放入某个字典，按照数组元素对字典进行排序，然后要获取排序后的数组在原始情况下的索引，只需直接访问其key就可以了。但是C++中没有直接的这样的数据结构，因此我们可以自己构造一个。

### 代码实现

按照上文中的思路，构造一个<原索引，数组元素>的数据结构，如下

```cpp
struct node
{
    double data;
    int No;
};
```

排序我们直接使用系统中自带的快排算法。其函数原型如下

```cpp
 qsort(array, num_of_data_in_array,sizeof(array[0]),comp)
```

其中第一个参数为数组名，第二个参数为数组中元素个数，第三个参数为数组中元素的sizeof，第四个元素为排序方式。在我们的需求中，需要排序的是一个结构体，我们需要按照结构体node中data的大小进行升序排序，其比较函数comp定义如下

```cpp
int comp(const void *a, const void *b)
{
    return (*(struct node *)a).data> (*(struct node *)b).data?1:-1;
}
```

函数原型中的函数参数是两个void类型的指针，在函数体中，需要做指针类型转换，然后按照data升序排序。
测试代码如下

```cpp
int main()
{
    double a[] = {3.0, 4.0, 2.5,1.1, 5.6};
    int n = sizeof(a)/sizeof(double);
    struct node arry[sizeof(a)/sizeof(double)];
    int i;
    for(i = 0; i < n;++i)
    {
        arry[i].data = a[i];
        arry[i].No = i;
    }
    qsort(arry,n,sizeof(struct node),comp);
    
    for ( i = 0; i < n; i++)
    {
        arry[i].data = a[i];
        arry[i].No = i;
    }
    qsort(arry, n, sizeof(struct node), comp);
    printf("(当前值，原索引)\n");
    for(i = 0; i < n;++i)
    {
        cout<<arry[i].data<<"\t"<<a[i]<<"\t"<<arry[i].No<<endl;
    }

    system("pause");
    return 0;
}
```

运行结果
![enter description here](https://images2015.cnblogs.com/blog/718109/201606/718109-20160620152815459-647447405.png)

### 总结

对一个数组进行排序后，要获取排序后数组中的某个元素在原始数组中的索引值时，可以使用本文介绍的方法进行排序。其核心就是自己构造一个结构体，结构体中包含原始数组的元素和其对应的索引，然后使用快排对结构体排序，排序之后，可以直接通过结构体获取其元素在原始数组中的索引。

分类: [C++](https://www.cnblogs.com/scut-linmaojiang/category/654786.html)

标签: [快排](https://www.cnblogs.com/scut-linmaojiang/tag/快排/) , [数组](https://www.cnblogs.com/scut-linmaojiang/tag/数组/)