# 图形渲染基础：光栅化算法

[![木头骨头石头](https://pic4.zhimg.com/10cd7b09b5944a1d5e8c0c5a60ac138f_xs.jpg)](https://www.zhihu.com/people/yan-mou-15)

[木头骨头石头](https://www.zhihu.com/people/yan-mou-15)





62 人赞同了该文章



**光栅化算法**得名于光栅化显示器（CRT），其[原理](https://zhuanlan.zhihu.com/p/172458237)在中学物理中就有介绍，这不是本文的重点，只需知道我们最终生成二维图像的过程是从上到下，从左到右一个像素一个像素生成的。根据《计算机图形学原理，第四版》的分类方法，光栅化算法是一种 Object-order rendering。也即遍历场景中每一个物体，然后找到物体对应的像素区域。

图形渲染的一大任务是将三维场景投影到二维平面上，并生成一张二维图像。为了完成这一任务，那么光栅化算法有两大关键，一是投影，二是图元的光栅化。投影解决的是把三维空间中共线的三点变换到指定平面上并且保持共线关系和交比不变，这是一个射影变换，同时也是一个线性变换，因此可以通过矩阵乘法完成；光栅化解决的是图像的生成，投影平面上的图形是连续的，光栅化需要把它们离散化，从而能在显示器上显示或存储在一张位图中。

简单的说光栅化图形流水线分以下四步：

1. 逐顶点操作
2. 图元的扫描转换与插值
3. 逐片元操作
4. 反走样

> 下面内容出现的很多术语借鉴于 OpenGL 和 DirectX，因此会有混用的情况

## 1 图元

在计算机图形学中，基本图元有三种：点；直线；三角形。通过**顶点（Vertex）**，我们可以定义一个图元：

```text
struct Vertex {
    float3 position; // 用三维向量表示顶点的坐标，必选属性

    float2 uv;       // 用二维向量表示 uv 坐标，可选属性
    float3 normal;   // 用三维向量表示法线方向，可选属性
};

class Point {
    Vertex vertices[1];
};

class Line {
    Vertex vertices[2]; // 两点确定一条直线
};

class Triangle {
    Vertex vertices[3]; // 三点确定一个平面
};
```

那么顶点中最重要的属性就是顶点的坐标，其次在完整的图形渲染中，顶点还会包含法线属性，uv 坐标属性等。

最终生成的二维图像通常是有固定分辨率的位图，光栅化算法的核心是通过顶点得到图元投影到屏幕上所覆盖的像素，这部分像素称为片元：

![img](https://pic1.zhimg.com/80/v2-cd2086b8653960f673969f9cfde26f50_1440w.jpg)

其中每个片元除了有顶点所包含的属性外，还额外携带了一个像素坐标，以表示对应图像空间中哪一个像素。这些属性都是在光栅化算法中，通过顶点属性插值得到的。可以说片元就是原图元内部离散化的点。

```text
struct Fragment {
    uint2 screenPos; // 用二维向量表示的图像空间坐标，必选属性

    float3 position; // 用三维向量表示顶点的坐标，通过顶点的插值得到，可选属性
    float2 uv;       // 用二维向量表示 uv 坐标，通过顶点的插值得到，可选属性
    float3 normal;   // 用三维向量表示法线方向，通过顶点的插值得到，可选属性
};
```

------

## 2 逐顶点操作

光栅化流水线的第一步，一个模型中包含若干图元，逐顶点操作的意思是遍历每个图元的每个顶点。

```text
foreach object in objects {
    foreach primitive in object {
        foreach vertex in primitive {
             Do Something ...
        }
    }
}
```

而具体做什么由我们自己定，在现代光栅化硬件中，逐顶点操作可交由用户编程，从而实现丰富的图形效果，称为**顶点着色器**。但通常，为了正确的渲染一个三维场景，我们需要进行如下操作：

1. 顶点的坐标变换
2. 顶点的投影变换
3. 顶点的裁剪
4. 顶点的屏幕映射
5. 顶点着色

> 着色并非本文的重点，这里只是简单的提一下。
> 裁剪也可看成是一个图元操作。



### 2.1 顶点的坐标变换

图元的顶点是定义在三维空间中的，我们最终要把它们变换到屏幕坐标（投影平面坐标）。这其中涉及平移变换、旋转变换、缩放变换（仿射变换）；坐标系变换；投影（射影变换）。

其中仿射变换是一种特殊的射影变换，而射影变换又是一种线性变换。为了执行射影变换，图元的顶点坐标用**齐次仿射坐标**描述，简称**齐次坐标**。

在齐次坐标下，三维空间的普通点描述为： ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%2Cz%2C1%29) ，三维空间的向量描述为： ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%2Cz%2C0%29) 。这么做的意义在于两点相减为向量，第四维为 0。而且第四维为 0，也让平移变换作用在向量上不会发生任何变换。

> 在射影几何中，齐次坐标第四维为 0，其实描述的是无穷远点。无穷远点是平行直线的交点

通过齐次坐标，顶点的仿射变换、坐标系变换、投影都可以通过矩阵乘法完成。图元顶点变换有严格的数学背景，我查阅了相关教科书，做了以下总结，感兴趣的可以以此为线索，继续学习：

- [线性空间与线性变换](https://zhuanlan.zhihu.com/p/350733327)
- [向量的内积与内积空间](https://zhuanlan.zhihu.com/p/350620954)
- [点变换和坐标变换](https://zhuanlan.zhihu.com/p/361918709)
- [射影几何（一）](https://zhuanlan.zhihu.com/p/368324848)
- [射影几何（二）](https://zhuanlan.zhihu.com/p/368346084)

解析几何的第一步是建立坐标系，在三维空间中，我们通常建立**三维直角仿射坐标系**，简称**直角坐标系**。直角坐标系分左手系和右手系：将右手的拇指和食指分别指着 ![[公式]](https://www.zhihu.com/equation?tex=x) 轴和 ![[公式]](https://www.zhihu.com/equation?tex=y) 轴的方向，如果中值所指的方向与 ![[公式]](https://www.zhihu.com/equation?tex=z) 轴方向在 ![[公式]](https://www.zhihu.com/equation?tex=xOy) 平面同侧，则称此坐标系为**右手系**，否则称为**左手系**。

![img](https://pic4.zhimg.com/80/v2-c2d95855976e173c84761dabf0caad17_1440w.jpg)

通过直角坐标系，我们可以刻画三维空间中任意一个点或向量。而三维空间的齐次坐标是一个有序四元实数组，那么在齐次坐标中的第四维坐标的基向量方向垂直于 ![[公式]](https://www.zhihu.com/equation?tex=x%2Cy%2Cz) 轴。三维空间的齐次坐标没有直观的几何图像，不过我们呢可以借助二维空间的齐次坐标理解三维空间的齐次坐标。

![img](https://pic1.zhimg.com/80/v2-913d96de928f3feafb19f1583369fea8_1440w.jpg)二维的齐次坐标



平面 ![[公式]](https://www.zhihu.com/equation?tex=%5Coverline%7B%5Cpi_0%7D) 上任意一点 ![[公式]](https://www.zhihu.com/equation?tex=M) 在标准正交基 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D) 下的坐标为 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%29) 。我们在平面外一点 ![[公式]](https://www.zhihu.com/equation?tex=O) 建立一个三维直角坐标系 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%2C%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) ，其中 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D) 与平面 ![[公式]](https://www.zhihu.com/equation?tex=%5Coverline%7B%5Cpi_0%7D) 的 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D) 平行， ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_3%7D) 垂直于 ![[公式]](https://www.zhihu.com/equation?tex=%5Coverline%7B%5Cpi_0%7D) ， ![[公式]](https://www.zhihu.com/equation?tex=%7CO_1O%7C+%3D+1) ，那么在 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%2C%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) 下， ![[公式]](https://www.zhihu.com/equation?tex=M) 的坐标为 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%2C1%29) 。这就是二维空间的齐次坐标，三维空间的齐次坐标同理。

在图形学中，为了方便计算，我们建立三个直角坐标系：**世界坐标**，**局部坐标**和**观察坐标**。世界坐标可以看成是绝对坐标、局部坐标是模型在建立时参考的坐标系、观察坐标是以摄像机中心为原点，观察方向、“快门”方向为坐标轴的坐标系。输入的顶点坐标往往是局部坐标，为了方便投影，我们需要把坐标变换到观察坐标，而在这中间其桥梁作用的就是世界坐标。

### 2.1.1 向量的坐标变换

向量 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7BV%7D) 在仿射坐标系 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%3B%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) 下的坐标是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7BV%7D%28x%2Cy%2Cz%29) ，我们想要得到点 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7BV%7D) 在仿射坐标系 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%5E%7B%5Cprime%7D%3B%5Cvec%7Be_1%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_2%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_3%5E%7B%5Cprime%7D%7D%5D) 下的坐标 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7BV%7D%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%29)

我们需要知道向量 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_1%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_2%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_3%5E%7B%5Cprime%7D%7D) 在 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%3B%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) 的坐标，设：

![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_1%5E%7B%5Cprime%7D%7D%3D%28a_%7B11%7D%2Ca_%7B21%7D%2Ca_%7B31%7D%29+%5C%5C+%5Cvec%7Be_2%5E%7B%5Cprime%7D%7D%3D%28a_%7B12%7D%2Ca_%7B22%7D%2Ca_%7B32%7D%29%5C%5C+%5Cvec%7Be_3%5E%7B%5Cprime%7D%7D%3D%28a_%7B13%7D%2Ca_%7B23%7D%2Ca_%7B33%7D%29)

那么：

![[公式]](https://www.zhihu.com/equation?tex=%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%29+%3D+%28x%2Cy%2Cz%29%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+a_%7B11%7D+%26+a_%7B12%7D+%26++a_%7B1+3%7D+%5C%5C+a_%7B21%7D+%26+a_%7B22%7D+%26++a_%7B2+3%7D+%5C%5C+++a_%7B3+1%7D+%26+a_%7B3+2%7D+%26++a_%7B3+3%7D+%5Cend%7Barray%7D%5Cright%29)

如果用齐次坐标表示：

![[公式]](https://www.zhihu.com/equation?tex=%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%2C0%29+%3D+%28x%2Cy%2Cz%2C0%29%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+a_%7B11%7D+%26+a_%7B12%7D+%26++a_%7B1+3%7D+%26+0%5C%5C+a_%7B21%7D+%26+a_%7B22%7D+%26++a_%7B2+3%7D+%26+0%5C%5C+++a_%7B3+1%7D+%26+a_%7B3+2%7D+%26++a_%7B3+3%7D+%26+0%5C%5C+0%26+0%26+0%26+1%5Cend%7Barray%7D%5Cright%29)

同时：

![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%2Cz%29%3D+%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%29+%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+a_%7B11%7D+%26+a_%7B12%7D+%26++a_%7B1+3%7D+%5C%5C+a_%7B21%7D+%26+a_%7B22%7D+%26++a_%7B2+3%7D+%5C%5C+++a_%7B3+1%7D+%26+a_%7B3+2%7D+%26++a_%7B3+3%7D+%5Cend%7Barray%7D%5Cright%29%5E%7B-1%7D)

特别的，当 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%3B%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) 和 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%5E%7B%5Cprime%7D%3B%5Cvec%7Be_1%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_2%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_3%5E%7B%5Cprime%7D%7D%5D) 都是直角坐标系时，**过渡矩阵是正交矩阵**。



### 2.1.2 点的坐标系变换

因为向量可以任意平移，所以向量的坐标变换可以看成是旋转加缩放的结合。如果是点的变换就有所不同了，因为点不能任意平移，所以除了需要知道向量 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Be_1%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_2%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_3%5E%7B%5Cprime%7D%7D) 在 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%3B%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) 的坐标，还需要知道原点 ![[公式]](https://www.zhihu.com/equation?tex=O%5E%7B%5Cprime%7D) 在 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%3B%5Cvec%7Be_1%7D%2C%5Cvec%7Be_2%7D%2C%5Cvec%7Be_3%7D%5D) 的坐标。设

![[公式]](https://www.zhihu.com/equation?tex=O%5E%7B%5Cprime%7D%3D%28x_0%2Cy_0%2Cz_0%29)

那么点 ![[公式]](https://www.zhihu.com/equation?tex=P%28x%2Cy%2Cz%29) 在 ![[公式]](https://www.zhihu.com/equation?tex=%5BO%5E%7B%5Cprime%7D%3B%5Cvec%7Be_1%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_2%5E%7B%5Cprime%7D%7D%2C%5Cvec%7Be_3%5E%7B%5Cprime%7D%7D%5D) 下的坐标为：

![[公式]](https://www.zhihu.com/equation?tex=%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%29+%3D+%28x%2Cy%2Cz%29%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+a_%7B11%7D+%26+a_%7B12%7D+%26++a_%7B1+3%7D+%5C%5C+a_%7B21%7D+%26+a_%7B22%7D+%26++a_%7B2+3%7D+%5C%5C+++a_%7B3+1%7D+%26+a_%7B3+2%7D+%26++a_%7B3+3%7D+%5Cend%7Barray%7D%5Cright%29+%2B+%28x_0%2Cy_0%2Cz_0%29)

如果用齐次坐标表示：

![[公式]](https://www.zhihu.com/equation?tex=%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%2C1%29+%3D+%28x%2Cy%2Cz%2C1%29%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+a_%7B11%7D+%26+a_%7B12%7D+%26++a_%7B1+3%7D+%26+0%5C%5C+a_%7B21%7D+%26+a_%7B22%7D+%26++a_%7B2+3%7D+%26+0%5C%5C+++a_%7B3+1%7D+%26+a_%7B3+2%7D+%26++a_%7B3+3%7D+%26+0%5C%5C+x_0+%26+x_1%26+x_2%26+1%5Cend%7Barray%7D%5Cright%29)

同时：

![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%2Cz%29%3D+%28x%5E%7B%5Cprime%7D%2Cy%5E%7B%5Cprime%7D%2Cz%5E%7B%5Cprime%7D%29+%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+a_%7B11%7D+%26+a_%7B12%7D+%26++a_%7B1+3%7D+%5C%5C+a_%7B21%7D+%26+a_%7B22%7D+%26++a_%7B2+3%7D+%5C%5C+++a_%7B3+1%7D+%26+a_%7B3+2%7D+%26++a_%7B3+3%7D+%5Cend%7Barray%7D%5Cright%29%5E%7B-1%7D%2B+%28-x_0%2C-y_0%2C-z_0%29)



通常我们会知道，摄像机在世界坐标下的位置以及观察、“快门”在世界坐标下的方向向量，因此从世界坐标变换到观察坐标可以直接利用上面的变换公式。从世界坐标变换到观察坐标称为**视图变换**，所用到的矩阵记为 ![[公式]](https://www.zhihu.com/equation?tex=V) 。

下面介绍从模型坐标变换到世界坐标的变换矩阵。

### 2.1.3 顶点的模型变换

有了上面的数学基础，顶点的模型变换不难理解。所谓的模型变换，就是模型的旋转、缩放和平移变换。这三类变换可以通过一个仿射变换统一描述，仿射变换是投影中心为无穷远点的射影变换，因此我们可以用齐次坐标描述仿射变换。

> 下图是维基百科上用齐次坐标描述仿射变换的几何意义：

![img](https://pic3.zhimg.com/v2-6ec464501d6846f9e20d56a7d5b3b0b6_b.jpg)

旋转、缩放、平移的变换矩阵：

**旋转变换**：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%26R_%7Bx%7D%28%5Ctheta%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+1+%26+0+%26+0+%26+0+%5C%5C+0+%26+%5Ccos+%5Ctheta+%26+-%5Csin+%5Ctheta+%26+0+%5C%5C+0+%26+%5Csin+%5Ctheta+%26+%5Ccos+%5Ctheta+%26+0+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29%5C%5C+%26R_%7By%7D%28%5Ctheta%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D+%5Ccos+%5Ctheta+%26+0+%26+%5Csin+%5Ctheta+%26+0+%5C%5C+0+%26+1+%26+0+%26+0+%5C%5C+-%5Csin+%5Ctheta+%26+0+%26+%5Ccos+%5Ctheta+%26+0+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29%5C%5C+%26R_%7Bz%7D%28%5Ctheta%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D+%5Ccos+%5Ctheta+%26+-%5Csin+%5Ctheta+%26+0+%26+0+%5C%5C+%5Csin+%5Ctheta+%26+%5Ccos+%5Ctheta+%26+0+%26+0+%5C%5C+0+%26+0+%26+1+%26+0+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29+%5Cend%7Baligned%7D)

**旋转变换的逆变换**：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%26R_%7Bx%7D%5E%7B-1%7D%28%5Ctheta%29%3DR_%7Bx%7D%5E%7BT%7D%28%5Ctheta%29%3DR_%7Bx%7D%28-%5Ctheta%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+1+%26+0+%26+0+%26+0+%5C%5C+0+%26+%5Ccos+%5Ctheta+%26+%5Csin+%5Ctheta+%26+0+%5C%5C+0+%26+-%5Csin+%5Ctheta+%26+%5Ccos+%5Ctheta+%26+0+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29%5C%5C+%26R_%7By%7D%5E%7B-1%7D%28%5Ctheta%29%3DR_%7By%7D%5E%7BT%7D%28%5Ctheta%29%3DR_%7By%7D%28-%5Ctheta%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D+%5Ccos+%5Ctheta+%26+0+%26+-%5Csin+%5Ctheta+%26+0+%5C%5C+0+%26+1+%26+0+%26+0+%5C%5C+%5Csin+%5Ctheta+%26+0+%26+%5Ccos+%5Ctheta+%26+0+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29%5C%5C+%26R_%7Bz%7D%5E%7B-1%7D%28%5Ctheta%29%3DR_%7Bz%7D%5E%7BT%7D%28%5Ctheta%29%3DR_%7Bz%7D%28-%5Ctheta%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+%5Ccos+%5Ctheta+%26+%5Csin+%5Ctheta+%26+0+%26+0+%5C%5C+-%5Csin+%5Ctheta+%26+%5Ccos+%5Ctheta+%26+0+%26+0+%5C%5C+0+%26+0+%26+1+%26+0+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29+%5Cend%7Baligned%7D)

**缩放变换**：

![[公式]](https://www.zhihu.com/equation?tex=S%28s%29+%3D+S%28s_%7Bx%7D%2Cs_%7By%7D%2Cs_%7Bz%7D%29+%3D+%5Cbegin%7Bpmatrix%7D++s_%7Bx%7D+%26+0+%26+0+%260+%5C%5C+++0%26+s_%7By%7D+%26++0%26+0%5C%5C++0+%26++0%26+s_%7Bz%7D+%26+0%5C%5C++0+%26+0+%26+0+%26+1+%5Cend%7Bpmatrix%7D)

**缩放变换的逆变换**：

![[公式]](https://www.zhihu.com/equation?tex=S%5E%7B-1%7D%28s%29+%3D+S%28%5Cfrac%7B1%7D%7Bs_%7Bx%7D%7D%2C%5Cfrac%7B1%7D%7Bs_%7By%7D%7D%2C%5Cfrac%7B1%7D%7Bs_%7Bz%7D%7D%29+%3D+%5Cbegin%7Bpmatrix%7D++%5Cfrac%7B1%7D%7Bs_%7Bx%7D%7D+%26+0+%26+0+%260+%5C%5C+++0%26+%5Cfrac%7B1%7D%7Bs_%7By%7D%7D+%26++0%26+0%5C%5C++0+%26++0%26+%5Cfrac%7B1%7D%7Bs_%7Bz%7D%7D+%26+0%5C%5C++0+%26+0+%26+0+%26+1+%5Cend%7Bpmatrix%7D)

**平移变换**：

![[公式]](https://www.zhihu.com/equation?tex=T%28t%29%3DT%5Cleft%28t_%7Bx%7D%2C+t_%7By%7D%2C+t_%7Bz%7D%5Cright%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+1+%26+0+%26+0+%26+t_%7Bx%7D+%5C%5C+0+%26+1+%26+0+%26+t_%7By%7D+%5C%5C+0+%26+0+%26+1+%26+t_%7Bz%7D+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29)

**平移变换的逆变换**：

![[公式]](https://www.zhihu.com/equation?tex=T%5E%7B-1%7D%28t%29%3DT%5Cleft%28-t_%7Bx%7D%2C-t_%7By%7D%2C-t_%7Bz%7D%5Cright%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+1+%26+0+%26+0+%26+-t_%7Bx%7D+%5C%5C+0+%26+1+%26+0+%26+-t_%7By%7D+%5C%5C+0+%26+0+%26+1+%26+-t_%7Bz%7D+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29)

> 模型变换就是上面一系列仿射变换的组合，表示在数学层面就是矩阵的乘法。

模型变换可以理解为旋转、缩放、平移的组合，可以理解为把顶点坐标从模型坐标变换到世界坐标。因为顶点的坐标是相对概念，在将模型放到世界中，默认将其模型坐标系的坐标轴与世界坐标轴对齐，单位长度与世界坐标保持一致，模型坐标系原点与世界坐标系原点重合。通常，经过模型变换后，顶点的坐标相对世界坐标发生了变化，但顶点的模型坐标不发生变换，这就看起来像把模型连通其模型坐标系一起进行了旋转、缩放、平移变化。

因此**模型变换即可以看成是模型的旋转、缩放、平移变换，也可以看成是从模型坐标到世界坐标的坐标系变换**。模型变换矩阵记为 ![[公式]](https://www.zhihu.com/equation?tex=M) 。

> 这里的仿射变换矩阵与坐标变换矩阵有点不一样，因为这里仿射变换的向量是列向量，上面坐标变换的行向量，其实它们两者本质是一样的。

### 2.1.3.1 法线的模型变换

在顶点结构中，颜色属性，uv 坐标在模型变换前后是不变的，而法线方向是受模型变换影响的。也即对图形施加一个非等比缩放，模型的法线可能与模型表面不垂直

![img](https://pic2.zhimg.com/80/v2-d3448b498a476cbb2fac8ba035f5f4cd_1440w.jpg)



> 如果模型变换中只包含平移，旋转或等比缩放，那么法线依然与表面垂直。因为旋转变换是正交变换，不改变共面向量间的夹角；法线是向量，可以任意平移；等比缩放之后，法线归一化后依然是原向量。因此唯一需要考虑的，就是模型变换中包含了非等比缩放。

为了正确的对法线进行模型变换，我们需要引入**切线（tangent）**，所谓顶点的切线就是在顶点处于平面相切与法线垂直的向量。切线不受模型变换影响，也即乘以包含了非等比缩放的模型变换矩阵，依然能保证与平面相切与法线垂直。利用这一性质，我们推导法线的模型变换矩阵。设法线方向为 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Bn%7D) ，切线方向为 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Bt%7D) ，模型变换矩阵为 ![[公式]](https://www.zhihu.com/equation?tex=M) ，法线的模型变换矩阵为 ![[公式]](https://www.zhihu.com/equation?tex=G)，那么有：

![[公式]](https://www.zhihu.com/equation?tex=%28G%5Cvec%7Bn%7D%29%5Ccdot+%28M%5Cvec%7Bt%7D%29+%3D+0)

因为内积空间中，任意两个向量 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Ba%7D%2C%5Cvec%7Bb%7D) ，其在标准正交基下的坐标分别为： ![[公式]](https://www.zhihu.com/equation?tex=%28a_x%2Ca_y%2Ca_z%29%2C%5C+%28b_x%2Cb_y%2Cb_z%29) 。那么：

![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7Ba%7D%5Ccdot%5Cvec%7Bb%7D+%3D+%28a_x%2Ca_y%2Ca_z%29%5Ccdot%5C+%28b_x%2Cb_y%2Cb_z%29+%3D+a_xb_x%2Ba_yb_y%2Ba_zb_z+%3D+%28%5Cvec%7Ba%7D%29%28%5Cvec%7Bb%7D%29%5ET+)

因此有：

![[公式]](https://www.zhihu.com/equation?tex=%28G%5Cvec%7Bn%7D%29%5Ccdot+%28M%5Cvec%7Bt%7D%29+%3D+%28G%5Cvec%7Bn%7D%29%5ET%28M%5Cvec%7Bt%7D%29+%3D+%28%5Cvec%7Bn%7D%29%5ETG%5ETM%28%5Cvec%7Bt%7D%29)

因为 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Cvec%7Bn%7D%29%5ET%28%5Cvec%7Bt%7D%29+%3D+0) ，那么只要 ![[公式]](https://www.zhihu.com/equation?tex=G%5ETM+%3D+I) ，就能满足 ![[公式]](https://www.zhihu.com/equation?tex=%28G%5Cvec%7Bn%7D%29%5Ccdot+%28M%5Cvec%7Bt%7D%29+%3D+0)

所以得到 ![[公式]](https://www.zhihu.com/equation?tex=G+%3D+%28M%5E%7B-1%7D%29%5ET)

> 在进行法线变换时，我们只用得到模型变换矩阵的前 3x3 的子矩阵。



### 2.2 顶点的投影

在[光线追踪](https://zhuanlan.zhihu.com/p/370440796)的文档中，介绍了平行投影和透视投影的概念，而且用光线投射的方法，实现了这一投影过程。在射影几何的文档里介绍了，投影其实是一种射影变换，在[射影几何（二）](https://zhuanlan.zhihu.com/p/368346084)中介绍了，用在齐次坐标下，射影变换可以用一个矩阵表示，记为 ![[公式]](https://www.zhihu.com/equation?tex=P) 矩阵。

在进行投影之前，我们需要把顶点坐标从模型坐标变换到观察坐标，也即要乘以 ![[公式]](https://www.zhihu.com/equation?tex=M) 矩阵和 ![[公式]](https://www.zhihu.com/equation?tex=V) 矩阵。顶点投影之后，会从观察坐标变换到**齐次裁剪坐标**。齐次裁剪空间是个通常是个**左手系**，摄像机空间是个右手系，所以在变换的过程中，需要对 ![[公式]](https://www.zhihu.com/equation?tex=z) 取反。

为什么齐次裁剪空间是一个左手系？这是因为通过投影变换后的 ![[公式]](https://www.zhihu.com/equation?tex=z) 值会在深度测试阶段用到，用以测试物体间（准确的说是片元间）的遮挡关系。而深度测试的比较条件是越小离摄像机越近，所以齐次裁剪坐标是一个左手系。



### 2.2.1 正交投影相机与透视投影相机

不同的投影方式需要不同的摄像机，定义一个相机需要六个面，但我们并不需要把这六个面的方程写出来。

对于正交投影相机，需要定义：近裁剪面（near）、远裁剪面（far）、投影尺寸（size）、宽高比缩放（aspect ratio）

对于透视投影相机，需要定义：近裁剪面（near）、远裁剪面（far）、视场角（field of view）、宽高比缩放（aspect ratio）

定义一个相机的伪代码如下：

```cpp
class Camera {
    float3 worldPos; // 世界坐标系下摄像机的位置
    float3 lookDir;   // 摄像机的观察方向
    float3 up;

    float near;
    float far;
    float aspectRatio;

    virtual float4x4 GetProjMat();
};

class OrthCamera : Camera{
    float2 size;
    virtual float4x4 GetProjMat();
};

class PersCamera : Camera {
    float2 fov;
    virtual float4x4 GetProjMat();
};
```

其中，

- `worldPos` 是摄像机的世界坐标 ![[公式]](https://www.zhihu.com/equation?tex=%28p_x%2Cp_y%2Cp_z%29) ，
- `lookDir` 是摄像机在世界坐标下的观察方向 ![[公式]](https://www.zhihu.com/equation?tex=%28d_x%2Cd_y%2Cd_z%29) ，而在观察坐标下， ![[公式]](https://www.zhihu.com/equation?tex=%280%2C0%2C-1%29)
- `up` 是摄像机在世界坐标下的快门方向 ![[公式]](https://www.zhihu.com/equation?tex=%28u_x%2Cu_y%2Cu_z%29) ，而在观察坐标下， ![[公式]](https://www.zhihu.com/equation?tex=%280%2C1%2C0%29)
- 通过 `right=-lookDir`![[公式]](https://www.zhihu.com/equation?tex=%5Ctimes)`up` 可以得到摄像机在世界坐标下的右手方向 ![[公式]](https://www.zhihu.com/equation?tex=%28r_x%2Cr_y%2Cr_z%29) ， 得到一个观察坐标的三个坐标轴在世界坐标下的向量，进而得到从得到矩阵 ![[公式]](https://www.zhihu.com/equation?tex=V)

![[公式]](https://www.zhihu.com/equation?tex=V%3D%5Cbegin%7Bpmatrix%7D++r_x+%26+u_x+%26+d_x++%26+0+%5C%5C++r_y+%26+u_y+%26+d_y+%26+0+%5C%5C++r_z+%26+u_z+%26+d_z+%26+0+%5C%5C++-p_x+%26+-p_y+%26+-p_z+%26+1+%5Cend%7Bpmatrix%7D)

- `near` 摄像机的近裁剪屏幕，是个负数
- `far` 摄像机的远裁剪屏幕，也是个负数，且 `near > far`
- `aspectRatio` 可以简单理解最终输出图像的长宽比，因此也决定了投影屏幕的长宽比
- `size` 正交投影相机特有属性，控制投影区域的大小
- `fov` 透视投影相机特有属性，通常指垂直的 `fov` ，也即视锥体上下两个屏幕的夹角，当然也可以定义成水平的 `fov`

整个摄像机类的关键在于，通过以上属性，推导投影矩阵。

### 2.2.2 透视投影矩阵

我们可以通过相似三角形的性质推导投影投影矩阵。下图是一个透视相机的俯视图，所谓透视投影就是找到视锥体任意一点 ![[公式]](https://www.zhihu.com/equation?tex=A) 通过投影线 ![[公式]](https://www.zhihu.com/equation?tex=OA) ，找到与近裁剪平面上的交点 ![[公式]](https://www.zhihu.com/equation?tex=P_1) 。

![img](https://pic1.zhimg.com/80/v2-8877a1e27a3f59a79c6f8780fad0f5e8_1440w.jpg)

近裁剪平面可以用 ![[公式]](https://www.zhihu.com/equation?tex=z%3Dn) 表示，那么 ![[公式]](https://www.zhihu.com/equation?tex=ON+%3D+%7Cn%7C) ；远裁剪平面可以用 ![[公式]](https://www.zhihu.com/equation?tex=z%3Df) 表示，那么 ![[公式]](https://www.zhihu.com/equation?tex=OF%3D%7Cf%7C) 。近裁剪平面是一个矩形，其取值范围是 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cin+%5Bl%2Cr%5D%2C%5C+y%5Cin+%5Bb%2Ct%5D) ，通常 ![[公式]](https://www.zhihu.com/equation?tex=N+) 点是近裁剪面的几何中心，通过 Field of View 和 Aspect Ratio，我们可以得到对称的取值范围：

![[公式]](https://www.zhihu.com/equation?tex=l%3D-r%3D+-%5Cfrac%7B%7Cf%7C%7D%7B2%7D%5Ccos+%5Cfrac%7B%5Ctheta_%7Bfov%7D%7D%7B2%7D%5Ccdot+%5Cmathrm%7BAspectRatio%7D%5C%5C+b%3D-t%3D-%5Cfrac%7B%7Cf%7C%7D%7B2%7D%5Ccos+%5Cfrac%7B%5Ctheta_%7Bfov%7D%7D%7B2%7D)

已知 ![[公式]](https://www.zhihu.com/equation?tex=A) 点坐标 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%2Cz%29) ,通过相似三角形原理不难得到 ![[公式]](https://www.zhihu.com/equation?tex=P_1%28x_1%2Cy_1%2Cz_1%29) 点坐标：

![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7BON%7D%7BOA%5E%7B%5Cprime%7D%7D+%3D+%5Cfrac%7Bn%7D%7Bz%7D+%3D+%5Cfrac%7Bx_1%7D%7Bx%7D+%3D+%5Cfrac%7By_1%7D%7By%7D)

所以 ![[公式]](https://www.zhihu.com/equation?tex=P_1%28%5Cfrac%7Bnx%7D%7Bz%7D%2C%5Cfrac%7Bny%7D%7Bz%7D%2Cn%29) ， ![[公式]](https://www.zhihu.com/equation?tex=P_1) 的 ![[公式]](https://www.zhihu.com/equation?tex=z%5Cequiv+n) ，似乎不是那么的有必要，因此，我们希望 ![[公式]](https://www.zhihu.com/equation?tex=P_1) 点上任保留 ![[公式]](https://www.zhihu.com/equation?tex=A) 点的 ![[公式]](https://www.zhihu.com/equation?tex=z) 轴信息，也即深度信息，以便将来进行深度测试，所以 ![[公式]](https://www.zhihu.com/equation?tex=P_1%28%5Cfrac%7Bnx%7D%7Bz%7D%2C%5Cfrac%7Bny%7D%7Bz%7D%2C-%5Cfrac%7B1%7D%7Bz%7D%29) 。

> 这里为什么是 ![[公式]](https://www.zhihu.com/equation?tex=-1%2Fz) ，因为齐次裁剪坐标是一个左手系，所以 z 要取反，第二为了方便之后的透视纠正插值，这里要存成 ![[公式]](https://www.zhihu.com/equation?tex=1%2Fz)



我们看到图中存在一点 ![[公式]](https://www.zhihu.com/equation?tex=B) ，它并非在视锥体之中，因此在投影之后，它的坐标不在近裁剪面的取值范围之中，应该舍弃。但如果上图中 ![[公式]](https://www.zhihu.com/equation?tex=AB) 是一条直线的两个端点， ![[公式]](https://www.zhihu.com/equation?tex=A) 在可视范围内， ![[公式]](https://www.zhihu.com/equation?tex=B) 不在，因此直线 ![[公式]](https://www.zhihu.com/equation?tex=AB) 有一段是不可见的，这应该怎么做？正确的做法是找到 ![[公式]](https://www.zhihu.com/equation?tex=B) 点与视锥体的交点 ![[公式]](https://www.zhihu.com/equation?tex=B%5E%7B%5Cprime%5Cprime%7D) 作为直线的新端点，然后投影到近裁剪面上。但是棱锥与直线的交点并不好找，如果是三角形有在视锥体中的，也有在视锥体外的，这就更麻烦了。这就是下一节，**裁剪（Clipping）算法**需要考虑的问题。为了更方便的做裁剪，我们需要把投影之后的坐标做一个简单的缩放变化。

我们把近裁剪面的取值范围 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cin+%5Bl%2Cr%5D%2C%5C+y%5Cin+%5Bb%2Ct%5D) 缩放放到 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E2) 的区间那么近裁剪面上的点 ![[公式]](https://www.zhihu.com/equation?tex=P%28x_1%2Cy_1%29) 都需要经过如下变换：

![[公式]](https://www.zhihu.com/equation?tex=x_1%5E%7B%5Cprime%7D+%3D+%5Cfrac%7B1%7D%7Br-l%7D%28x_1-l%29+%3D+%5Cfrac%7Bnx%7D%7B%28r-l%29z%7D-%5Cfrac%7Bl%7D%7Br-l%7D%5C%5C+y_1%5E%7B%5Cprime%7D+%3D+%5Cfrac%7B1%7D%7Bt-b%7D%28y_1-b%29+%3D%5Cfrac%7Bny%7D%7B%28t-b%29z%7D-%5Cfrac%7Bb%7D%7Bt-b%7D)

而视锥体 ![[公式]](https://www.zhihu.com/equation?tex=-1%2Fz+%5Cin+%5B-1%2Ff%2C-1%2Fn%5D) 也要缩放到 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D) 区间，为了和正交投影保持一致，我们让当 ![[公式]](https://www.zhihu.com/equation?tex=z%3Dn) 时映射到 0，当 ![[公式]](https://www.zhihu.com/equation?tex=z%3Df) 时映射到到 1。那么



那么近裁剪面的点的 ![[公式]](https://www.zhihu.com/equation?tex=z_1) 需要经过如下变换：

![[公式]](https://www.zhihu.com/equation?tex=z_1%5E%7B%5Cprime%7D+%3D+%5Cfrac%7B1%7D%7B1%2Fn-1%2Ff%7D%28z_1%2B%5Cfrac%7B1%7D%7Bn%7D%29%3D%5Cfrac%7Bnf%7D%7B%28n-f%29z%7D%2B%5Cfrac%7Bf%7D%7Bf-n%7D)

因此通过投影变换之后，视锥体中的点，都变换到了一个 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E3) 的立方体中，不在视锥体中的点自然不在视锥体中。而用立方体去找与直线的交点，三角形的交线，自然比用棱锥简单得多。这也是齐次裁剪坐标的裁剪二字的由来。

![img](https://pic1.zhimg.com/80/v2-8b7ca02828be38507e2f18fdbc0e9410_1440w.jpg)

> 在 OpenGL 中，齐次裁剪坐标的取值范围是 ![[公式]](https://www.zhihu.com/equation?tex=%5B-1%2C1%5D%5E3) ，在 DirectX 中，齐次裁剪坐标的取值范围是 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E3) ，但它们的本质是一样的。

我们知道 ![[公式]](https://www.zhihu.com/equation?tex=A) 的坐标是一个齐次坐标，是一个四维坐标，经过投影变换之后应该还是一个齐次坐标，这也是齐次裁剪坐标，齐次的由来。综合以上两步，我们可以得到**投影变换矩阵**：

![[公式]](https://www.zhihu.com/equation?tex=P_1%5E%7B%5Cprime%7D%3D%5Cmathbf%7BP%7DA%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+%5Cfrac%7Bn%7D%7Br-l%7D+%26+0+%26+-%5Cfrac%7Bl%7D%7Br-l%7D+%26+0+%5C%5C+0+%26+%5Cfrac%7Bn%7D%7Bt-b%7D+%26+-%5Cfrac%7Bb%7D%7Bt-b%7D+%26+0+%5C%5C+0+%26+0+%26+%5Cfrac%7Bf%7D%7Bf-n%7D+%26+%5Cfrac%7Bn+f%7D%7Bn-f%7D+%5C%5C+0+%26+0+%26+1+%26+0+%5Cend%7Barray%7D%5Cright%29%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D+x+%5C%5C+y+%5C%5C+z+%5C%5C+1+%5Cend%7Barray%7D%5Cright%29%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D+%5Cfrac%7B+n%7D%7Br-l%7Dx-%5Cfrac%7Bl%7D%7Br-l%7Dz+%5C%5C+%5Cfrac%7Bn%7D%7Bt-b%7Dy-%5Cfrac%7Bb%7D%7Bt-b%7Dz+%5C%5C+%5Cfrac%7Bf%7D%7Bf-n%7Dz%2B%5Cfrac%7Bnf%7D%7Bn-f%7D+%5C%5C+z+%5Cend%7Barray%7D%5Cright%29)

乘以投影矩阵得到的坐标第四维不是 ![[公式]](https://www.zhihu.com/equation?tex=1) ，因此对 ![[公式]](https://www.zhihu.com/equation?tex=P_1%5E%7B%5Cprime%7D) 除以 ![[公式]](https://www.zhihu.com/equation?tex=w) ，使得第四维归一，就得到了真正的 ![[公式]](https://www.zhihu.com/equation?tex=P_1) ，这一步称为**齐次除法**：

![[公式]](https://www.zhihu.com/equation?tex=P_1+%3D+%5Cfrac%7B1%7D%7Bw%7DP_1%5E%7B%5Cprime%7D+%3D+%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D+%5Cfrac%7Bnx%7D%7B%28r-l%29z%7D-%5Cfrac%7Bl%7D%7Br-l%7D+%5C%5C+%5Cfrac%7Bny%7D%7B%28t-b%29z%7D-%5Cfrac%7Bb%7D%7Bt-b%7D+%5C%5C+%5Cfrac%7Bn+f%7D%7B%28n-f%29z%7D%2B%5Cfrac%7Bf%7D%7Bf-n%7D+%5C%5C+1+%5Cend%7Barray%7D%5Cright%29)

因此完整的透视投影，包含两步，1. 乘以投影矩阵；2. 齐次除法



### 2.2.3 正交投影矩阵

理解了透视投影矩阵的推导，正交投影矩阵不难得到，因为正交投影是一种特殊的平行投影，其投影线与近裁剪平面垂直，所以投影之后，投影点的 ![[公式]](https://www.zhihu.com/equation?tex=x) 坐标与 ![[公式]](https://www.zhihu.com/equation?tex=y) 坐标保持不变。同样为了方便裁剪，也需要把投影之后，可视区域的坐标映射到 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E3) 范围之内。

![img](https://pic1.zhimg.com/80/v2-a947d5f0fc61cb397c1d5a6c239afc90_1440w.jpg)

可视范围内一点 ![[公式]](https://www.zhihu.com/equation?tex=A%28x%2Cy%2Cz%29) 投影到近裁剪面上一点 ![[公式]](https://www.zhihu.com/equation?tex=P_1) ，因为正交投影不需要透视纠正，投影之后 ![[公式]](https://www.zhihu.com/equation?tex=P_1%28x%2Cy%2C-z%29) 。

同样，近裁剪面用 ![[公式]](https://www.zhihu.com/equation?tex=x%3Dn+) 表示，远裁剪面用 ![[公式]](https://www.zhihu.com/equation?tex=y%3Df) 表示，因为深度要取反，那么 ![[公式]](https://www.zhihu.com/equation?tex=-z%5Cin+%5B-n%2C-f%5D) 。近裁剪面的取值范围是 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cin+%5Bl%2Cr%5D%2C%5C+y%5Cin+%5Bb%2Ct%5D) ，那么缩放到 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E3) 范围后：

![[公式]](https://www.zhihu.com/equation?tex=P_1+%3D+%5Cbegin%7Bpmatrix%7D+%5Cfrac%7Bx%7D%7Br-l%7D-%5Cfrac%7Bl%7D%7Br-l%7D+%5C%5C+%5Cfrac%7By%7D%7Bt-b%7D-%5Cfrac%7Bb%7D%7Bt-b%7D+%5C%5C+%5Cfrac%7Bz%7D%7Bf-n%7D-%5Cfrac%7Bn%7D%7Bf-n%7D%5C%5C+1+%5Cend%7Bpmatrix%7D)



![img](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='735' height='305'></svg>)

正交投影的投影矩阵为：

![[公式]](https://www.zhihu.com/equation?tex=P_1%3D%5Cmathbf%7BP%7DA%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D+%5Cfrac%7B1+%7D%7Br-l%7D+%26+0+%26+0+%26+-%5Cfrac%7Bl%7D%7Br-l%7D++%5C%5C+0+%26+%5Cfrac%7B1+%7D%7Bt-b%7D+%26+0%26+-%5Cfrac%7Bb%7D%7Bt-b%7D++%5C%5C+0+%26+0+%26+%5Cfrac%7B1%7D%7Bf-n%7D+%26+-%5Cfrac%7Bn%7D%7Bf-n%7D+%5C%5C+0+%26+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%29%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D+x+%5C%5C+y+%5C%5C+z+%5C%5C+1+%5Cend%7Barray%7D%5Cright%29%3D+%5Cbegin%7Bpmatrix%7D+%5Cfrac%7Bx%7D%7Br-l%7D-%5Cfrac%7Bl%7D%7Br-l%7D+%5C%5C+%5Cfrac%7By%7D%7Bt-b%7D-%5Cfrac%7Bb%7D%7Bt-b%7D+%5C%5C+%5Cfrac%7Bz%7D%7Bf-n%7D-%5Cfrac%7Bn%7D%7Bf-n%7D%5C%5C+1+%5Cend%7Bpmatrix%7D)

正交投影不需要齐次除法，也可以认为齐次除法除以 1。

至此顶点变换的所有矩阵已经推导完毕，通常在逐顶点操作中，将这三个矩阵结合起来，称为模型视图投影变换，记为 ![[公式]](https://www.zhihu.com/equation?tex=MVP) 矩阵，把顶点从模型坐标变换到齐次裁剪坐标。

> 在乘以 MVP 矩阵之后，有的点可能会有得到很奇怪的坐标，比如在观察坐标 ![[公式]](https://www.zhihu.com/equation?tex=xOy) 平面的点，或者在观察坐标中 ![[公式]](https://www.zhihu.com/equation?tex=z%3E0) 的点，这些点不可见的，都是需要裁剪的。但它们乘以 MVP 矩阵后，坐标可能会在立方体中，需要特殊处理。



### 2.3 裁剪

通过模型视图投影变换，顶点的坐标变换到了一个 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E3) 的立方体中，也称为**规范立方体（Canonical View Volume，CVV）**，我们下面就要用这个立方体去裁剪图元，避免不必要的片元绘制。

图元与 CVV 的位置关系有三种：1. 完全在立方体内；2. 完全在立方体外；3. 部分在立方体内。第二种情况不需要裁剪，只有第三种情况需要裁剪，而所谓的裁剪，就是用图元与立方体的交点作为图元的新顶点，构建新的图元。

![img](https://pic4.zhimg.com/80/v2-b1f54dcd03c8c19128e1832c452ac233_1440w.jpg)



### 2.3.1 直线的裁剪

最常用的直线的裁剪算法称为 Cohen-Sutherland 裁剪算法。它通过给空间编码，通过位运算，快速判断直线与立方体的位置关系。如果是第三种情况，直线与立方体的交点是非常容易找到的。下面就介绍以下 Cohen-Sutherland 裁剪算法。

CVV 把空间分成 27 个区域。我们给其中 7 个比较特殊的区域一个二进制编码，它们分别是：

1. CVV 内部，编码：`0x000000`
2. CVV 左边，编码：`0x000001`
3. CVV 右边，编码：`0x000010`
4. CVV 下变，编码：`0x000100`
5. CVV 上边，编码：`0x001000`
6. CVV 前边，编码：`0x010000`
7. CVV 后边，编码：`0x100000`

通过这七个编码，相邻区域编制之间按位或，我们可以得到所有 27 个区域的编码。比如左前区域编码：`0x000001 | 0x010000 = 0x010001` ；左前上区域编码：`0x010001 | 0x001000 = 0x011001` ……

**第一步给顶点编码**：通过顶点的坐标与 CVV 的取值范围比较，得到顶点的编码，伪代码如下：

```cpp
int IN_SIDE = 0x000000;
int LEFT_SIDE = 0x000001;
int RIGHT_SIDE = 0x000010;
int TOP_SIDE = 0x001000;
int BOTTOM_SIDE = 0x000100;
int FRONT_SIDE = 0x010000;
int BACK_SIDE = 0x100000;

int EncodePoint(float3 pos){
    int code = IN_SIDE;
    if(pos.x < 0)
        code |= LEFT_SIDE;
    if(pos.x > 1)
        code |= RIGHT_SIDE;
    if(pos.y < 0)
        code |= BOTTOM_SIDE;
    if(pos.y > 1)
        code |= TOP_SIDE;
    if(pos.z < 0)
        code |= BACK_SIDE;
    if(pos.z > 1)
        code |= FRONT_SIDE;
    return code;
}
```

**第二步判断直线与 CVV 的位置关系**：通过编码，可以快速判断直线与 CVV 的位置关系。

1. 完全在立方体内，将直线的两个端点按位或，如果等于 `0x000000` 证明直线都在 CVV 内，直线不用裁剪，全部保留
2. 完全在立方体外， 将直线的两个端点按位与，如果不等于 `0x000000` 证明直线都在 CVV 外，直线不用裁剪，全部舍弃
3. 如果不是上两种情况，那么直线与 CVV 有交点，我们需要找到这个交点。先让直线与 CVV 的六个平面相交，判断交点是否在 CVV 内，这个在 CVV 内的交点只有一个

那么 Cohen-Sutherland 裁剪算法的参考实现如下：

```cpp
bool CohenSutherlandLineClip(out Line l)
{
    float3 p1 = l.vertices[0].position;
    float3 p2 = l.vertices[1].position;
    
    int code1 = EncodePoint(p1);
    int code2 = EncodePoint(p2);
    
    while(true) {
        if(code1 | code2 == 0) { // 在 CVV 内
            return true; 
        }
        else if (code1 & code2 != 0) { // 在 CVV 外
            return false;
        }
        else { // 寻找交点，裁剪直线
            int outCode = code1 ? code1 : code2; // 找到在 CVV 外的那一点
            double x, y, z;
            if(outCode & LEFT_SIDE) { // 在 CVV 左侧，与左平面的交点
                x = -1;
                float t = (x - p1.x)/(p2.x - p1.x);
                y = (1-t) * p1.y + t * p2.y;
                z = (1-t) * p1.z + t * p2.z;
            }
            elseif(outCode & RIGHT_SIDE) { // 在 CVV 右侧，与右平面的交点
                x = 1;
                float t = (x - p1.x)/(p2.x - p1.x);
                y = (1-t) * p1.y + t * p2.y;
                z = (1-t) * p1.z + t * p2.z;
            }
            elseif(outCode & BOTTOM_SIDE) { // 在 CVV 下侧，与下平面的交点
                y = -1;
                float t = (y - p1.y)/(p2.y - p1.y);
                x = (1-t) * p1.x + t * p2.x;
                z = (1-t) * p1.z + t * p2.z;
            }
            elseif(outCode & TOP_SIDE) { // 在 CVV 上侧，与上平面的交点
                y = 1;
                float t = (y - p1.y)/(p2.y - p1.y);
                x = (1-t) * p1.x + t * p2.x;
                z = (1-t) * p1.z + t * p2.z;
            }
            elseif(outCode & BACK_SIDE) { // 在 CVV 后侧，与后平面的交点
                z = -1;
                float t = (z - p1.z)/(p2.z - p1.z);
                x = (1-t) * p1.x + t * p2.x;
                y = (1-t) * p1.y + t * p2.y;
            }
            elseif(outCode & FRONT_SIDE) { // 在 CVV 前侧，与前平面的交点
                z = 1;
                float t = (z - p1.z)/(p2.z - p1.z);
                x = (1-t) * p1.x + t * p2.x;
                y = (1-t) * p1.y + t * p2.y;
            }
            
            // 用新顶点替代外点直线顶点
            if(outCode == code1) {
                p1.x = x;
                p1.y = y;
                p1.z = z;
                l.vertices[0].position = p1;
                code1 = EncodePoint(p1);
            }
            else {
                p2.x = x;
                p2.y = y;
                p2.z = z;
                l.vertices[1].position = p2;
                code2 = EncodePoint(p2);
            }
        }
    }
}
```

> 在裁剪过程中，还有一步，就是用新的顶点替换旧顶点后，新顶点上的属性需要根据旧顶点插值得到。
> 在计算交点的过程，有 `p1.x-p2.x` 等操作，为了避免分母为 0，可以加上一个非常小的数 `epsilon=0.000001`

### 2.3.2 三角形的裁剪

三角形的裁剪要比直线的裁剪复杂一点，因为三角形裁剪之后会得到一个多边形，那么我们需要用这些与边界的交点构建出多个新的三角形，然后继续光栅化。三角形与 CVV 相交的情况有以下三种：

![img](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='932' height='288'></svg>)

最容易想到的做法是对三角形的三条边分别进行 Cohen-Sutherland 裁剪算法，分别找到三角形三条边与 CVV 的交点，然后构造出新的三角形。这也可以推广到任意凸多边形的情况。

![img](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='411' height='370'></svg>)

在硬件光栅化的做法是用的是一个比视口大很多的“虚拟视口”，也即放宽需要裁剪的区域，如果有片元不在视口内，则在光栅化阶段自行判断。这么做是为了因为虽然有的片元有一部分在可视区域内，但大部分都不在，那么直接舍弃。而如果有的图元只有小部分在可视范围外，那么保留它，在光栅化阶段自行判断片元的去留。

> 裁剪操作是为了避免不可见的片元的光栅化，其目的是为了提高光栅化算法的效率。但裁剪本身也会带来消耗，所以在硬件光栅化流水线中，是否裁剪？如何裁剪？是一个常常引起争议的话题，除非是了解硬件的工程师。这里只是对裁剪算法做一个简单介绍，具体情况还需要请教相关人士。



### 2.4 屏幕映射

图形渲染的目标是生成一张二维的图像或输出到显示器。这个图像有固定的分辨率 ![[公式]](https://www.zhihu.com/equation?tex=w%5Ctimes+h) 。同样我们也可以为这个图像建立一个坐标系，比如以图像右下角为原点，向右为 ![[公式]](https://www.zhihu.com/equation?tex=x) 轴，向上为 ![[公式]](https://www.zhihu.com/equation?tex=y) 轴。图像空间也是有取值范围的，它的取值范围是 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cin+%5B0%2Cw%5D%2C%5C+y%5Cin+%5B0%2Ch%5D) 。

屏幕映射的目的就是找到齐次坐标范围 ![[公式]](https://www.zhihu.com/equation?tex=%5B0%2C1%5D%5E3) 内的顶点，对应图像坐标中的哪一个像素。屏幕映射非常简单，就只是对齐次裁剪坐标进行缩放。

以我们最终生成图像的分辨率为 ![[公式]](https://www.zhihu.com/equation?tex=1920%5Ctimes+1080) ，屏幕映射的伪代码如下：

```cpp
const int IMAGE_WIDTH = 1920;
const int IMAGE_HEIGHT = 1080;
unsigned int2 ScreenMapping(Vertex v)
{
    unsigned int2 screenPos;
    screenPos.x = unsigned int(round(v.position.x * IMAGE_WIDTH));
    screenPos.y = unsigned int(round(v.position.y * IMAGE_HEIGHT));
    return screenPos;
}
```

### 2.5 顶点着色

顶点着色是通过顶点的属性，计算顶点的颜色，着色是非常重要的一步但并不是本文的重点。通过顶点着色计算得到的颜色值，在光栅化阶段经过插值可以得到片元的颜色。我们也可以把顶点的属性插值得到片元的属性，留到逐片元操作阶段再进行着色。

------

## 3 图元的扫描转换与插值

光栅化也称为扫描转换，也即将连续的图元离散成一个个相邻的像素。

通过屏幕映射，我们找到了图元顶点对应的图像坐标，我们需要用这个坐标找到图元内部的片元，这就是所谓的光栅化。点图元是不需要光栅化的，下面也主要介绍直线和三角形的光栅化。光栅化的任务除了找到图元覆盖的片元，还要插值出片元的属性。对于透视投影，还需要透视纠正，也就是 ![[公式]](https://www.zhihu.com/equation?tex=1%2Fz) 的由来。

### 5.1 直线的光栅化

直线的画线算法有很多，可以运用直线方程找到直线的每一个片元。但这种做法涉及浮点运算，下面介绍一种直线光栅化最常用的算法 —— Bresenham 算法。Bresenham 算法根据直线和屏幕像素的特点，规避了浮点数运算。

```cpp
void DrawLine(Line l)
{
    int2 p1 = l.vertices[0].screenPos;
    int2 p2 = l.vertices[1].screenPos;

    bool steep = false;
    if(abs(p1.x - p2.x) < abs(p1.y - p2.y)){ // 保证在画线的时候斜率小于 1
        swap(p1.x, p2.x);
        swap(p1.y, p2.y);
        steep = true;
    }

    int dx = p2.x - p1.x;
    int dy = p2.y - p1.y;

    int derror2 = abs(dy) * 2;
    int error2 = 0;
    int y = p1.y;
    for (int x = p1.x; x <= p2.x; x++) {
        Fragment f;
        if (steep) 
            f.screenPos = int2(y, x); 
        else 
            f.screenPos = int2(x, y);
        error2 += derror2;
        if (error2 > dx) {
            y += (p2.y > p1.y ? 1 : -1);
            error2 -= dx * 2;
        }

        // 线性插值
        float t = float(abs(x - p1.x)) / float(abs(p1.x - p2.x));
        lerp(l.vertices[0], l.vertices[1], t, f);

        // 将片元交由下一阶段
        Output(f);
    }
}
```

> 完整的 Bresenham 算法需要对直线斜率为 0，斜率不存在，两端点重合等情况做特殊处理。



### 5.1.2 线性插值

在画线算法中，有一步**线性插值**，其作用是通过顶点属性得到这一片元的属性。线性插值是插值节点数为 2 的拉格朗日插值，可以参考我的数值分析的笔记：[插值](https://zhuanlan.zhihu.com/p/360882227)。线性插值是图形学中非常常见的操作。其伪代码如下：

```cpp
void lerp(Vertex v1, Vertex v2, float t, out Fragment f)
{
    foreach attributes in Vertex
    {
        f.attr = v1.attr * t + v2.attr * (1 - t);
    }
}
```

> 在裁剪算法中，用新顶点替换旧顶点，新顶点的属性也是通过线性插值得到的



### 5.1.3 透视纠正插值

下面介绍在透视投影中， ![[公式]](https://www.zhihu.com/equation?tex=1%2Fz) 的由来。

![img](https://pic2.zhimg.com/80/v2-99d6196de14d254af57d857eaad2ced9_1440w.jpg)

上图中，通过透视.投影，齐次除法与屏幕映射，我们找到了直线 ![[公式]](https://www.zhihu.com/equation?tex=v_0v_1) 的顶点对应的屏幕坐标 ![[公式]](https://www.zhihu.com/equation?tex=v_0%5E%7B%5Cprime%7Dv_1%5E%7B%5Cprime%7D) ，通过光栅化找到等距节点 ![[公式]](https://www.zhihu.com/equation?tex=A%5E%7B%5Cprime%7D%2C%5C+B%5E%7B%5Cprime%7D%2C%5C+C%5E%7B%5Cprime%7D) ，以及它们对应的 ![[公式]](https://www.zhihu.com/equation?tex=t%3D%5Cfrac%7B1%7D%7B4%7D%2C%5C+%5Cfrac%7B2%7D%7B4%7D%2C%5C+%5Cfrac%7B3%7D%7B4%7D) 。通过透视关系，我们找到了它们对应原直线上的 ![[公式]](https://www.zhihu.com/equation?tex=A%2C%5C+B%2C%5C+C) 三点。我们现在需要用 ![[公式]](https://www.zhihu.com/equation?tex=v_0v_1) 上的属性与这里的 ![[公式]](https://www.zhihu.com/equation?tex=t) 找到 ![[公式]](https://www.zhihu.com/equation?tex=A%2C%5C+B%2C%5C+C) 三点的属性。

根据相似三角形， 在 ![[公式]](https://www.zhihu.com/equation?tex=x) 轴方向上，有如下关系

![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7B%7Cv_0A%7C_x%7D%7B%7Cv_0v_1%7C_x%7D+%3D+%5Cfrac%7B%7Cv_0%5E%7B%5Cprime%7DA%5E%7B%5Cprime%7D%7C_x%7D%7B%7Cv_0%5E%7B%5Cprime%7Dv_1%5E%7B%5Cprime%7D%7C_x%7D+%3D+%5Cfrac%7B1%7D%7B4%7D%2C%5C+%5Cfrac%7B%7Cv_0B%7C_x%7D%7B%7Cv_0v_1%7C_x%7D+%3D+%5Cfrac%7B%7Cv_0%5E%7B%5Cprime%7DB%5E%7B%5Cprime%7D%7C_x%7D%7B%7Cv_0%5E%7B%5Cprime%7Dv_1%5E%7B%5Cprime%7D%7C_x%7D+%3D+%5Cfrac%7B2%7D%7B4%7D%2C%5C+%5Cfrac%7B%7Cv_0C%7C_x%7D%7B%7Cv_0v_1%7C_x%7D+%3D+%5Cfrac%7B%7Cv_0%5E%7B%5Cprime%7DC%5E%7B%5Cprime%7D%7C_x%7D%7B%7Cv_0%5E%7B%5Cprime%7Dv_1%5E%7B%5Cprime%7D%7C_x%7D+%3D+%5Cfrac%7B3%7D%7B4%7D)

那么有：

![[公式]](https://www.zhihu.com/equation?tex=A_x+%3D+%5Cfrac%7B1%7D%7B4%7Dv_%7B0x%7D%2B%5Cfrac%7B3%7D%7B4%7Dv_%7B1x%7D%2C%5Cquad+B_x%3D%5Cfrac%7B2%7D%7B4%7Dv_%7B0x%7D%2B%5Cfrac%7B2%7D%7B4%7Dv_%7B1x%7D%2C%5Cquad++C_x+%3D+%5Cfrac%7B3%7D%7B4%7Dv_%7B0x%7D%2B%5Cfrac%7B1%7D%7B4%7Dv_%7B1x%7D)

类似的 ![[公式]](https://www.zhihu.com/equation?tex=y) 轴方向上也有类似的关系。但 ![[公式]](https://www.zhihu.com/equation?tex=z) 方向的却不满足上述关系，也即：

![[公式]](https://www.zhihu.com/equation?tex=A_z+%5Cneq+%5Cfrac%7B1%7D%7B4%7Dv_%7B0z%7D%2B%5Cfrac%7B3%7D%7B4%7Dv_%7B1z%7D)

根据三角形的相似，有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7BA_x%7D%7BA%5E%7B%5Cprime%7D_x%7D%3D%5Cfrac%7BA_z%7D%7Bn%7D)

解得： ![[公式]](https://www.zhihu.com/equation?tex=A_z+%3D+n%5Cfrac%7BA_x%7D%7BA%5E%7B%5Cprime%7D_x%7D%3Dn%5Cfrac%7B1%2F4v_%7B0x%7D%2B3%2F4v_%7B1x%7D%7D%7B1%2F4v%5E%7B%5Cprime%7D_%7B0x%7D%2B3%2F4v%5E%7B%5Cprime%7D_%7B1x%7D%7D)

根据三角形的相似，有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7Bv_%7B0x%7D%7D%7Bv%5E%7B%5Cprime%7D_%7B0x%7D%7D%3D%5Cfrac%7Bv_%7B0z%7D%7D%7Bn%7D%2C%5Cquad+%5Cfrac%7Bv_%7B1x%7D%7D%7Bv%5E%7B%5Cprime%7D_%7B1x%7D%7D%3D%5Cfrac%7Bv_%7B1z%7D%7D%7Bn%7D)

那么把 ![[公式]](https://www.zhihu.com/equation?tex=v%5E%7B%5Cprime%7D_%7B0x%7D%3D%5Cfrac%7Bnv_%7B0x%7D%7D%7Bv_%7B0z%7D%7D%2C%5Cquad+v%5E%7B%5Cprime%7D_%7B1x%7D%3D%5Cfrac%7Bnv_%7B1x%7D%7D%7Bv_%7B1z%7D%7D) 带入 ![[公式]](https://www.zhihu.com/equation?tex=A_z) 的方程，得：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A_z+%3D%26+n%5Cfrac%7BA_x%7D%7BA%5E%7B%5Cprime%7D_x%7D%3Dn%5Cfrac%7B1%2F4v_%7B0x%7D%2B3%2F4v_%7B1x%7D%7D%7B%5Cfrac%7Bnv_%7B0x%7D%7D%7B4v_%7B0z%7D%7D%2B%5Cfrac%7B3nv_%7B1x%7D%7D%7B4v_%7B1z%7D%7D%7D%5C%5C+%3D%26%5Cfrac%7Bv_%7B0z%7Dv_%7B1z%7D%28v_0x%2B3v_%7B1x%7D%29%7D%7Bv_%7B0x%7Dv_%7B1z%7D%2B3v_%7B0z%7Dv_%7B1x%7D%7D+%5Cend%7Balign%7D)

那么：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%5Cfrac%7B1%7D%7BA_z%7D+%26+%3D+%5Cfrac%7Bv_%7B0x%7Dv_%7B1z%7D%2B3v_%7B0z%7Dv_%7B1x%7D%7D%7Bv_%7B0z%7Dv_%7B1z%7D%28v_0x%2B3v_%7B1x%7D%29%7D%5C%5C+%26%3D%5Cfrac%7Bv_%7B0x%7D%7D%7Bv_%7B0z%7D%28v_%7B0x%7D%2B3v_%7B1x%7D%29%7D%2B%5Cfrac%7B3v_%7B1x%7D%7D%7Bv_%7B1z%7D%28v_%7B0x%7D%2B3v_%7B1x%7D%29%7D%5C%5C+%26%3D%5Cfrac%7B1%7D%7Bv_%7B0z%7D4%7D%2B%5Cfrac%7B3%7D%7Bv_%7B1z%7D4%7D+%3D+t%5Cfrac%7B1%7D%7Bv_%7B0z%7D%7D%2B%281-t%29%5Cfrac%7B1%7D%7Bv_%7B1z%7D%7D+%5Cend%7Balign%7D)

因此对于深度，需要用 ![[公式]](https://www.zhihu.com/equation?tex=z) 坐标的倒数进行插值。

而对于顶点的一般属性，比如 uv 坐标、顶点法线、顶点颜色，插值点的属性与顶点属性有如下关系：

![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7BA_%7Battr%7D-v_%7B0attr%7D%7D%7Bv_%7B1attr%7D-v_%7B0attr%7D%7D%3D%5Cfrac%7BA_z-v_%7B0z%7D%7D%7Bv_%7B1z%7D-v_%7B0z%7D%7D)

整理得：

![[公式]](https://www.zhihu.com/equation?tex=A_%7Battr%7D+%3D+A_%7Bz%7D%5B%5Cfrac%7Bv_%7B0attr%7D%7D%7Bv_0z%7Dt%2B%5Cfrac%7Bv_%7B1attr%7D%7D%7Bv_%7B1z%7D%7D%281-t%29%5D)

所以在齐次除法之前，我们需要对顶点的每一个属性除以此时的 w 分量，也即除以摄像机坐标下顶点的 z 分量。在光栅化阶段正常线性插值。在运用这个属性时，要乘以该片元在摄像机坐标下的 z 分量，才是这个属性真正的值。

```cpp
// 顶点变换阶段
line.vertices[0].position = mul(MVP, line.vertices[0].position); // 模型视图投影变换
line.vertices[0].uv = line.vertices[0].uv / line.vertices[0].position.w; // 对 uv 属性透视纠正
line.vertices[0].position = (1 / line.vertices[0].position.w) * line.vertices[0].position; // 齐次除法

......

// 在片元着色中
float z = 1 / frag.position.z;
float2 uv = line.vertices[0].uv * z;
```

![img](https://pic4.zhimg.com/80/v2-df04a4948b671701081f2324dafcc17f_1440w.jpg)

> 透视纠正插值的原理是透视投影的交比不变性。

### 5.2 三角形的光栅化

三角形有三个顶点，我们规定输入的三个顶点是按逆时针顺序排列的。

三角形的扫描转换的核心是判断这一像素是否在三角形内，在上一章[光线追踪](https://zhuanlan.zhihu.com/p/370440796)中，就介绍了利用重心判断点与三角形之间的位置关系。这里同样可以利用重心坐标实现三角形的扫描转换操作。下面再回顾一下重心坐标的推导：

平面上任意一点 ![[公式]](https://www.zhihu.com/equation?tex=P) 与 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbigtriangleup+P_0P_1P_2) 有如下关系：

![[公式]](https://www.zhihu.com/equation?tex=%5Cvec%7BP_0P%7D+%3D+%5Comega_1%5Cvec%7BP_0P_1%7D+%2B+%5Comega_2%5Cvec%7BP_0P_2%7D%5Cquad+%281%29)

![img](https://pic3.zhimg.com/80/v2-5d1c748611b9f154830c736cf4ba8d3a_1440w.jpg)

稍微整理一下可以得到重心坐标公式：

![[公式]](https://www.zhihu.com/equation?tex=P+%3D+%281-%5Comega_0-%5Comega_1%29P_0+%2B+%5Comega_0P_1+%2B+%5Comega_1P_2)

由上式 (1) 可以联立一个二元一次方程组：

![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D++%5Comega_1%5Cvec%7BP_0P_1%7D_x+%2B+%5Comega_2%5Cvec%7BP_0P_2%7D_x+%2B+%5Cvec%7BPP_0%7D_x+%3D+0%5C%5C++%5Comega_1%5Cvec%7BP_0P_1%7D_y+%2B+%5Comega_2%5Cvec%7BP_0P_2%7D_y+%2B+%5Cvec%7BPP_0%7D_y+%3D+0+%5Cend%7Bmatrix%7D%5Cright.)

我们不会硬解这个方程，这不便于程序实现，也容易造成误差。通过观察，我们发现 (1) 方程可以拆解成两个向量的点乘形式

![[公式]](https://www.zhihu.com/equation?tex=%28%5Comega_1%2C%5Comega_2%2C1%29+%5Ccdot+%28%5Cvec%7BP_0P_1%7D_x%2C%5Cvec%7BP_0P_2%7D_x%2C%5Cvec%7BPP_0%7D_x%29+%3D+0%5C%5C+%28%5Comega_1%2C%5Comega_2%2C1%29+%5Ccdot+%28%5Cvec%7BP_0P_1%7D_y%2C%5Cvec%7BP_0P_2%7D_y%2C%5Cvec%7BPP_0%7D_y%29+%3D+0)

由点乘的几何意义，向量 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Comega_1%2C%5Comega_2%2C1%29) 同时垂直于向量 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Cvec%7BP_0P_1%7D_x%2C%5Cvec%7BP_0P_2%7D_x%2C%5Cvec%7BPP_0%7D_x%29) 和向量 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Cvec%7BP_0P_1%7D_y%2C%5Cvec%7BP_0P_2%7D_y%2C%5Cvec%7BPP_0%7D_y%29) ，也即三维向量 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Comega_1%2C%5Comega_2%2C1%29) 垂直于向量 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Cvec%7BP_0P_1%7D_x%2C%5Cvec%7BP_0P_2%7D_x%2C%5Cvec%7BPP_0%7D_x%29) 和向量 ![[公式]](https://www.zhihu.com/equation?tex=%28%5Cvec%7BP_0P_1%7D_y%2C%5Cvec%7BP_0P_2%7D_y%2C%5Cvec%7BPP_0%7D_y%29) 构成的平面，那么：

![[公式]](https://www.zhihu.com/equation?tex=%28a%2Cb%2Cc%29+%3D+%28%5Cvec%7BP_0P_1%7D_x%2C%5Cvec%7BP_0P_2%7D_x%2C%5Cvec%7BPP_0%7D_x%29+%5Ctimes+%28%5Cvec%7BP_0P_1%7D_y%2C%5Cvec%7BP_0P_2%7D_y%2C%5Cvec%7BPP_0%7D_y%29%5C%5C++%28%5Comega_1%2C+%5Comega_2%2C+1%29+%3D+%28%5Cfrac%7Ba%7D%7Bc%7D%2C+%5Cfrac%7Bb%7D%7Bc%7D%2C+%5Cfrac%7Bc%7D%7Bc%7D%29)

用伪代码表示为：

```cpp
void DrawTriangle(Triangle t) {
    // 三角形的包围盒
    int minViewPortX = INT_MAX;
    int maxViewPortX = INT_MIN;
    int minViewPortY = INT_MAX;
    int maxViewPortY = INT_MIN;

    FindBoundingBox(t, minScreenPosX, maxScreenPosX, minScreenPosY, maxScreenPosY);

    // 光栅化
    for (int i = minScreenPosX; i <= maxScreenPosX; ++i) {
        for (auto j = minScreenPosY; j <= maxScreenPosY; ++j) {
            int2 P(i, j);
            int2 P0P2 = t.vertices[1].screenPos - t.vertices[0].screenPos;
            int2 P0P =  P - t.vertices[0].screenPos;
            int2 P2P1 = t.vertices[1].screenPos - t.vertices[2].screenPos;
            int2 P2P =  P - t.vertices[2].screenPos;
            int2 P1P0 = t.vertices[0].screenPos - t.vertices[1].screenPos;
            int2 P1P =  P - t.vertices[1].screenPos;

            int tmp1 = P0P2.x * P0P.y - P0P.x * P0P2.y; // axis-z
            int tmp2 = P2P1.x * P2P.y - P2P.x * P2P1.y;
            int tmp3 = P1P0.x * P1P.y - P1P.x * P1P0.y;

            bool condition1 = tmp1 >= 0 && tmp2 >= 0 && tmp3 >= 0; // 逆时针三角形
            // bool condition1 = tmp1 < 0 && tmp2 < 0 && tmp3 < 0;    // 顺时针三角形

            if (condition1){
                // 重心坐标
                float3 vx = float3(-P1P0.x, P0P2.x, -P0P.x);
                float3 vy = float3(-P1P0.y, P0P2.y, -P0P.y);
                float3 result = cross(vx, vy);
                float a, b, c;
                b = result.x / result.z;
                c = result.y / result.z;
                a = 1 - b - c;

                // 插值
                Fragment frag;
                frag.viewportPos = ivec2(i, j);
                frag.ndcPos = a * t.vertices[0].position + b * t.vertices[1].position + c * t.vertices[2].position;
                frag.color = a * t.vertices[0].color + b * t.vertices[1].color + c * t.vertices[2].color;
                frag.normal = a * t.vertices[0].normal + b * t.vertices[1].normal + c * t.vertices[2].normal;
                frag.uv = a * t.vertices[0].uv + b * t.vertices[1].uv + c * t.vertices[2].uv;

                Output(frag); // 将片元交由下一阶段
            }
        }
    }
}
```



运用重心坐标插值，同样需要透视纠正，画出这个三角形，并对颜色属性插值，三个顶点的颜色分别为：![[公式]](https://www.zhihu.com/equation?tex=%281%2C0%2C0%29%2C%5C+%280%2C0%2C1%29%2C%5C+%280%2C1%2C0%29) 可以得到下图：

![img](https://pic2.zhimg.com/80/v2-ad0f0087421bee2e3b288c9ab47455fd_1440w.jpg)

### 5.2.3 背面剔除

之所以规定三角形三个顶点是逆时针排序的，除了重心坐标算法与顶点顺序有关，规定逆时针排序，还可以给光栅化算法提供一步优化 —— 背面剔除（back face culling）。

**用外积确定平面的方向**：通过外积，我们可以得到三角形面的法线。我们知道不共线的三点确定一个平面， ![[公式]](https://www.zhihu.com/equation?tex=%5Cbigtriangleup+ABC) 的有三个顶点，可以确定一个平面。我们规定逆时针遍历三角形顶点的顺序为正，也即 ![[公式]](https://www.zhihu.com/equation?tex=A%2CB%2CC) 是按逆时针遍历得到的，根据右手定则，四指弯曲的方向指向三角形的顶点遍历的方向，拇指的指向即为三角形的方向。我们可以得到

![[公式]](https://www.zhihu.com/equation?tex=n+%3D+%5Cvec%7BAB%7D%5Ctimes%5Cvec%7BAC%7D+%3D+%5Cvec%7BBC%7D%5Ctimes%5Cvec%7BBA%7D+%3D+%5Cvec%7BCA%7D%5Ctimes%5Cvec%7BCB%7D)

为平面的正法向量，反之为负法向量。

![img](https://pic3.zhimg.com/80/v2-4eba4420a2fd6909111090f947d251fa_1440w.jpg)

对于一个封闭的不透明物体，其背面的三角形是不可见的，因此我们可以根据这一特性，剔除掉背面的三角形，从而减少三角形的绘制。其做法也非常简单：

```cpp
void BackFaceCulling(Triangle t)
{
    float3 P0P1 = t.vertices[1].position - t.vertices[0].position;
    float3 P0P2 = t.vertices[2].position - t.vertices[0].position;
    float3 n = cross(P0P1, P0P2);
    float3 dir = GetViewDir();
    if (dot(n, dir) >= 0){
        cull triangle;
    }
    else {
        draw triangle;
    }
}
```



------

## 4 逐片元操作

通过扫描转换与插值，我们得到了每个图元所覆盖的像素区域 —— 片元。那么逐片元操作就是遍历每一个片元完成相应操作，而具体做什么由我们自己定。在现代光栅化硬件中，逐片元操作可交由用户编程，从而实现丰富的图形效果，称为**片元着色器。**通常，为了完成一个三维场景的渲染，我们需要完成以下操作：

1. 片元着色
2. 深度测试
3. 颜色混合
4. 模板测试



```cpp
foreach object in objects {
    foreach primitive in object {
        foreach fragment in primitive {
             Do Something ...
        }
    }
}
```

通常，片元的数量是远多于顶点的，因此逐片元操作的开销要远大于逐顶点操作。但因为物体间的遮挡关系，在一次渲染中，有的片元是不可见的。对于最终图像上的某一个像素，可能会有多个片元定位到这里，但因为遮挡关系，最终只有一个片元是可见的。如果这些不可见的片元都被绘制了，无疑会造成浪费，这种浪费称为 **OverDraw**。因此减少 OverDraw 可以有效的减少逐片元操作的开销。



### 4.1 深度测试

简单讲，深度测试就是一个逐片元的 `if-else` 。在投影变换时，齐次裁剪坐标的第三维记录了这一片元的深度。我们可以利用这一深度值，完成片元之间的遮挡判断。

深度测试的比较条件是越小离摄像机越近，也即可见点的距离近裁剪面越近，则深度值越小。

我们需要用一个二维数组存储每一个像素的最小深度值，这个二维数组称为**深度缓存**。每一个片元可以执行两个操作：1. 深度写入；2. 深度测试。用伪代码表示为：

```cpp
float zBuffer[SCREEN_WIDTH][SCREEN_HEIGHT];

void ZWrite(Fragnmet f){
    int2 screenPos = f.screenPos;
    zBuffer[screenPos.x][screenPos.y] = f.position.z;
}

void ZTest(Fragment f){
    int2 screenPos = f.screenPos;
    float zMin = zBuffer[screenPos.x][screenPos.y];
    if(zMin >= f.position.z){
        z test pass;
        ZWrite(f);
    }
    else{
        z test fail;
    }
}
```

> 在深度测试阶段，我们可以选择不进行深度写入，比如在半透明物体的渲染时就需要关闭深度写入



### 4.2 画家算法与绘制顺序

在介绍颜色混合前，先介绍**画家算法**，画家算法是另一种解决场景物体遮挡的手段。它需要场景中的物体根据其深度进行排序，然后从距离摄像机最远的物体一个一个画，最后画距离摄像机最近的物体。

画家算法相较于深度测试算法的缺点非常明显，首先它不能解决物体的自遮挡问题，其次它是与渲染顺序高度相关，而且 OverDraw 很高。其优点不过是节省了一个深度缓存。

虽然在主流的光栅化算法的实现中，几乎不用画家算法，但也牵扯出了光栅化算法一大重要内容 —— **绘制顺序**。

对于不透明物体的绘制，我们不需要控制物体的绘制顺序，运用深度测试算法的就已经能完成物体间正确的遮挡关系。但这并不意味这在光栅化算法中，绘制顺序不重要，下面的颜色混合和模板测试就与绘制顺序高度相关。

通常对于不透明物体，我们先绘制距离摄像机近的，再绘制距离摄像机远的，这样可以提前进行深度测试 **pre-Z** ，明确每一片元的可见性，如果某一片元被遮挡，那么就不继续进行后面的操作，减少 OverDraw。



### 4.3 颜色混合

颜色混合也需要一个二维数组，记录每一个像素的 RGBA 颜色值，称为**颜色缓存**。所谓的颜色混合，就是把当前片元的颜色与颜色缓存中的颜色按照某一规则进行混合。颜色混合与渲染顺序相关，先到的片元会将混合的结果写入颜色缓存，后到的片元会使用之前颜色混合的结果。用伪代码表示为：

```cpp
float4 colorBuffer[SCREEN_WIDTH][SCREEN_HEIGHT];

void Blend(Fragment f)
{
    float4 fColor = f.color; // 片元颜色
    float4 bColor = colorBuffer[f.screenPos.x][f.screenPos.y]; // 颜色缓存颜色
    float4 result = BlendOp(fColor, bColor);  // 混合操作
    colorBuffer[f.screenPos.x][f.screenPos.y] = result; // 将混合结果写入缓存
}
```

这里的混合规则 `BlendOp(float4 srcColor, float4 dstColor)` 在 Photoshop 中都一个名字

```cpp
// 正常 透明度混合
srcColor.rgb * srcColor.a + dstColor.rgb * (1 - dstColor.a);

// 
```

通常，在光栅化算法中，半透明物体的绘制都会采用上面的第一种 `BlendOp` 透明度混合。混合操作与渲染顺序高度相关，为了正确绘制半透明物体，我们需要先绘制距离摄像机远的物体，再绘制距离摄像机近的物体。因此，半透明物体的绘制不能进行 pre-Z，会带来一定的 OverDraw。

> 同时需要关闭深度写入，但需要进行深度测试，因为这个半透明片元可能会被某一不透明片元遮挡



### 4.3 模板测试

模板测试和深度测试一样，也是一个逐片元的 `if-else` 。

模板测试也需要有一个二维数组，称为**模板缓存**，存储每一个像素的参考值，这个参考值的取值范围是 `0~255` 的整数。

每个片元在进行模板测试前也会提前设定一个参考值 `ref`，这个参考值的取值范围也是 `0~255` 的整数。

我们那这两个参考值进行比较，决定这个片元是否通过模板测试，如果通过测试，则继续保留片元，反之则舍弃片元。

```cpp
int stencilBuffer[SCREEN_WIDTH][SCREEN_HEIGHT];

void StencilTest(Fragment f)
{
    int fRef = f.ref;
    int bRef = stencilBuffer[f.screenPos.x][f.screenPos.y];
    if(StencilComp(fRef, bRef)){
        stencil test pass;
        StencilPassOp();
    }
    else {
        stencil test fail;
        StencilFailOp();
    }
}
```

其中 `StencilComp` 可以是 `>, <, >=, <=, !=, ==` 中的任意一个 ，也可以总返回 `false` 或总返回 `true` 。

`StencilPassOp, StencilFailOp` 主要是模板缓冲区的写入操作，比如使模板缓冲区的 `ref` 自增、自减、归零，可以把片元的 `ref` 写入缓冲区，也可以保存缓冲区值不变。

模板测试也是一个跟渲染顺序相关的算法，类似于 pre-Z，我们可以 pre-Stencil，提前舍弃不可见的片元，减少 OverDraw。



### 4.4 帧缓存

在上面逐片元操作中，涉及到若干个缓存，这些缓存都一个共同特点，就是它的大小与图像分辨率有关。上面深度缓存、颜色缓存、模板缓存统称为帧缓存。帧缓存需要定义三个操作：1. 读（Read）；2. 写（Write）；3. 清除（Clear）。在上面的逐片元操作中，已经涉及了帧缓存的读写操作，而清除操作是在需要绘制多帧的情况下才需要，如果是单帧绘制则不需要清除。所谓的清除，就是把这个二维数组重新用默认值填充：

```cpp
void ClearBuffer(out FrameBuffer buffer)
{
    for(int i=0, i < SCREEN_WIDTH; i++)
    {
        for(int j=0; j<SCREEN_HEIGHT; j++)
        {
             buffer = DEFAULT_VALUE; 
        }
    }
}
```

> 在工业界，帧缓存自然不止上面三种，在具体情况还会分配更多的帧缓存

------

## 5 反走样

我们把经过光栅化算法得到的图像放大，可以看到边缘有非常明显的锯齿，这在信号处理领域称为**走样（Aliasing）**。

图元是一个连续的几何图形，而我们的图像是一些离散的像素点，图元经过光栅化算法得到片元就是一个**采样（Sampling）**过程，而用这些离散的片元表示原来的图元称为**重建（Reconstruction）**。

图元可以用一个连续函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 表示，称为**模拟信号**，采样就是从这个函数中得到一个点集 ![[公式]](https://www.zhihu.com/equation?tex=%5C%7Bx_i%2Cf%28x_i%29%5C%7D) ，称为数字信号。重建就是通过一个**滤波（filter）**构造出另一个函数 ![[公式]](https://www.zhihu.com/equation?tex=%5Cwidetilde%7Bf%28x%29%7D) 。使得 ![[公式]](https://www.zhihu.com/equation?tex=%5Cwidetilde%7Bf%28x%29%7D) 尽可能逼近 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 。但毕竟 ![[公式]](https://www.zhihu.com/equation?tex=%5Cwidetilde%7Bf%28x%29%7D+%5Cneq+f%28x%29) ，所以采样重建的过程必然是有损的，当这个损失令我们不能接受时，那么就发生了走样。

对模拟型号施加[傅里叶变换](https://zhuanlan.zhihu.com/p/359682056)，可以把它从时域变换到频域，频域图像反应了信号更多的特征。最重要的自然是信号的频率。在图元的边界属于高频部分，图元内部属于低频部分。走样往往发生在信号的高频部分。通过采样定理，我们可以得到反走样的方法。

**采样定理（The Sampling Theorem）**：简单的说，当采样频率大于等于原始模拟信号 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 最大频率两倍时，离散信号能重建出原始信号。



![img](https://pic2.zhimg.com/80/v2-215baa8b499295fd26ace592f14e5cb1_1440w.jpg)





### 5.1 超采样反走样

**超采样反走样（Super Sampling Anti-Aliasing，SSAA**）是最简单，效果最好，开销最大的一种反走样的技术，它直接对症下药，走样是因为采样率不足导致的，那么超采样就直接提高采样频率。

对于光栅化算法来说，以最终生成 ![[公式]](https://www.zhihu.com/equation?tex=200%5Ctimes+200) 的图像为例，超采样技术直接用 ![[公式]](https://www.zhihu.com/equation?tex=400%5Ctimes+400) 的分辨率生成一张图像，再用一个盒子滤波器，将每 ![[公式]](https://www.zhihu.com/equation?tex=2%5Ctimes+2) 像素的颜色平均成一个像素的颜色，写入目标图像对应像素中。

它相当于把原来的一个像素，拆成了 4 个小像素，用着四个小像素去采样图元得到各自的片元。每个小片元单独执行逐片元。每个小片元都要执行片元着色，深度测试，颜色混合，模板测试的操作，所以帧缓存也要跟着翻倍。

相比与原来，需要处理的像素翻了 4 倍，帧缓存也翻了 4 倍。自然我们可也可以用 ![[公式]](https://www.zhihu.com/equation?tex=800%5Ctimes+800%2C%5C+1600%5Ctimes+1600) 的分辨率去生成图像，这无非是更大的开销和更好的反走样效果。



![img](https://pic3.zhimg.com/80/v2-44b021cb26f1ba4fd5971dd8bf033b4a_1440w.jpg)

> 简单来说，SSAA 算法就是先生成一张更高分辨率的图像，再把它缩放到目标分辨率。SSAA 算法是暴力反走样，虽然效果最好，但开销也大。





### 5.2 多重采样反走样

**多重采样反走样（Multi-Sampling Anti-Aliasing，MSAA）**是在超采样的基础上稍微的妥协了一下。在逐片元操作中，最费时的操作是片元着色，MSAA 在这里做出了妥协。

还是以生成 ![[公式]](https://www.zhihu.com/equation?tex=200%5Ctimes+200) 的图像为例，多重采样技术同样用 ![[公式]](https://www.zhihu.com/equation?tex=400%5Ctimes+400) 的分辨率生成一张图像，同样将原来一个像素拆成四个小像素，但图元的每个小片元不会单独计算片元着色，而是计算原来 ![[公式]](https://www.zhihu.com/equation?tex=200%5Ctimes+200) 时得到的那个大片元的颜色。如果四个小片元中，有一个片元没有被图元覆盖，或者没有通过片元测试，则赋给它颜色缓存中的颜色；如果片元被图元覆盖，或者通过了片元测试，则覆盖它片元着色的颜色。最后还是用一个盒子滤波，将每 ![[公式]](https://www.zhihu.com/equation?tex=2%5Ctimes+2) 个像素的颜色平均起来写入目标图像对应像素中。

> 将四个小片元直接平均的结果可能并不好，通常会通过小片元的覆盖率加权平均。

总结一下多重采样技术，其相比于 SSAA，其减少了片元着色操作，但同样需要原来 4 倍的逐片元操作和 4 倍的帧缓存。开销同样不小。

![img](https://pic3.zhimg.com/80/v2-44b021cb26f1ba4fd5971dd8bf033b4a_1440w.jpg)

> 多重采样反走样是被广泛支持的否走样技术，并且得到了硬件的支持。上面提到的走样有属于同一种分类 —— **几何走样**。还有另外一种走样称为**着色走样**，因为渲染方程也是一个连续函数，对某些部分（比如法线，高光等）在空间变化较快（高频部分）采样不足也会造成走样，反映在视觉上一般是图像闪烁或者噪点。SSAA 即可以减轻几何走样，也可以减轻着色走样；但 MSAA 只能减轻几何走样。
> 在工业级还有很多种反走样算法，比如 FXAA，TAA，DLSS 等，这里就不在深究了。

编辑于 10-17 17:47

计算机图形学

DirectX

OpenGL

赞同 62

4 条评论

分享