# 带你彻底理解RSA算法原理

[TOC]

## 1. 什么是RSA

RSA算法是现今使用最广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语
根据密钥的使用方法，可以将密码分为对称密码和公钥密码
对称密码：加密和解密使用同一种密钥的方式
公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。

## 2. RSA算法

### 2. 1 RSA加密

RSA的加密过程可以使用一个通式来表达
$$
enx = x^E mod\ N
$$


也就是说RSA加密是对明文的E次方后除以N后求余数的过程。就这么简单？对，就是这么简单。
从通式可知，只要知道E和N任何人都可以进行RSA加密了，所以说E、N是RSA加密的密钥，也就是说**E和N的组合就是公钥**，我们用(E,N)来表示公钥

> ### 公钥＝(E,N) 

不过E和N不并不是随便什么数都可以的，它们都是经过严格的数学计算得出的，关于E和N拥有什么样的要求及其特性后面会讲到。顺便啰嗦一句E是加密（Encryption）的首字母，N是数字（Number）的首字母

### 2.2  RSA解密

RSA的解密同样可以使用一个通式来表达
$$
x = enx^D mod\ N
$$


也就是说对密文进行D次方后除以N的余数就是明文，这就是RSA解密过程。知道D和N就能进行解密密文了，所以D和N的组合就是私钥(D,N)

从上述可以看出RSA的加密方式和解密方式是相同的，加密是求“E次方的mod N”;解密是求“D次方的mod N”
此处D是解密（Decryption）的首字母；N是数字（Number）的首字母。

小结下

|        |                     |
| ------ | ------------------- |
| 公钥   | （E，N）            |
| 私钥   | （D，N）            |
| 密钥对 | （E，D，N）         |
| 加密   | 密文＝明文^ E mod N |
| 解密   | 明文＝密文^ D mod N |

### 2.3  生成密钥对

既然公钥是（E，N），私钥是（D，N）所以密钥对即为（E，D，N）但密钥对是怎样生成的？步骤如下：

1. 求N
2. 求L（L为中间过程的中间数）
3. 求E
4. 求D

#### 2.3.1 求N

准备两个质数p，q。这两个数不能太小，太小则会容易破解，将p乘以q就是N

> ### N=p∗q

#### 2.3.2 求L

L 是 p－1 和 q－1的最小公倍数，可用如下表达式表示

> ### L=lcm（p－1，q－1）

#### 2.3.3 求E

E必须满足两个条件：E是一个比1大比L小的数，E和L的最大公约数为1
用gcd(X,Y)来表示X，Y的最大公约数则E条件如下：

> #### 1 < E < L
>
> #### gcd（E，L）=1

之所以需要E和L的最大公约数为1是为了保证一定存在解密时需要使用的数D。现在我们已经求出了E和N也就是说我们已经生成了密钥对中的公钥了。



#### 2.3.4 求D

数D是由数E计算出来的。D、E和L之间必须满足以下关系：

> #### 1 < D < L
>
> #### E＊D mod L ＝ 1

只要D满足上述2个条件，则通过E和N进行加密的密文就可以用D和N进行解密。
简单地说条件2是为了保证密文解密后的数据就是明文。

可以发现，D和E是对称的，可以选择一个作为公钥，另一个作为私钥，一般选择E和D之中较大的作为D。

可以简单的让E取2，3这种小质数，实际应用中常常选择65537。



现在私钥自然也已经生成了，密钥对也就自然生成了。
小结下：

|      |                                                         |
| ---- | ------------------------------------------------------- |
| 求N  | N＝ p ＊ q ；p，q为质数                                 |
| 求L  | L＝lcm（p－1，q－1） ；L为p－1、q－1的最小公倍数        |
| 求E  | 1 < E < L，gcd（E，L）=1；E，L最大公约数为1（E和L互质） |
| 求D  | 1 < D < L，E＊D mod L ＝ 1                              |

### 2.4 原理



##### 欧拉函数 

欧拉函数 φ(n)：在小于等于n的正整数之中，与n构成互质关系的个数。

显然：φ(1) = 1

如果n是质数， φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系

例如：φ(3) = 2， 包括1，2。

φ(8) = 4 ,  包括1,3,5,7, 而2，4，6与8有公约数2



#####  欧拉定理

如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：
$$
a^{\phi(n)}\equiv 1\ mod\ n
$$
欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。

##### ****

如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。
$$
ab\equiv 1\ mod\ n
$$
通过欧拉定理，可以按如下取值即可
$$
b = a^{\phi(n)-1}
$$
显然，a和b是对称的，一般期望a和b在1～n的范围内，在1～n范围a对应的b是唯一的。

实际计算中，模反元素不用这么麻烦的计算，解不定方程即可。
$$
ab-kn=1
$$
式子中只有b和k未知，通过欧几里德算法求解即可。



##### 综合过程

L是N的欧拉数。

D和E 是 基于L 的模反元素组。
$$
D*E \equiv 1 \ mod\ \phi(n)
$$

$$
(x^D)^E = x^{D*E}=x^{k\phi(n)+1}=x*x^{\phi(n)*k}
$$

$$
(x^D)^E\ mod\ N= x*(x^{\phi(n)})^k\ mod\ N=x\ mod\ N
$$



总结：RSA公钥/私钥生成算法流程如下。

1. 选择两个大质数，生成N
2. 计算N的欧拉数
3. 挑选一个质数作为公钥E，基于欧拉数计算对应的私钥D
4. 导出公钥数组(E,N), 私钥数组（D,N)



RSA算法难以破解建立以下几个结论之上。

1. 质因数分解很困难，而质因数乘法很容易。通过算法搜索质数，选择两个质数p,q， 做乘法得到N=pq，而别人很难分解N得到p，q。
2. 通过欧拉定理，可以计算模反元素。 通过挑选E，就可以计算D。没有欧拉数，就没法计算模反元素组。
3. 得到N，p，q，就可以计算 φ(N)=（p-1)(q-1)。质因数分解N很困难，进而难以计算欧拉数φ(N)。

第一条结论和第二条结论都比较强，但第三条结论稍弱。



## 3.  实例

我们用具体的数字来实践下RSA的密钥对对生成，及其加解密对全过程。为方便我们使用较小数字来模拟。

### 3.1 求N

我们准备两个很小对质数，
p ＝ 17
q ＝ 19
N ＝ p ＊ q ＝ 323

### 3.2 求L

L ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144
144为16和18对最小公倍数

### 3.3 求E

求E必须要满足2个条件：1 < E < L ，gcd（E，L）=1
即1 < E < 144，gcd（E，144） ＝ 1
E和144互为质数，5显然满足上述2个条件
故E ＝ 5

此时**公钥=(E，N）＝ （5，323）**

### 3.4 求D

求D也必须满足2个条件：1 < D < L，E＊D mod L ＝ 1
即1 < D < 144，5 ＊ D mod 144 ＝ 1
显然当D＝ 29 时满足上述两个条件
1 < 29 < 144
5＊29 mod 144 ＝ 145 mod 144 ＝ 1
此时**私钥＝（D，N）＝（29，323）**

### 3.5 加密

准备的明文必须时小于N的数，因为加密或者解密都要mod N，其结果必须小于N
假设明文 ＝ 123

密文＝明文^E mod N: 123^5 mod 323 =225 



### 3.6 解密

明文＝密文^D mod N:  225^29 mod 323 =123
解密后的明文为123。

## code

``` python
import random
_primer_list = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]

def genPrimer():    
    return _primer_list[5+random.random()]

def getEuler(p,q):
    return lcd(p-1,q-1)

def genInv(a, L):
    #  todo
    return 1

# 模反元素
def genRsa():
    p = genPrimer()
    q = genPrimer()
    N = p * q
    L = getEuler(p, q)
    E = genPrimer()
    D = genInv(E, L)
    return (E,N), (D, N)

def powerMod(x, p, N):
    return (x**p)%N

def encryptRsa(msg, public_key):
    (E, N) = public_key
    msg = powerMod(msg, E, N)
    return msg

def decryptRsa(msg, private_key):
    (D, N) = private_key
    msg = powerMod(msg, D, N)
    return msg

def main():
	public_key, private_key = genRsa()
    msg = 112
    enc_msg = encryptRsa(msg, public_key)
    dec_msg = encryptRsa(enc_msg, private_key)
    
```

