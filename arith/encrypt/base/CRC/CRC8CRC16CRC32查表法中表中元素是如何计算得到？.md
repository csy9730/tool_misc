# CRC8/CRC16/CRC32查表法中表中元素是如何计算得到？

``` cpp
const char CRC8Table[]={
0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65,
157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220,
35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98,
190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255,
70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7,
219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154,
101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36,
248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185,
140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205,
17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80,
175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238,
50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115,
202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139,
87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22,
233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168,
116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53
};
```



　　上面这个庞大的数组是根据，CRC8的多项式X^8+X^5+X^4+X^0 计算出来的，但该数组到底是如何被计算出来的？如果以后想换一个多项式时要怎么办？这就需要我们理解CRC表的计算原理了。

　　**以表的下标为0x01 作为示例来进行计算：**

　　首先需要明确CRC8常见的表格数据中是按照线传输LSB，并通过右移寄存器来判断的，因此每次要判断的就是寄存器的最低位LSB。同时要将多项式X^8+X^5+X^4+X^0 （也就是0x131(0011 0001)）按位颠倒后得到0x8c(1000 1100)，在计算过程

中做异或运算（为什么0x131中第一个1没有被颠倒？答：因为它是隐藏的）。

　　具体步骤如下：

　　1 选择范围0~255(包含255)范围内的数据，设为temp；

　　2 判断temp的最低位是否为1，如果为1，先将temp右移一位，然后将temp和多项式(0x8c)进行异或运算，结果保存在temp中。如果最低位为0，则将temp右移一位；

　　3 重复第二步，直到temp中的8位数据全部从右移出，然后进入4步；

　　4 此时temp的值就是CRC8校验值。

![img](https://img2020.cnblogs.com/blog/1704783/202008/1704783-20200812133936902-397419064.png)

　　通过以上推导，以表的下标为0x00，按步骤1/2/3/4 计算得出的CRC表格值为0，而表格中剩下其它下标元素对应CRC值都是一样的计算步骤。

## CRC16 校验算法

​    循环冗余码校验英文名称为Cyclical Redundancy Check，简称CRC。它是利用除法及余数的原理来作错误侦测（Error Detecting）的。实际应用时，发送装置计算出CRC值并随数据一同发送给接收装置，接收装置对收到的数据重新计算CRC并与

收到的CRC相比较，若两个CRC值不同，则说明数据通讯出现错误。

根据应用环境与习惯的不同，CRC又可分为以下几种标准：

　　①CRC-12码；

　　②CRC-16码；

　　③CRC-CCITT码；

　　④CRC-32码。

　　CRC-12码通常用来传送6-bit字符串。CRC-16及CRC-CCITT码则用是来传送8-bit字符，其中CRC-16为美国采用，而CRC-CCITT为欧洲国家所采用。CRC-32码大都被采用在一种称为Point-to-Point的同步传输中。

1、循环校验码（CRC码）：

　　是数据通信领域中最常用的一种差错校验码，其特征是信息字段和校验字段的长度可以任意选定。

2、生成CRC码的基本原理：

　　任意一个由二进制位串组成的代码都可以和一个系数仅为‘0’和‘1’取值的多项式一一对应。例如：代码1010111对应的多项式为x6+x4+x2+x+1，而多项式为x5+x3+x2+x+1对应的代码101111。

标准CRC生成多项式如下表：

| 名称        | 生成多项式              | 简记式   | 标准引用                                        |
| ----------- | ----------------------- | -------- | ----------------------------------------------- |
| CRC-4       | x4+x+1                  | 3        | ITU G.704                                       |
| CRC-8       | x8+x5+x4+1              | 0x31     |                                                 |
| CRC-8       | x8+x2+x1+1              | 0x07     |                                                 |
| CRC-8       | x8+x6+x4+x3+x2+x1       | 0x5E     |                                                 |
| CRC-12      | x12+x11+x3+x+1          | 80F      |                                                 |
| CRC-16      | x16+x15+x2+1            | 8005     | IBM SDLC                                        |
| CRC16-CCITT | x16+x12+x5+1            | 1021     | ISO HDLC, ITU X.25,，V.34/V.41/V.42, PPP-FCS    |
| CRC-32      | x32+x26+x23+...+x2+x+1  | 04C11DB7 | ZIP, RAR, IEEE 802 LAN/FDDI, IEEE 1394, PPP-FCS |
| CRC-32c     | x32+x28+x27+...+x8+x6+1 | 1EDC6F41 | SCTP                                            |

下面着重是CRC-16检验码的生成过程。

​    CRC-16码由两个字节构成，在开始时CRC寄存器的每一位都预置为1，然后把CRC寄存器与8-bit的数据进行异或，之后对CRC寄存器从高到低进行移位，在最高位（MSB）的位置补零，而最低位（LSB，移位后已经被移出CRC寄存器）如果为

1，则把寄存器与预定义的多项式码进行异或，否则如果 LSB为零，则无需进行异或。重复上述的由高至低的移位8次，第一个8-bit数据处理完毕，用此时CRC寄存器的值与下一个8-bit数据异或并进行如前一个数据似的8次移位。所有的字符处理完成

后CRC寄存器内的值即为最终的CRC值。

下面为CRC16的计算过程，其中生成多项式为:X16+X15+X2+1：

　　1．设置CRC寄存器，并给其赋值FFFF(hex)。

　　2．将数据的第一个8-bit字符与16位CRC寄存器的低8位进行异或，并把结果存入CRC寄存器。

　　3．CRC寄存器向右移一位，MSB补零，移出并检查LSB。

　　4．如果LSB为0，重复第三步；若LSB为1，CRC寄存器与生成多项式码相异或。

　　5．重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。

　　6．重复第2至第5步直到所有数据全部处理完成。

　　7．最终CRC寄存器的内容即为CRC值。

 

```cpp
const uint16 CRC_Table[256] = {
0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

/********************************************************************************************************
** 函数名称: CRCCode_Calibate(uint8 *Databuf,UINT16 UseDataSize);
** 功能描述: 计算报文CRC校验码
** 输　入: uint8 *Databuf:要校验的数组
uint16 UseDataSize:要校验的数组长度
** 输　出:
** 返 回: 返回16位CRC校验码
** 全局变量:
** 调用模块:
*********************************************************************************************************/
uint16 CRCCode_Calibate(uint8 *Databuf,uint16 UseDataSize)
{
uint16 i,X,CRC_Code,CRC;
CRC_Code=0xFFFF; //CRC 校验初始值为0xFFFF
for(i=0; i<UseDataSize; ++i)
{
X=CRC_Code^Databuf[i];
CRC_Code=(CRC_Code>>8)^CRC_Table[X&0x00FF];
}
CRC=((CRC_Code&0xFF)<<8)|((CRC_Code>>8)&0xFF);
return CRC;
}
```



 

转自：https://blog.csdn.net/u010464679/article/details/52637518?locationNum=8&fps=1

分类: [嵌入式软件](https://www.cnblogs.com/muyi23333/category/1831348.html)