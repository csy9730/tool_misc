# 最小二乘问题的四种解法——牛顿法，梯度下降法，高斯牛顿法和列文伯格-马夸特法的区别和联系

[yc zhang](https://www.zhihu.com/people/yc-zhang-12)

开开心心每一天



322 人赞同了该文章

在SLAM的过程中，我们可以构建机器人状态过程。通过对其概率的计算，最终将问题转化为了求最大似然估计的问题。

[yc zhang：贝叶斯理论在SLAM状态估计中的应用40 赞同 · 5 评论文章![img](https://pic2.zhimg.com/v2-4598679f31a03aa0bba252a74d054879_180x120.jpg)](https://zhuanlan.zhihu.com/p/113012522)

最终，可以将问题转换为求解最小二乘的问题。

那么如何求解最小二乘呢？本文将详细的介绍SLAM过程中求解最小二乘的方法。

**阅读指引：**

- 第1部分介绍**最小二乘**的基础流程；
- 第2部分介绍**牛顿法；**
- 第3部分介绍**梯度下降法；**
- 第4部分介绍**高斯牛顿法；**
- 第5部分介绍**列文伯格-马夸特法；**
- 第6部分介绍**几种方法的联系**。

如果觉得全文过长，可以直接定位到自己想要看的地方。书写不易，如果看完觉得对您有帮助的话，希望可以帮忙**点赞收藏**支持一下哈~

## 1、最小二乘

我们想要求解的问题是SLAM过程中的最大似然估计问题。由于最大似然估计问题可以转换为最小二乘问题，所以也就是最小二乘的求解问题。

我们假设目标函数为 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) ，误差函数为 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) ，则其最小二乘可以表示为[[1\]](https://zhuanlan.zhihu.com/p/113946848#ref_1)：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmin+F%28x%29+%3D+%5Cfrac%7B1%7D%7B2%7D%7C%7Cf%28x%29%7C%7C_2%5E2)

那么如何求解这个问题呢？

常规的思路就是对目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) 进行求导，当其导数为0的时候，求 ![[公式]](https://www.zhihu.com/equation?tex=x) 的最优解，最终求得极值，这里需要注意导数为0的点，不一定就是极值点，可能会是鞍点。

然而，有些时候，若目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) 的不是很容易进行求导，这个时候就需要使用一些迭代的方法，来使得目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) 下降，这样就可以逐步迭代，求得最小值了。整个的迭代流程如下所示：

![img](https://pic2.zhimg.com/80/v2-2fe5deb6b8eaca7375164f8b427a54c9_1440w.jpg)最小二乘问题的求解流程

因此，上诉问题，就变成了不断寻找下降增量 ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k) 的问题。

为了方便求解，我们只需要关心误差函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 在迭代值处的局部性质，而不用考虑 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) 在迭代值处的全局性质，这种方法在最优化，机器学习领域使用的非常广泛。

## 2、牛顿法

说到优化方法，那自然不能少了最基本的牛顿法。牛顿法在本科的时候大家应该都学过，这里进行一下回顾：

首先定义一个实变量 ![[公式]](https://www.zhihu.com/equation?tex=x) ，和其单变量函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) ，函数的一阶导数记为 ![[公式]](https://www.zhihu.com/equation?tex=f%5E%60%28x%29) ，二阶导数记为 ![[公式]](https://www.zhihu.com/equation?tex=f%5E%7B%60%60%7D%28x%29) [[2\]](https://zhuanlan.zhihu.com/p/113946848#ref_2)。

那么首先看一个牛顿法最常用的场景------求根：

### **2.1、一元函数求根：**

假设有根的近似解 ![[公式]](https://www.zhihu.com/equation?tex=x_0) ，则满足假设且更接近根的值为：

![[公式]](https://www.zhihu.com/equation?tex=x_1+%3D+x_0+-+%5Cfrac%7Bf%28x_0%29%7D+%7Bf%5E%60%7Bx_0%7D%7D)

以此类推，可以得到：

![[公式]](https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-++%5Cfrac+%7Bf%7B%28x_n%29%7D%7D%7Bf%5E%60_%7B%28x_n%29%7D%7D)

细节流程刻意参考下图：

![img](https://pic3.zhimg.com/v2-e908f9721cc82415fa7e70c763351f3a_b.jpg)

牛顿法求根的逼近过程

因此，根据上面的流程，可以逐步求得 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29+%3D+0) 的根。

我们假设当前的近似解为 ![[公式]](https://www.zhihu.com/equation?tex=x_n) ，那么迭代之后的下一个解，列出当前的切线方程为：

![[公式]](https://www.zhihu.com/equation?tex=y+%3D+f%5E%60%28x_n%29%28x-x_n%29+%2B+f%28x_n%29)

设定其在 ![[公式]](https://www.zhihu.com/equation?tex=x) 轴的截距为 ![[公式]](https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D) ，将 ![[公式]](https://www.zhihu.com/equation?tex=%28x_%7Bn%2B1%7D%2C0%29) 代入方程，可以得到： ![[公式]](https://www.zhihu.com/equation?tex=0+%3D+f%5E%60%28x_n%29%28x_%7Bn%2B1%7D-x_n%29+%2B+f%28x_n%29)

即： ![[公式]](https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-+%5Cfrac%7Bf%28x_n%29%7D%7Bf%5E%60%28x_n%29%7D)

因此，我们得到了在函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 上求解 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29+%3D+0) 的方法。

### **2.2、求函数的极值：**

我们在前面知道了求解函数的根的方法，那么和函数的极值有什么关系呢？我们知道函数的极值的必要条件是其一阶微分等于0。那么求解微分方程为0时候的值，从而函数的极值了。

为了能够方便理解整个流程，我们还是拿一元函数 ![[公式]](https://www.zhihu.com/equation?tex=f+%28x%29) 来举例。

我们首先对其在 ![[公式]](https://www.zhihu.com/equation?tex=x+%3D+x_0) 处进行二阶泰勒展开：

![[公式]](https://www.zhihu.com/equation?tex=f%28x%29+%3D+f%28x_0%29+%2B+f%5E%60%28x_0%29%28x-x_0%29+%2B+%5Cfrac%7Bf%5E%7B%60%60%7D%28x_0%29%7D%7B2%7D%28x-x_0%29%5E2+%2B+o%28x-x_0%29%5E2)

其中，由于泰勒展开的特性，后面 ![[公式]](https://www.zhihu.com/equation?tex=o%28x-x_0%29) 部分不予考虑，我们只考虑前面展开部分的极值问题：

![[公式]](https://www.zhihu.com/equation?tex=g%28x%29+%3D+f%28x_0%29+%2B+f%5E%60%28x_0%29%28x-x_0%29+%2B+%5Cfrac%7Bf%5E%7B%60%60%7D%28x_0%29%7D%7B2%7D%28x-x_0%29%5E2)

上面的式子是一个一元二次函数，那么其极值就是一阶导数为0的时候，我们可以先微分：

![[公式]](https://www.zhihu.com/equation?tex=+g%5E%60%28x%29+%3D+f%5E%60%28+x_0+%29+%2B+f%5E%7B%60%60%7D%28+x_0+%29%28x+-+x_0%29+)

令 ![[公式]](https://www.zhihu.com/equation?tex=g%5E%60%28x_1%29+%3D+0) ，则此时的 ![[公式]](https://www.zhihu.com/equation?tex=x_1) 就是极值（为了方便说明，暂不考虑鞍点的情况）。

故 ![[公式]](https://www.zhihu.com/equation?tex=f%5E%60%28x_0%29+%2B+f%5E%7B%60%60%7D%28x_0%29%28x_1-x_0%29+%3D+0)

![[公式]](https://www.zhihu.com/equation?tex=x_1+%3D+x_0+-+%5Cfrac%7Bf%5E%60%28x_0%29%7D%7Bf%5E%7B%60%60%7D%28x_0%29%7D)

以此类推，可以得到迭代公式：

![[公式]](https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-+%5Cfrac%7Bf%5E%60%28x_n%29%7D%7Bf%5E%7B%60%60%7D%28x_n%29%7D+%5Ctag+1)

根据这个方法就可以不断的迭代下去直到收敛，最终找到极值了。

如果是多元的情况，则一阶导数 ![[公式]](https://www.zhihu.com/equation?tex=f%5E%60%28x%29) 被叫做梯度，也称之为**雅可比矩阵** ![[公式]](https://www.zhihu.com/equation?tex=J) [[3\]](https://zhuanlan.zhihu.com/p/113946848#ref_3)（**这里不太严谨。严格来说，矩阵的梯度为一阶导的转置，函数的梯度为一阶导，这里并没有进行详细的区分**），二阶导数矩阵 ![[公式]](https://www.zhihu.com/equation?tex=f%5E%7B%60%60%7D%28x%29) ，也被叫做**海塞矩阵** ![[公式]](https://www.zhihu.com/equation?tex=H) [[4\]](https://zhuanlan.zhihu.com/p/113946848#ref_4)。如果是收敛的话， ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x+%3D+x_%7Bn%2B1%7D+-+x_n+%5Capprox+0) ，则式子可以转化为：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x+%3D+-++%5Cfrac%7Bf%5E%60%28x_n%29%7D%7Bf%5E%7B%60%60%7D%28x_n%29%7D+%3D+-+%5Cfrac%7BJ%7D%7BH%7D)

也就是说：

![[公式]](https://www.zhihu.com/equation?tex=+H%5CDelta+x+%3D+-J+%5Ctag2)

这样，就可以求出能够取得函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 的极值点，继而算出函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 的极值。

由于牛顿法需要算二阶导数，如果高阶的话，需要算海塞矩阵，这里是有三个**缺陷**：

- 要求给定的方程需要二阶可导
- 非凸函数的海森矩阵不一定有逆
- 数据较大的时候，海塞矩阵的计算量偏大

因此，需要思考别的方法来进行最小二乘问题的优化和求解。

## 3、梯度下降法

为了能够更好的进行最值问题的优化求解，我们可以使用**高斯牛顿法（GN）**和**列文伯格-马夸特法（LM）**。

再介绍上面两个方法之前，我们首先介绍一下**梯度下降法**[[5\]](https://zhuanlan.zhihu.com/p/113946848#ref_5)。

**梯度下降**是用于找到可微函数的局部最小值的一阶迭代优化算法。为了使用梯度下降找到函数的局部最小值，我们采取与该数在当前点的梯度（或近似梯度）的负值成比例的步骤。

![img](https://pic4.zhimg.com/80/v2-41641f20d0a7ca75a369e9451ab69f6b_1440w.jpg)梯度下降法示意图，来自wiki

梯度下降法是基于以下的观测原理而来的：

如果实值函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 在点 ![[公式]](https://www.zhihu.com/equation?tex=x+%3D+a) 处可微且有定义，那么函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 在点 ![[公式]](https://www.zhihu.com/equation?tex=a) 处，沿着梯度的反方向![[公式]](https://www.zhihu.com/equation?tex=-%5CDelta+f%28a%29) 下降的最快。

因此，假设有个点 ![[公式]](https://www.zhihu.com/equation?tex=b) ，满足：

![[公式]](https://www.zhihu.com/equation?tex=b+%3D+a+-+%5Cgamma+%5CDelta+f%28a%29+%5Cquad++s.t+%5Cquad+%5Cgamma+%3E+0+%5Cquad+%5C%26+%5Cquad+%5Cgamma+%5Cto+0)

那么我们就可以得到：

![[公式]](https://www.zhihu.com/equation?tex=f%28a%29+%5Cgeq+f%28b%29+)

通过这种方法，就可以找到极小值。

因此，得到迭代公式：

![[公式]](https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-+%5Cgamma+%5CDelta+f%28x_n%29+%5Ctag3)

其中， ![[公式]](https://www.zhihu.com/equation?tex=%5Cgamma) 是我们人为设定的参数，通过迭代，就可以得到极值。

梯度下降法每次都以梯度的反方向下降，所以，有可能会**容易走出锯齿路线，从而增加迭代次数**。

![img](https://pic4.zhimg.com/80/v2-9f3317ee73db262c8419c0f333dcd903_1440w.jpg)梯度下降法容易出现锯齿状，来自wiki

### 4、高斯牛顿法

如果代入到最小二乘问题中，牛顿法和梯度下降法都是针对目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F%28x_k%29) 来进行求解的，这样，就不可避免的需要求得海塞矩阵 ![[公式]](https://www.zhihu.com/equation?tex=H) ，所以，为了避免这个问题，我们选取了误差函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29)来进行优化求解：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmin+F%28x%29+%3D+%5Cfrac%7B1%7D%7B2%7D%7C%7Cf%28x%29%7C%7C_2%5E2)

那么，我们从上面的迭代步骤2中可以看到：

![img](https://pic4.zhimg.com/80/v2-464da939803a687b055a568091f0def7_1440w.jpg)最小二乘法求解流程

那么，我们对 ![[公式]](https://www.zhihu.com/equation?tex=f%28x+%2B+%5CDelta+x%29) 进行一阶泰勒展开。

![[公式]](https://www.zhihu.com/equation?tex=f%28x%2B%5CDelta+x%29+%5Capprox+f%28x%29+%2B+J%28x%29%5ET+%5CDelta+x+%2B+o%28%5CDelta+x%29)

我们需要求 ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x) 使得上面的式子 ![[公式]](https://www.zhihu.com/equation?tex=%7C%7Cf%28x+%2B+%5CDelta+x%29%7C%7C_2%5E2) 有最小值，所以，我们可以得到最小二乘问题为：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x%5E%2A+%3D+%5Carg+%5Cmin+%5Cfrac%7B1%7D%7B2%7D+%7C%7Cf%28x+%2B+%5CDelta+x%29%7C%7C_2%5E2+%5Capprox+%5Carg+%5Cmin+%5Cfrac%7B1%7D%7B2%7D+%7C%7Cf%28x%29+%2B+J%28x%29%5ET+%5CDelta+x%7C%7C_2%5E2)

为了求极值，对其求导：

![[公式]](https://www.zhihu.com/equation?tex=m%28x%29+%3D+%5Cfrac%7B1%7D%7B2%7D+%7C%7Cf%28x%29+%2B+J%28x%29%5ET+%5CDelta+x%7C%7C%5E2+%3D+%5Cfrac%7B1%7D%7B2%7D%28f%28x%29+%2B+J%28x%29%5ET+%5CDelta+x%29%5ET%28f%28x%29+%2B+J%28x%29%5ET+%5CDelta+x%29+)

![[公式]](https://www.zhihu.com/equation?tex=%3D+%5Cfrac%7B1%7D%7B2%7D+%28%7C%7Cf%28x%29%7C%7C%5E2+%2B+2f%28x%29J%28x%29%5ET%5CDelta+x+%2B+%5CDelta+x%5ETJ%28x%29J%28x%29%5ET%5CDelta+x)

故，对其求导可以得到：

![[公式]](https://www.zhihu.com/equation?tex=m%5E%60%28x%29+%3D++J%28x%29f%28x%29+%2B+J%28x%29J%28x%29%5ET%5CDelta+x)

则，此时可以转化为线性求解问题：

![[公式]](https://www.zhihu.com/equation?tex=m%5E%60%28x%29+%3D+0+%5Cquad+%5Crightarrow+%5Cquad+J%28x%29J%28x%29%5ET%5CDelta+x+%3D+-+J%28x%29f%28x%29)

令![[公式]](https://www.zhihu.com/equation?tex=J%28x%29J%28x%29%5ET)定义为 ![[公式]](https://www.zhihu.com/equation?tex=H%28x%29) ，令 ![[公式]](https://www.zhihu.com/equation?tex=-+J%28x%29f%28x%29) 定义为 ![[公式]](https://www.zhihu.com/equation?tex=g%28x%29) ，则此时变为了：

![[公式]](https://www.zhihu.com/equation?tex=H%5CDelta+x+%3D+g+%5Cquad+s.t+%5Cquad++H+%3D+JJ%5ET+%5Cquad+%5C%26+%5Cquad+g+%3D+-Jf+%5Ctag+4)

这样，就可以优化求解了。上面的最小二乘的优化步骤就可以变为[[6\]](https://zhuanlan.zhihu.com/p/113946848#ref_6)：

![img](https://pic4.zhimg.com/80/v2-3931dad56dda6ce0cb7a196d6f675a67_1440w.jpg)高斯牛顿法求解最小二乘的步骤

相比较于传统的最小二乘求解方法，只更改了两个步骤。该方法的优点和缺点如下：

**优点**：

- 避免了求海塞矩阵，大大减少了计算量。

**缺点**：

- 为了求解 ![[公式]](https://www.zhihu.com/equation?tex=H%5E-) ，需要 ![[公式]](https://www.zhihu.com/equation?tex=H) 矩阵可逆，但是实际上 ![[公式]](https://www.zhihu.com/equation?tex=JJ%5ET) 只有半正定性，所以，当为奇异矩阵的时候，稳定性较差，算法不收敛。
- 如果求出来的步长 ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k) 太大，会导致其局部近似不精确，严重的时候，可能无法保证迭代收敛。
- 容易和梯度下降法一样，陷入锯齿状，导致迭代次数较长。

不过，为了能够更好的进行最小二乘问题的求解，我们可以使用**列文伯格-马夸特法**(LM)来进行求解。

## 5、列文伯格-马夸特法

该方法是在高斯牛顿法的基础上进行的改进，基本的思路和原理和高斯牛顿法一样。

在高斯牛顿法的缺点中，可以看到，有一点使容易进入锯齿状，导致迭代的次数较长。所以，为了避免其步长过大导致的问题，该方法提出了**信赖区域**，设定一个区域。使得步长能够受到控制[[7\]](https://zhuanlan.zhihu.com/p/113946848#ref_7)。

在更新迭代的过程中，为了判定近似值的好坏，我们设定了一个评判指标：

![[公式]](https://www.zhihu.com/equation?tex=%5Crho+%3D+%5Cfrac%7Bf%28x%2B%5CDelta+x%29+-+f%28x%29%7D%7BJ%28x%29%5ET%5CDelta+x%7D)

这个指标就是我们的近似指标，可以看到其分为以下几种情况：

- ![[公式]](https://www.zhihu.com/equation?tex=%5Crho) 接近1，近似是好的，不需要更改；
- ![[公式]](https://www.zhihu.com/equation?tex=%5Crho) 太小，则实际减少的值小于近似减少的值，近似较大，需要缩小近似的范围；
- ![[公式]](https://www.zhihu.com/equation?tex=%5Crho) 太大，则实际减少的值大于近似减少的值，近似较小，需要扩大近似的范围。

这样的话，就可以动态调整步长了。

通过近似指标，我们可以设定信赖区域的大小。当没有接近我们设定的阈值，则不断调整动态区域，直到找到好的近似结果。

当找到符合要求的近似结果后，就可以进行后续正常的迭代更新了。

因此，使用该信赖区域后，可以更新算法流程：

![img](https://pic1.zhimg.com/80/v2-648839ea567516366e55f8459436fdf0_1440w.jpg)Levenberg–Marquardt 求解最小二乘问题的算法流程

至于增量方程的获取，可以通过拉格朗日函数来求解：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmin+%5Cfrac+%7B1%7D%7B2%7D%7C%7Cf%28x%29+%2B+J%28x%29%5ET+%5CDelta+x%7C%7C++%5Cquad+s.t+%5Cquad+%7C%7CD+%5CDelta+x+%3C+%5Cmu%7C%7C_2)

构建拉格朗日函数， ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) 是系数因子：

![[公式]](https://www.zhihu.com/equation?tex=L%28%5CDelta+x%2C%5Clambda%29+%3D+%5Cfrac+%7B1%7D%7B2%7D%7C%7Cf%28x%29+%2B+J%28x%29%5ET%5CDelta+x%7C%7C%5E2+%2B+%5Cfrac+%7B%5Clambda%7D%7B2%7D%28%7C%7CD+%5CDelta+x%7C%7C%5E2+-+%5Cmu%29)

这样的话，化简后求导就可以得到：

![[公式]](https://www.zhihu.com/equation?tex=J%28x%29f%28x%29+%2B+J%28x%29J%5ET%28x%29%5CDelta+x+%2B+%5Clambda+D%5ETD+%5CDelta+x+%3D+0)

我们化简后得到：

![[公式]](https://www.zhihu.com/equation?tex=%28JJ%5ET+%2B+%5Clambda+D%5ETD%29+%5CDelta+x+%3D+-Jf)

在本文中，我们令 ![[公式]](https://www.zhihu.com/equation?tex=H+%3D+JJ%5ET%EF%BC%8Cg+%3D+-Jf) 。在实际使用中，通常用 ![[公式]](https://www.zhihu.com/equation?tex=I) 来代替 ![[公式]](https://www.zhihu.com/equation?tex=D%5ETD) 。所以，公式就变为：

![[公式]](https://www.zhihu.com/equation?tex=%28H+%2B+%5Clambda+I%29+%5CDelta+x_k+%3D+g+%5Ctag+5)

这样，就可以得到对应的增量方程了。

代入算法流程中，最终就可以优化得到最小二乘问题的极小值了。

## 6、几种方法的联系

我们已经知晓了四种优化的方法，分别是：

- 牛顿法： ![[公式]](https://www.zhihu.com/equation?tex=+H%5CDelta+x+%3D+-J+%5Cquad+s.t+%5Cquad+H+%3D+f%5E%7B%60%60%7D%28x_k%29%2C+J+%3D+f%5E%60%28x_k%29)
- 梯度下降法： ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x++%3D+-+%5Cgamma+J+%5Cquad+s.t+%5Cquad+J+%3D++f%5E%60%28x_k%29)
- 高斯牛顿法： ![[公式]](https://www.zhihu.com/equation?tex=H%5CDelta+x+%3D+g+%5Cquad+s.t+%5Cquad++H+%3D+JJ%5ET+%EF%BC%8C+g+%3D+-Jf)
- 列文伯格-马夸特法： ![[公式]](https://www.zhihu.com/equation?tex=%28H+%2B+%5Clambda+I%29+%5CDelta+x_k+%3D+g+%5Cquad+s.t+%5Cquad++H+%3D+JJ%5ET+%EF%BC%8C+g+%3D+-Jf)

其实，这四种方法在最小二乘的问题求解中，也是有着联系的。

我们设定最小二乘问题为：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmin+F%28x%29+%3D+%5Cfrac%7B1%7D%7B2%7D%7C%7Cf%28x%29%7C%7C_2%5E2)

根据针对求解的是目标函数还是误差函数，可以将问题进行分类：

### 6.1 针对目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) 优化

对于目标函数![[公式]](https://www.zhihu.com/equation?tex=F+%28x%29+) 进行一阶泰勒展开：

![[公式]](https://www.zhihu.com/equation?tex=F%28x_k+%2B+%5CDelta+x_k%29+%5Capprox+F%28x_k%29+%2B+J%28x_k%29%5ET+%5CDelta+x_k)

此时，此时变成求最小值的问题，则：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k+%5E%2A+%3D+%5Carg+%5Cmin+%28F%28x_k%29+%2B+J%28x_k%29%5ET+%5CDelta+x_k%29)

故，对其求最小值，可以进行求一阶导数为0：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k+%3D+-+J%28x_k%29%5ET)

可以看到，如果增加一个步长 ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) ， 此时的方法就是**梯度下降法**。

如果对目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F+%28x%29+) 其进行二阶泰勒展开：

![[公式]](https://www.zhihu.com/equation?tex=F%28x_k+%2B+%5CDelta+x_k%29+%5Capprox+F%28x_k%29+%2B+J%28x_k%29%5ET+%5CDelta+x_k+%2B+%5Cfrac%7B1%7D%7B2%7D%5CDelta+x_k%5ET+H%28x_k%29%5CDelta+x_k)

则，此时的增量方程为最小二乘问题：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k%5E%2A+%3D+%5Carg+%5Cmin%28F%28x_k%29+%2B+J%28x_k%29%5ET+%5CDelta+x_k+%2B+%5Cfrac%7B1%7D%7B2%7D%5CDelta+x_k%5ET+H%28x_k%29%5CDelta+x_k%29)

则，为了求其最小值，对 ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k%5E%2A) 进行求导：

![[公式]](https://www.zhihu.com/equation?tex=J%28x_k%29+%2B+H%28x_k%29+%5CDelta+x_k+%3D+0+%5Crightarrow+H%2A%5CDelta+x+%3D+-J)

则此时的方法为**牛顿法**。

所以，如果从目标函数 ![[公式]](https://www.zhihu.com/equation?tex=F%28x%29) 入手的话，梯度下降法和牛顿法就是其一阶泰勒展开和二阶泰勒展开的求解方法。

### 6.2 针对误差函数 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%29) 优化

上面正文部分的4和5，就是对误差函数的优化，可以得到两种方法：高斯牛顿法和列文伯格-马夸特法。

其中，列文伯格-马夸特法是在高斯牛顿法的基础上得来的。他们之间的联系，主要取决于参数 ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) ：

- ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) 较大的时候，公式变为： ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda+I+%5CDelta+x_k+%3D+g) ，此时为**梯度下降法**
- ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) 较小的时候，公式变为： ![[公式]](https://www.zhihu.com/equation?tex=H%5CDelta+x_k+%3D+g) ， 此时为**高斯牛顿法**。

所以， ![[公式]](https://www.zhihu.com/equation?tex=LM) 法可以在一定程度上避免线性方程组的系数矩阵的非奇异和病态的问题，从而得到更精准，更稳定的增量 ![[公式]](https://www.zhihu.com/equation?tex=%5CDelta+x_k) 。

通过上面内容，我们知道了牛顿法，梯度下降法，高斯牛顿法和列文伯格-马夸特法的区别和联系了。

不管是什么方法，**初始参数的选取**很重要，给一个好的参数，可以减少迭代次数，更快的收敛，从而减少很多的计算量。

在实际的使用中，可以根据具体的情况来最终决定，到底要使用那种方法来进行优化求解。

## 参考

1. [^](https://zhuanlan.zhihu.com/p/113946848#ref_1_0)<https://en.wikipedia.org/wiki/Least_squares>
2. [^](https://zhuanlan.zhihu.com/p/113946848#ref_2_0)[https://en.wikipedia.org/wiki/Newton%27s_method](https://en.wikipedia.org/wiki/Newton's_method)
3. [^](https://zhuanlan.zhihu.com/p/113946848#ref_3_0)<https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant>
4. [^](https://zhuanlan.zhihu.com/p/113946848#ref_4_0)<https://en.wikipedia.org/wiki/Hessian_matrix>
5. [^](https://zhuanlan.zhihu.com/p/113946848#ref_5_0)<https://en.wikipedia.org/wiki/Gradient_descent>
6. [^](https://zhuanlan.zhihu.com/p/113946848#ref_6_0)<https://github.com/gaoxiang12/slambook2>
7. [^](https://zhuanlan.zhihu.com/p/113946848#ref_7_0)[https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm](https://en.wikipedia.org/wiki/Levenberg–Marquardt_algorithm)

编辑于 2020-04-23 21:43

视觉SLAM十四讲（书籍）

同时定位和地图构建（SLAM）

最小二乘法

赞同 322

31 条评论

分享