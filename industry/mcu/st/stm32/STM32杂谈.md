# STM32杂谈

### SRAM



SRAM（Static Random-Access Memory）即静态随机存取存储器，所谓“静态”是指这种存储器只要保持通电，里面存储的数据就可以一直保持，但是掉电之后就会丢失。与DRAM（动态随机存取存储器）相比它不需要周期性的刷新里面的数据，操作简单，速度更快，但是更加的昂贵，集成度不如DRAM高。



本文使用的SRAM型号为 IS62WV51216，是 ISSI（Integrated Silicon Solution, Inc）公司生产的一颗16位宽 1M字节容量的CMOS静态内存芯片。



#### STM32F103系列的FSMC模块
FSMC（Flexible Static Memory Controller）即可变静态存储控制器，通俗的来说是STM32的一个强大的总线控制模块，它将AHB传输信号转换到适当的外部设备协议，满足访问外部设备的时序要求。FSMC将不同的功能映射到了不同的虚拟内存块上，我们实际编程中只需要简单地往特定的虚拟内存上读写数据，便可以实现对外部模块的数据读写操作了，中间的协议操作过程由FSMC模块完成。FSMC模块涉及引脚非常的多，所以只在STM32的大容量产品上才有，我使用的型号是STM32F103ZET6。



STM32F407系列芯片使用FSMC外设来管理扩展的存储器

> FSMC是Flexible StaticMemory Controller的缩写，就是灵活的静态存储控制器。它可以用于驱动包括SRAM、NOR FLASH以及NAND FLSAH类型的存储器

其他我们不用管，从上面我们可以总结的是，stm32雇佣FSMC这个管家来管理我们的IS62WV51216。



### stm32

片内Flash ROM与片内RAM，RAM相当于内存，Flash ROM相当于硬盘。



①code:代码段，存放程序的所有代码

②RO：只读数据段，存放程序中定义的**常量**

③RW：读写数据段，存放初始化为**非0值的全局变量**

④ZI：零数据段，存放**未初始化的全局变量**，以及**初始化为0的变量**。



user FLASH=Code + RO-data + RW-data =(14588+428+32)/1024=14.70KB

RAM=RW-data + ZI-data =32+20264=20.296KB

System Flash= 2KB？



STM32在上电后，默认从flash启动，之后将RW段中的RW-data（初始化不为零的全局变量）搬运到RAM中，（因为自身定义的值不能改变）但不会搬运RO-data段，（因为都是初始化为0或者没赋值，不需要管它的值是多少）

#### 4

RAM中的数据不是在烧录的时候写入的，同时也说明，在CPU运行时，RAM中已经写入了数据。关键就在这里：这个数据不是人为写入的，CPU写入的，那CPU又是什么时候写入的呢？

这里所做的工作是为整个程序的顺利运行做好准备，或者说是对RAM的初始化（注：ROM是只读不写的），工作任务有几项：
1、为全局变量分配地址空间---如果全局变量已赋初值，则将初始值从ROM中拷贝到RAM中，如果没有赋初值，则这个全局变量所对应的地址下的初值为0或者是不确定的。当然，如果已经指定了变量的地址空间，则直接定位到对应的地址就行，那么这里分配地址及定位地址的任务由“连接器”完成。
2、设置堆栈段的长度及地址---用C语言开发的单片机程序里面，普遍都没有涉及到堆栈段长度的设置，但这不意味着不用设置。堆栈段主要是用来在中断处理时起“保存现场”及“现场还原”的作用，其重要性不言而喻。而这么重要的内容，也包含在了编译器预设的内容里面，确实省事，可并不一定省心。
3、分配数据段data，常量段const，代码段code的起始地址。代码段与常量段的地址可以不管，它们都是固定在ROM里面的，无论它们怎么排列，都不会对程序产生影响。但是数据段的地址就必须得关心。数据段的数据时要从ROM拷贝到RAM中去的，而在RAM中，既有数据段data,也有堆栈段stack，还有通用的工作寄存器组。通常，工作寄存器组的地址是固定的，这就要求在绝对定址数据段时，不能使数据段覆盖所有的工作寄存器组的地址。必须引起严重关注。  

 通常的做法是：普通的flashMCU是在上电时或复位时，c指针里面的存放的是“0000”，表示CPU从ROM的0000地址开始执行指令，在该地址处放一条跳转指令，使程序跳转到_main函数中，然后根据不同的指令，一条一条的执行，当中断发生时（中断数量也很有限，2~5个中断），按照系统分配的中断向量表地址，在中断向量里面，放置一条跳转到中断服务程序的指令，如此如此，整个程序就跑起来了。决定CPU这样做，是这种ROM结构所造成的。



。

#### startup.asm

startup.asm文件中的代码（类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的）通通都存储在ROM中。



startup_stm32fxxx.s文件是系统的启动文件，startup_stm32fxxx.s主要完成三个工作：栈和堆的初始化、定位中断向量表、调用Reset Handler。

#### **地址映射**



在《ARM Cotrex-M3权威指南》中有关 M3的存储器映射表：

![img](https://pic1.zhimg.com/80/v2-393747cf712128c5ea46940b7d8c8d20_720w.webp)

存储器映射 是用 地址来表示 对象，因为Cortex-M3是32位的单片机，因此其PC指针可以指向2^32=4G的地址空间，也就是图中的 0x00000000到0xFFFFFFFF的区间，也就是将程序存储器、数据存储器、寄存器和输入输出端口被组织在同一个4GB的线性地址空间内，数据字节以小端格式存放在存储器中。

#### **STM32的启动模式

**STM32的启动模式介绍** 从STM32参考手册上，可以查阅到，STM32的启动模式，共有下列三种，可以通过BOOT0和BOOT1电平的不同组合，来选择不同的启动模式。

![img](https://pic4.zhimg.com/80/v2-877f5f8f9b8a4e4bba29174523073c93_720w.webp)

**主闪存启动模式**：即运行模式，单片机上电即运行程序。

启动地址：0x08000000 是STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。基本上都是采用这种模式。

**系统存储器启动模式**：即串口下载模式。上电之前要先设置BOOT0=1，BOOT1=0，然后才能通过串口下载程序。或者在已经上电的情况下，设置BOOT0=1，BOOT1=0，然后按一下复位键，这样也能通过串口下载程序。

**SRAM启动模式**：即调试模式。假如只修改了代码中一个小小的地方，如果直接擦除整个Flash，比较费时，而且Flash的擦写次数也是有限制的。所以可以考虑从RAM中启动代码，用于快速的程序调试，等程序调试完成后，再将程序下载到Flash中。

启动地址：0x20000000 内置SRAM，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。假如我只修改了代码中一个小小的 地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码（也就是STM32的内存中），用于快速的程序调试，等程序调试完成后，在将程序下载到SRAM中。



有的朋友肯定遇到过这种情况：程序第一次下载的时候可以运行，但是掉电重启之后，程序就不能运行了。**这种情况就有可能是把BOOT设置成了串口下载模式**，所以掉电之后，并不会自动运行。如果想要即使掉电重启也能直接运行程序，可以把BOOT设置为主闪存启动模式，即BOOT0=0。



第二种方式(boot0 = 1；boot1 = 0)：System memory启动方式
启动地址：0x1FFF0000从系统存储器启动，这种模式启动的程序功能是由厂家设置的。一般来说，这种启动方式用的比较少。系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader， 也就是我们常说的ISP程序， 这是一块ROM，出厂后无法修改。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的BootLoader 中，提供了串口下载程序的固件，可以通过这个BootLoader将程序下载到系统的Flash中。



#### 关于启动地址
理论上，CM3中规定上电后CPU是从0地址开始执行，但是这里中断向量表却被烧写在0x0800 0000地址里(Flash memory启动方式)，那启动时不就找不到中断向量表了？既然CM3定下的规矩是从0地址启动，SMT32当然不能破坏ARM定下的“规矩”，所以它做了一个启动映射的过程，就是和芯片上总能见到的BOOT0和BOOT1有关了，当选择从主Flash启动模式后，芯片一上电，Flash的0x0800 0000地址被映射到0地址处，不影响CM3内核的读取，所以这时的CM3既可以在0地址处访问中断向量表，也可以在0x0800 0000地址处访问中断向量表，而代码还是在0x0800 0000地址处存储的。

#### SWD

SWD是Serial Wire Debug的简称，翻译成中文是”串行线调试”。 SWD是ARM目前支持的两种调试端口之一，另一个调试端口叫做JTAG Debug Port，也就是我们常用的J-link上面的调试端口（JTAG模式下）。基于ARM CoreSight调试构架，SWD可以通过传输数据包来读写芯片的寄存器。SWD是用于访问ARM调试接口的双线协议。它是ARM调试接口规范(ARM Debug Interface Architecture Specification)的一部分，是JTAG的替代品。SWD的物理层由两条线组成：

SWDIO: 双向数据线

SWCLK: host驱动的时钟线



#### Iap

Iap,全名为in applacation programming,即在应用编程,与之相对应的叫做isp,in system programming,在系统编程,两者的不同是isp需要依靠烧写器在单片机复位离线的情况下编程,需要人工的干预,而iap则是用户自己的程序在运行过程中对User Flash 的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口对产品中的固件程序进行更新升级。在工程应用中经常会出现我们的产品被安装在某个特定的机械结构中,更新程序的时候拆机很不方便,使用iap技术能很好地降低工作量.

#### OTA

OTA是Over-the-Air的简写，即空中下载技术，通过网络远程给用户进行系统更新和升级。IAP是In Application Programming的简写，IAP是用户自己的程序在运行过程中对User Flash的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口对产品中的固件程序进行更新升级。IAP主要包括BootLoader和应用程序两部分，基于IAP的OTA设计思路是先通过OTA接收升级固件，再利用IAP进行固件搬移、校验和程序跳转，实现空中升级的目的。

BootLoader程序根据判断是否需要升级固件，并进行运行代码跳转。APP工程中需要编写OTA数据包交互协议，将接收到的升级固件保存至FLASH，校验一致性然后设置升级标志位并重启。





而且随着汽车行业已进入软件定义汽车的时代，对售后汽车售卖各种各样功能的新商业模式兴起，也要求汽车必须具备OTA功能。这里准确地说，OTA分为两类，一类是**固件在线升级FOTA**（Firmware-Over-the-Air），是指不改变车辆原有配件的前提下，通过写入新的固件程序，使拥有联网功能的设备进行升级，包括车辆的发动机，电机，变速箱，底盘等控制系统，比如特斯拉曾通过FOTA新增过自动驾驶功能、增加过电池容量和改善过刹车距离等。另一类是**软件在线升级SOTA**（Software-Over-the-Air），是在操作系统的基础上对应用程序进行升级，是指那些离用户更近的应用程序，UI界面和车载地图、人机交互界面等功能，像娱乐系统更新操作界面或主题。