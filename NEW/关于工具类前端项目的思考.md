# 关于工具类前端项目的思考

工具类前端项目类项目应该是指基于浏览器/框架开发的工具
编译器，是指本地端工具
office 是本地端带界面，含有前端和后端部分。
IDE 是本地端带界面，含有前端和后端部分。

前端项目类，一般侧重于网页，依托于浏览器，具有较高的抽象级别，缺点是底层能力不足。
纯前端工具类，不具有本地能力（无需考虑本地性能），可以视为普通的前端项目。
前端工具复合类型，不完全依托浏览器，要管理本地端的功能（绕开浏览器直接操作底层获得更好的性能），。


### VSCode难度

WebIDE的后端的难度和许多其他产品的后端一样主要是建立在尺度上的（比如你要服务GitHub规
模的群体还要高可用），你如果没有上规模很多问题就不存在，说句难听的，要是只是内部自己用
用，派两个CRUD码农说不定也能给你堆出来。就算上规模，和其他大规模高可用应用的后端还是
基本相通的，绝大部分经验（包括安全性之类的）是可以互通的。
而WebIDE的前端的难度，是横跨多个领域知识的，随便拿出来一个领域知识都够你学上好几年。
比如国际化本地化和多语言支持。不要说跟后端没有共通性，跟其他前端也可能没啥共通性。（不
同端项目的领域知识的差别还随手找了个这个例子：zhihu.com/question/2759...。这个其实还容
易理解，我还见过一些更特别的前端项目如果你不懂该项目的领域知识你几乎根本看不懂。当然后
端项目也会有类似的情况，不过前端出现多领域交叉的几率更高。）
以本地化举例，就算VSCode这么逆天的牛逼项目，就算是在中文这么这么重要的语言（而不是蒙
文藏文之类的小众语言），随便就可以找个本地化bug出来给你，我昨天刚刚在群里抱怨的：
MacOS下搜狗输入法 、鼠须管等用capslock切换到英文，在VSCode的terminal窗口里会变成全
大写，导致基本无法使用。
现在咱们评估一下，这个bug要多久能修好？
……
……
……
实际上很可能根本评估不出来，甚至是不是VSCode的bug（还是说这是输入法本身的bug？比方
说MacOS自带的拼音输入法也用capslock切换就没有这个问题）都不好断言，除非你已经有足够
的Mac下输入法领域知识……但是这它喵的是前端的技能范畴？
还别说，说到输入法有关的bug，我突然想起十几年之前我在老IE上就发现过一个和输入法相关的
奇葩bug：iteye.com/topic/191555?... 。但是我这经验对于现在也并没有什么卵用。
我们一直说技术变化快，这么多年以来，后端的核心知识还是有很大的延续性的。前端不能说没有
延续性，但前端相比后端有很多类似我前面说的这类的跨领域且结合非受控环境产生的琐碎问题。
前端的非受控环境远超后端，从某种角度说和终端硬件产品类似。前端本来有个超大优点是（无论
入法级别，也可能是操作系统级别，或者是多个级别的综合作用）。而像WebIDE这类项目甚至可
能需要经常主动打破通常前端所依赖的抽象层，这下大优势一下就变成了大劣势（因为高抽象的反
面就是无论编程语言还是API都缺乏底层控制能力）。
我讲的这些，还是我作为一个敬畏WebIDE之难的门外汉管窥所知，你要去问真搞的人（比如吕鹏
大大），估计给你讲各种奇葩血泪史三天不带重样的。


首先关于软件架构，我们知道有一个 “康威定律”（Conway's law）Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.设计系统的架构受制于产生这些设计的组织的沟通结构。

作者：何幻
链接：https://www.zhihu.com/question/397643817/answer/1253111861
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：何幻
链接：https://www.zhihu.com/question/397643817/answer/1253111861
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

说白了，团队有几个人，软件系统就倾向于被拆分为几个部分。因为事情终究还是会落实到人手上来的，与其争论互相影响，倒不如独立解耦更好。因此好的架构，往往能更准确的界定子系统的边界，使得，各子系统之间的沟通成本最小（少了很多扯皮甩锅的事情）。如何让软件开发显得忙碌起来呢，那就是多拆系统和模块，让每个人维护好多模块，且相互影响。先有人后有问题其次，我们是什么样的人，就会遇到什么样的问题，而不是反之。这可能跟时下流行的观点不太一致。通常人们会觉得，是先有一个问题然后再想办法去解决它，怎么可能会反着来？这是因为有人先识别出了这个问题，在自己的能力范围之内，后来才有了找人解决问题这件事。再回想一下，我们平时开发过程中解决过哪些问题？几乎都是与我们工作经验有交集的，那种努把力就能解决的问题。那些我们完全摸不到头脑的，要么根本意识不到这是个问题，一般早早得就放弃了。所以，有什么样的人，就会识别到什么样的问题，有什么样的团队，他们擅长什么，当前就正忙着做什么。开发复杂度软件复杂度有很多种说法，有很多种不同的评定方式。关于软件系统本身的复杂度，例如依赖复杂度，或者关于要解决的那个问题的复杂度，比如业务场景的复杂度，这些复杂度，很多前辈都说得很多了，我觉得他们说的很有道理。只是，另外还有一个难以被注意到的复杂度 —— 软件工作的复杂度。指的是，开发过程比较麻烦，难以理清头绪，或者信息量比较大，开发效率很低。这种复杂度的形成是由多种因素造成的，但主要还是人为因素。不合理的系统划分，或者不合理的分工安排，代码的历史债务比较多，等等，都有可能增加软件工作的复杂度。从这种意义上来看，打个不恰当的比喻，一个由 10 人组成的前端团队，他们的开发工作，并不比 3 人后端团队的开发工作简单。因为每个人都可能互相制约，并且需要频繁沟通。结语总之，有很多言论是从软件开发待解决的问题角度，来讨论开发复杂度的，也有一些言论，是从用来开发软件的工具角度来讨论，我觉得从这些角度理解，完全没有问题。但有一个盲区，即从软件开发工作的角度评判复杂度。正因为这样，《人月神话》中才会提到理想化的 “外科手术团队”，意图最大限度的减少开发（沟通）难度。最后，我认为技术本没有贵贱，无非是武器不同，作战方式不同，敌人不同罢了。