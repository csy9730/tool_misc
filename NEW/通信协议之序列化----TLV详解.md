# 通信协议之序列化----TLV详解



通信协议可以理解两个节点之间为了协同工作实现信息交换，协商一定的规则和约定，例如规定字节序，各个字段类型，使用什么压缩算法或加密算法等。常见的有tcp，udo，http，sip等常见协议。协议有流程规范和编码规范。流程如呼叫流程等信令流程，编码规范规定所有信令和数据如何打包/解包。
编码规范就是我们通常所说的编解码，序列化。不光是用在通信工作上，在存储工作上我们也经常用到。如我们经常想把内存中对象存放到磁盘上，就需要对对象进行数据序列化工作。
本文采用先循序渐进，先举一个例子，然后不断提出问题-解决完善，这样一个迭代进化的方式，介绍一个协议逐步进化和完善，最后总结。看完之后，大家以后在工作就很容易制定和选择自己的编码协议。
一、**紧凑模式**
本文例子是A和B通信，获取或设置基本资料，一般开发人员第一步就是定义一个协议结构:

```cpp
struct userbase
{
unsigned short cmd;//1-get, 2-set, 定义一个short，为了扩展更多命令(理想那么丰满)
unsigned char gender; //1 – man , 2-woman, 3 - ??
char name[8]; //当然这里可以定义为 string name；或len + value 组合，为了叙述方便，就使用简单定长数据
}
```

在这种方式下，A基本不用编码，直接从内存copy出来，再把cmd做一下网络字节序变换，发送给B。B也能解析，一切都很和谐愉快。
这时候编码结果可以用图表示为(1格一个字节)



![img](https://upload-images.jianshu.io/upload_images/44290-4877835edf76afb2.gif?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp)



这种编码方式，我称之为

紧凑模式

，意思是除了数据本身外，没有一点额外冗余信息，可以看成是Raw Data。在dos年代，这种使用方式非常普遍，那时候可是内存和网络都是按K计算，cpu还没有到1G。如果添加额外信息，不光耗费捉襟见肘的cpu，连内存和带宽都伤不起。

二、

可扩展性

有一天，A在基本资料里面加一个生日字段，然后告诉B



```cpp
struct userbase
{
unsigned short cmd;
unsigned char gender;
unsigned int birthday;
char name[8];
}
```

这是B就犯愁了，收到A的数据包，不知道第3个字段到底是旧协议中的name字段，还是新协议中birthday。这是后A，和B终于从教训中认识到一个协议重要特性——**兼容性和可扩展性**。
于是乎，A和B决定废掉旧的协议，从新开始，制定一个以后每个版本兼容的协议。方法很简单，就是加一个version字段。

```cpp
struct userbase
{
unsigned short version;
unsigned short cmd;
unsigned char gender;
unsigned int birthday;
char name[8];
}
```

这样，A和B就松一口气，以后就可以很方便的扩展。增加字段也很方便。这种方法即使在现在，应该还有不少人使用。
二、**更好的可扩展性**
过了一段较长时间，A和B发现又有新的问题，就是没增加一个字段就改变一下版本号，这还不是重点，重点是这样代码维护起来相当麻烦，每个版本一个case分支，到了最好，代码里面case 几十个分支，看起来丑陋而且维护起来成本高。
A 和 B仔细思考了一下，觉得光靠一个version维护整个协议，不够细，于是觉得为每个字段**增加一个额外信息——tag,虽然增加内存和带宽，但是现在已经不像当年那样，可以容许这些冗余，换取易用性**。

```cpp
struct userbase
{
unsigned short version;
unsigned short cmd;
unsigned char gender;
unsigned int birthday;
char name[8];
}
```





![img](https://upload-images.jianshu.io/upload_images/44290-6023e27f6d2229a8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)



制定完这些协议后，A和B很得意，觉得这个协议不错，可以自由的增加和减少字段。随便扩展。

现实总是很残酷的，不久就有新的需求，name使用8个字节不够，最大长度可能会达到100个字节，A和B就愁怀了，总不能即使叫“steven”的人，每次都按照100个字节打包，虽然不差钱，也不能这样浪费。

于是A和B寻找各方资料，找到了ANS.1编码规范，好东西啊.. ASN.1是一种ISO/ITU-T 标准。其中一种编码BER（Basic Encoding Rules）简单好用，它使用三元组编码，简称TLV编码。



每个字段编码后内存组织如下



![img](https://upload-images.jianshu.io/upload_images/44290-a14410e4d049d66e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/188/format/webp)

clip_image006

字段可以是结构，即可以嵌套



![img](https://upload-images.jianshu.io/upload_images/44290-43760f59511d2aaf.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/308/format/webp)

clip_image008

A和B使用TLV打包协议后，数据内存组织大概如下:



![img](https://upload-images.jianshu.io/upload_images/44290-c257a728cad5da13.gif?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)

clip_image010

TLV具备了很好可扩展性，很简单易学。同时也具备了缺点，因为其增加了2个额外的冗余信息，tag 和len，特别是如果协议大部分是基本数据类型int ,short, byte. 会浪费几倍存储空间。另外Value具体是什么含义，需要通信双方事先得到描述文档，即TLV不具备结构化和自解释特性。

三、

自解释性

当A和B采用TLV协议后，似乎问题都解决了。但是还是觉得不是很完美，决定增加自解释特性，这样抓包就能知道各个字段类型，不用看协议描述文档。这种改进的类型就是 TT[L]V（tag，type，length，value），其中L在type是定长的基本数据类型如int,short, long, byte时候，因为其长度是已知的，所以L不需要。

于是定义了一些type值如下



| 类型   | Type值 | 类型描述               |
| ------ | ------ | ---------------------- |
| bool   | 1      | 布尔值                 |
| int8   | 2      | 带符号的一个字符       |
| uint8  | 3      | 带符号的一个字符       |
| int16  | 4      | 16位有符号整型         |
| uint16 | 5      | 16位无符号整型         |
| int32  | 6      | 32位有符号整型         |
| uint32 | 7      | 32位无符号整型         |
| ...    |        |                        |
| string | 12     | 字符串或二进制序列     |
| struct | 13     | 自定义的结构，嵌套使用 |
| list   | 14     | 有序列表               |
| map    | 15     | 无序列表               |

按照ttlv序列化后，内存组织如下



![img](https://upload-images.jianshu.io/upload_images/44290-f2162bd68a6b1333.gif?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)

clip_image012

改完后，A和B发现，的确带来很多好处，不光可以随心所以的增删字段，还可以修改数据类型，例如把cmd改成int cmd；可以无缝兼容。真是太给力了。

三、

跨语言特性

有一天来了一个新的同事C，他写一个新的服务，需要和A通信，但是C是用java或PHP的语言，没有无符号类型，导致负数解析失败。为了解决这个问题，A重新规划一下协议类型，做了有些剥离语言特性，定义一些共性。对使用类型做了强制性约束。

虽然带来了约束，但是带来通用型和简洁性，和跨语言性

，大家表示都很赞同，于是有了一个类型(type)规范。



| 类型   | Type值 | 类型描述               |
| ------ | ------ | ---------------------- |
| bool   | 1      | 布尔值                 |
| int8   | 2      | 带符号的一个字符       |
| int16  | 3      | 16位有符号整型         |
| int32  | 4      | 32位有符号整型         |
| …      |        |                        |
| string | 12     | 字符串或二进制序列     |
| struct | 13     | 自定义的结构，嵌套使用 |
| list   | 14     | 有序列表               |
| map    | 15     | 无序列表               |

**四、代码自动化**——**IDL语言的产生**
但是A和B发现了新的烦恼，就是每搞一套新的协议，都要从头编解码，调试，虽然TLV很简单，但是写编解码是一个毫无技术含量的枯燥体力活，一个非常明显的问题是，由于大量copy/paste,不管是对新手还是老手，非常容易犯错，一犯错，定位排错非常耗时。于是A想到使用工具自动生成代码。
IDL（Interface Description Language），它是一种描述语言，也是一个中间语言，IDL一个使命就是规范和约束，就像前面提到，规范使用类型，提供跨语言特性。通过工具分析idl文件，生成各种语言代码

```css
Gencpp.exe sample.idl 输出 sample.cpp sample.h
Genphp.exe sample.idl 输出 sample.php
Genjava.exe sample.idl 输出 sample.java
```

是不是简单高效
**四、总结**
大家看到这里，是不是觉得很面熟。是的，协议讲到最后，其实就是和facebook的thrift和google protocol buffer协议大同小异了。包括公司无线使用的jce协议。咋一看这些协议的idl文件，发现几乎是一样的。只是有些细小差异化。

这些协议在一些细节上增加了一些特性：

1.压缩，这里压缩不是指gzip之类通用压缩，是指针对整数压缩，如int类型，很多情况下值是小于127（值为0的情况特别多），就不需要占用4个字节，所以这些协议做了一些细化处理，把int类型按照情况，只使用1/2/3/4字节，实际上还是一种ttlv协议。

2.reuire/option 特性: 这个特性有两个作用，1、还是压缩，有时候一个协议很多字段，有些字段可以带上也可以不带上，不赋值的时候不是也要带一个缺省值打包，这样很浪费，如果字段是option特性，没有赋值的话，就不用打包。2、有点逻辑上约束功能，规定哪些字段必须有，加强校验。
序列化是通信协议的基础，不管是信令通道还是数据通道，还是rpc，都需要使用到。在设计协议早期就考虑到扩展性和跨语言特性。会为以后省去不少麻烦。

**Ps**
本篇主要介绍二进制通信协议序列化，没有讲文本协议。从某种意义来讲，文本协议天生具有兼容和可扩展性。不像二进制需要考虑那么多问题。文本协议易于调试（如抓包就是可见字符，telnet即可调试，数据包可以手工生成不借助特殊工具），简单易学是其最强大的优势。
二进制协议优势就是性能和安全性。但是调试麻烦。
两者各有千秋，按需选择。(stevenrao)

转发：[http://blog.chinaunix.net/uid-27105712-id-3266286.html](https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-27105712-id-3266286.html)







什么是TLV？

**T（Tag/Type）**所传输数据的类型，自定义，如规定0x01为int类型，则接收端必须使用同样的规定（协议)来解
 析这串数据
**L（Lengh)**    所传输数据的长度（也可以是整帧数据的长度，协议是自定义的，L的定义由协议制定者自己定义
（数据经过协议的封装，最后发送出去的数据串是经过数据链路层的封装形成的最小传输单元--帧））。
**V（Value）**    传输的数据内容。

再用一个例子来加深对此协议的理解：
假设我们现在要发送某地的温度和相对湿度到服务器，温度：0x01,0x02,0x02,0x04(12.24℃）相对湿度0x64(100％）（这里的数据解析由协议制定者来规定）

V:直接传输V（value)如果直接发送。。。。。0x01,0x02,0x02,0x04,0x64。。。
0x01,0x02,0x04,0x04,0x64。。。。。接收方可以解析出温度和湿度，而且会傻傻的一次解析4个字节，如果数据传输
时发生丢失，整帧数据的解析岂不是完全乱了，如果数据传输时发生错误，解析出来一个100℃（笑出声）。。。假
设数据传输完全可靠，如果想再加入一个数据类型如天气，整个传输解析过程要做出大量修改。。。而且数据传输
不可能百分百可靠。	

TLV：加上Tag域同时也要加上Length域，假设Tag（1byte）为数据的类型，假设规定0x01为温度（4byte)，0x02为
湿度（1byte),Length（1byte）为整个数据帧的长度，则数据的传输：。。。。**0x01**，0x06，
0x01,0x0,0x02,0x04，**0x02**，0x03，0x64。。。。。。接收端遇到T开始解析，通过数据的Length域来判断解析
的数据的长度，实现对Value的解析，同样，问题仍然没有解决，只是解决了对增加新的数据类型更方便，但是对数
据丢失，变化没有更好的处理，除非数据传输完全可靠。

HTLV：引入H域（Head域）HTLV传输数据，定义H为0xfd,在原来TLV基础上对每个数据包前面加上头Head，接收
方只有遇到Head才开始解析数据，否则丢弃数据，可以很明显的看出，这种方法很好的避免了数据丢失带来的解析
失序，但是不能避免的时当数据包中数据出现0xfd，而此时原数据帧的Head域丢失或者变化，接收端在解析时，会
丢弃变化的Head域，再开始search 0xfd，直到找到Head域才开始解析，而刚好数据域中有一个字节时0xfd，此时数
据将从这开始解析，解析同样会乱套。

HTLVC：引入CRC（Cyclic Redundancy Check）循环冗余检验，形成HTLVC的形式，CRC是一种检错技术，对原
有数据的变化和丢失有很好的检测效果，它的主要工作方式就是对数据的**每一位**（bit而不是byte）进行某种运
算，得出独一无二（相对的独一无二）的FCS（Frame Check Sequence）帧检序列，	将其加在HTLV尾部。CRC
对HTLV的每一位进行计算，得到一个独一无二的数据，并将此数据加在HTLV后面形成数据帧HTLVC，此时接收方
遇到Head域开始对数据进行检测，找到数据的Length域得知数据的长度，再减去CRC的长度，得到数据HTLV，对
数据HTLV进行同样的CRC运算，得到一个CRC值，用此值与源数据包的CRC值进行比较，如果不同，证明数据是
有问题的（HTLVC都可能出错，此时任何一个域出错，都判定此数据出错，则停止解析，继续寻找下一个
Head。。。），如果相同，则证明数据是正确是，并正常解析出Value，**再跳过此帧数据**，继续解析。此外，
CRC技术广泛用于对数据的检测（计算机网络的IP层，数据链路层对数据的封装都会用到CRC校验，为最大可能的
保证数据传输的可靠性），尽管它对数据的计算方式可能不尽相同，但是对同一段数据的解析采用同一种运算的结
果肯定的一样的。
