## 思考

### 继承和多态
继承指子类与父类的共同继承，多态(Polymorphism)指子类间 和父类的区别。
子类相比父类的区别在于：类名，子类变量，子类函数，重载函数。

多态：switch ==》 虚类虚方法+继承


简单多态： switch 和对象多态
高级多态：反射，type参数化，类型全局注册，序列化。

如何实现 工厂，字符串输入，输出不同对象。
类型全局注册 相当于添加 记录对象名id和具体类型的字典结构，
工厂函数输入字符串id，从全局注册类型基于id构建


### 面向对象编程范式



### 面向函数式编程
pipeline, 高阶函数， currying， 管道符，递归，lazy Evalutation
闭包，思路类似 函数+环境变量+ 参数变量（输入输出）
不关心结构的继承衍生关系，只关心和处理属性。
lazy Evalutation 和写时复制相似。
### 多变衍生思考
变与不变：即相同的格式，封装不同的内容，有多种实现
if & then ，处理bool型多态
switch&case，处理int，char型多态
基类&子类 ,处理子类之间实例的多态，返回接口/数据
基类&子类 : 衍生出了工厂模式，,处理子类类型的多态
接口&实现， duck typing

url& 网关&路由分发
ip地址&路由器地址
path& file content
json字典&CRUD
字符串=》json序列化=》object


需要设计合适的多态，封装不同等级的变化，让多态的变化维度与业务需求适配。
一个例子： 使用多语言写项目时，可以使用python写业务逻辑，C++写速度瓶颈模块，json部分记录可配置方案。

网络世界构筑于协议之上，cpu构筑于指令集之上。

组合的实现方式：多重继承，
组合和继承都允许在新的类中放置子对象，组合是显式这样做，而继承则是隐式这样做。组合技术通常是用于想在新类中使用现有类的功能而非其接口的情况。即，在新类中嵌入某个对象，让其实现所需要的功能；新类的用户看到的只是为新类所定义的接口，而非所嵌入类的接口。继承是使用某个现有类并开发其特殊版本，会拥有现有类的接口并且可以为新类开发新的接口。所以，继承关系为“is-a”（是一个），组合关系为“has-a”（有一个）。

在大多数面向对象的编程语言中多继承都是不支持的。因为在基于class的体系中，多继承极大地增加了编译器的复杂性。
多继承非常容易出现菱形继承，多个父类的数据方法的继承顺序非常容易出现意料之外的行为。
#### 平台无关
如何实现平台无关，所有的问题都可以通过增加接口层实现
java增加jvm和字节码
python增加了pyc的字节码。
QT提供了对底层系统的封装，使得qt多平台可用。
nodejs基于浏览器提供了封装，使得nodejs多平台可用。
#### type

 鸭子类型是多态(polymorphism)的一种形式.在这种形式中,不管对象属于哪个,也不管声明的具体接口是什么,只要对象实现了相应的方法,函数就可以在对象上执行操作. 即忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义.

duck typing相对应的是normal typing（对象的类型决定了对象的特性），duck typing中对象的类型不重要，只要对象有类型A的方法和属性，那么它被当做类型A来使用
c就是normal typing，在编译阶段静态检查，函数定义和传参类型不一致就报错。对应的python属于duck typing，基本上是类型随便混用，没有静态检查类型匹配情况，只有运行起来找不到相应属性和方法时才报错。

在 Python 中创建功能完善的序列类型无需使用继承, 只需实现符合序列协议的方法.
在面向对象编程中,协议是非正式的接口,只在文档中定义,在代码中不定义.
 例如,Python 的序列协议只需要 __len__ 和 __getitem__ 两个方法.
 任对象/类型(A)只要使用标准的签名和语义实现了这两个方法,就能用在任何期待序列的地方,
 然而A 是不是哪个类的子类无关紧要,只要提供了所需的方法即可.这就是 python 序列协议.
协议是非正式的,没有强制力,因此如果你知道类的具体使用场景,通常只需要实现一个协议的部分.
例如,为了支持迭代,只需实现 __getitem__ 方法，没必要提供 __len__方法.

### 结构化逆结构化
序列化& 反序列化
序列化之后获得的是一个流对象，流对象的中间过程没有意义，只有结束了才能重构并获得完整对象。
序列化&解析
协议封包&协议解包
数据+模板生成网页&网页解析得到数据
归根结底是对 对象操作

结构化和扁平化：可以想象成一个一张折纸可以折成各种形状，各种形状都能转成一张折纸。折纸化之后失去了结构特性，但还保留了可以重建的折痕。
对象除了扁平化还有分解，分解的不同在于分解的对象保留部分特性，扁平化的流过程不保留原始对象的特性。
分解与重构。