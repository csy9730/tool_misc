# 面向对象设计模式
23种面向对象设计模式

* 创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
* 结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
* 行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


1. Factory Method（工厂方法）
2. Abstract Factory（抽象工厂）
3.  Builder（建造者）
4. Prototype（原型）
5.  Singleton（单例）结构型
6.  Adapter Class/Object（适配器）
7.  Bridge（桥接）
8.  Composite（组合）
9.  Decorator（装饰）
10.  Facade（外观）
11.  Flyweight（享元）
12.  Proxy（代理）行为型
13.  Interpreter（解释器）
14.  Template Method（模板方法）
15.  Chain of Responsibility（责任链）
16.  Command（命令）
17.   Iterator（迭代器）
18.   Mediator（中介者）
19.   Memento（备忘录）
20.   Observer（观察者）
21.   State（状态）
22.   Strategy（策略）
23.   Visitor（访问者）

面向对象设计模式，目的在于处理对象的差异化和统一化。
* 差异化：策略模式 模板方法模式  抽象工厂模式 建造者模式, 状态机模式，
* 统一化：适配器模式、装饰器模式、代理模式、外观模式、桥接模式，命令模式，组合模式
* 其他：原型模式 单例模式 ，迭代子模式，

Factory Method（工厂方法）, Abstract Factory（抽象工厂）,基于参数生成目标类，Builder（建造者）基于配置参数（延迟给定）生成目标类，两者有什么区别？
Prototype（原型）复制构造函数，支持写时复制？
Singleton（单例）构造单例目标类。

适配器模式和 facade的区别： 使用一个wrapper的一个方法，统一多个不同object的方法，不同object的方法是并行关系,一次对应一个方法。
facade，把多个object的方法，按照串行执行，对应wrapper的一个方法。
装饰器，为object添加装饰器，增加功能，使用被装饰过的object，通过语法糖使你仍然调用原始的那个object。
proxy：使用wrapper替代原始object使用，相比比较朴素。
享元模式： 返回一个 query or new 对象， 如果查询到对象就返回，否则新建对象，允许共享同一个对象，减少内存消耗。
Composite 组合模式，类似列表，可以描述多个object。
桥接模式： 可以为不同的 接口提供共同的实体,组成一个wrapper（融合了接口和实现）。

解释器模式，状态模式、迭代子模式、
策略模式、模板方法模式、责任链模式、命令模式、
中介者模式、观察者模式、备忘录模式、访问者模式、

策略模式和适配器模式的区别： 策略模式侧重于多态，同一个接口可以更换多种策略；适配器侧重于把多态统一成同一个接口。


Adapter Class/Object（适配器）

1.   Interpreter（解释器）
2.   Template Method（模板方法）
3.   Chain of Responsibility（责任链）
4.   Command（命令）
5.    Iterator（迭代器）
6.    Mediator（中介者）
7.    Memento（备忘录）
8.    Observer（观察者）
9.    State（状态）
10.   Strategy（策略）
11.   Visitor（访问者）


## 简介

### 单例模式
单例模式，功能类似于c语言的全局变量，相比全局变量，有更加完整的初始化、析构流程，避免全局变量初始化的歧义型，具体实现分为懒汉初始化和饿汉初始化。

### 工厂模式

工厂模式的意义,就是生成对象，就是 传入一个type,返回一个对象。生成对象与new功能相当。new 配合构造函数，只能生成对应的类的实例，不能生成不同类。也就是， 工厂模式是对new的封装，比new多了一层抽象层。
new 和类
常见的例子就是工厂模式，抽象工厂，
工厂模式类似switch case 

``` python
class Shape:
    def draw(self):
        pass
class Circle(Shape):
    def draw(self):
        print("draw Circle")
class Rectangle(Shape):
    def draw(self):
        print("draw Rectangle")
class ShapeFactory:
    def getShape(typ):
        if "Circle"==typ:
            return Circle()
        elif "Rectangle"==typ:
            return Rectangle()

def demo():
    shapeFactory = ShapeFactory()
    shapeFactory.getShape("circle").draw()
    shapeFactory.getShape("Rectangle").draw()
def demo2():
    class ShapeFactory:
        factory ={"Circle":Circle,"Rectangle":Rectangle}
        @classmethod
        def get(cls, factory_name):
            return cls.factory.get(factory_name)
    shapeFactory=ShapeFactory()
    shapeFactory.get("Circle")().draw()
    shapeFactory.get("Rectangle")().draw()    
if __name__ =="__main__":
    demo()
```

策略工厂

``` python
class Shape:
    def draw(self):
        pass
class Circle(Shape):
    def draw(self):
        print("draw Circle")
class Rectangle(Shape):
    def draw(self):
        print("draw Rectangle")
class ShapeFactory:
    def getShape(typ):
        pass
class CircleFactory:
    def getShape():
            return Circle()
class RectangleFactory:
    def getShape():
            return Rectangle()

def demo():
    shapeFactory = CircleFactory()
    shapeFactory.getShape().draw()
    rectangleFactory = RectangleFactory()
    rectangleFactory.getShape().draw()
    
if __name__ =="__main__":
    demo()
```


抽象工厂包括：
抽象产品类
具体产品类
抽象工厂类
具体工厂类

``` python
class Button:
    def processEvent(self):
        pass

class Text:
    def getWholeText(self):
        pass
        
class LinuxButton(Button):
    def processEvent(self):
        print("Inside LinuxButton::processEvent() method.")
class WindowsButton(Button):
    def processEvent(self):
        print("Inside WindowsButton::processEvent() method.")

class LinuxText(Text):
    def getWholeText(self):
        print("Inside LinuxText::getWholeText() method.")

class WindowsText(Text):
    def getWholeText(self):
        print("Inside WindowsText::getWholeText() method.")
    
class AbstractFactory(Text):
    def createButton(self):
        pass
   def createText(self):
        pass    
        
class LinuxFactory(AbstractFactory):
    def createButton(self):
        return LinuxButton()
   def createText(self):
        return LinuxText()  
        
class WindowsFactory(AbstractFactory):
    def createButton(self):
        return WindowsButton()
   def createText(self):
        return WindowsText() 

def demo():
    linuxFactory = LinuxFactory();
    linuxFactory.createButton().processEvent();
    linuxFactory.createText().getWholeText();
    windowsFactory = WindowsFactory();
    windowsFactory.createButton().processEvent();
    windowsFactory.createText().getWholeText();

```

工厂模式+反射：

使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。
``` python

class Shape:
    def draw(self):
        pass
class Circle(Shape):
    def draw(self):
        print("draw Circle")
class Rectangle(Shape):
    def draw(self):
        print("draw Rectangle")
class ShapeFactory:
    def getShape(typ):
        if locals().get(typ):
            return locals().get(typ)()
            
def demo():
    shapeFactory = ShapeFactory()
    shapeFactory.getShape("circle").draw()
    shapeFactory.getShape("Rectangle").draw() 
if __name__ =="__main__":
    demo()
```
工厂模式分为：简单工厂模式，策略工厂，抽象工厂,工厂模式+反射。
区分聚合和合成
增加一个抽象层，应对变化。
开放，封闭，原则： 多态的增量开发。
李氏替换原则：针对抽象编程，而不是细节编程。


### 组装模式
builder模式：包含newer & setter
分为product，builder，director，
builder通用；director侧重专用。
builder包含 newer和setter，director包含builder和具体的setter属性。具体的setter属性可以通过参数传入。确保builder的每个组件都被正确创建。

### 装饰模式

组件拼合方法： 装饰模式和builder模式。区别：装饰对象可以任意在任意时点展示装饰，builder需要完整组装完成才能展示。
重点是不改变主体的情况下，对主体添加功能。
函数嵌套迭代调用，容易消耗栈空间。
装饰模式：  
```  js
A.decorate(B) ; 
A.func()==>{ 
    B.func(); 
    A.spec();
}
C.decorate(B); 
C.func()==>{ B.func();C.spec();};
```


### 外观模式
外观模式用于隐藏复杂的结构信息，提供扁平化接口。
``` python

class Computer:
    def open(self):
        pass
class Cpu(Computer):
    def open(self):
        print("启动CPU")
class Ddr(Computer):
    def open(self):
        print("启动内存")
class Ssd(Computer):
    def open(self):
        print("启动硬盘");

class Facade:
    def __init__(self):
        self. cpu = Cpu();
        self. ddr = Ddr();
        self. ssd = Ssd();

    def start(self):
        self.cpu.open()
        self.ssd.open()
        self.ddr.open()
    
def main():
    facade = Facade();
    facade.start();
```


### 适配器模式

可以实现把不同class 的object的attribute和methods，重命名（映射）成Adapter的统一attribute和methods。该操作无需修改原class。
需要写wrapper，新的wrapper完全调用就class/object的功能，为每个原class分别绑定方法，

``` python

import os
class Dog(object):
    def __init__(self):
        self.name = "Dog"
    def bark(self):
        return "woof!"
class Cat(object):
    def __init__(self):
        self.name = "Cat"
    def meow(self):
        return "meow!"
class Human(object):
    def __init__(self):
        self.name = "Human"
    def speak(self):
        return "'hello'"
class Car(object):
    def __init__(self):
        self.name = "Car"
    def make_noise(self, octane_level):
        return "vroom%s" % ("!" * octane_level)
class Adapter(object):
    """
    Adapts an object by replacing methods.
    Usage:
    dog = Dog
    dog = Adapter(dog, dict(make_noise=dog.bark))
    """
    def __init__(self, obj, adapted_methods):
        """We set the adapted methods in the object's dict"""
        self.obj = obj
        self.__dict__.update(adapted_methods)
    def __getattr__(self, attr):
        """All non-adapted calls are passed to the object"""
        return getattr(self.obj, attr)
def main():
    objects = []
    dog = Dog()
    objects.append(Adapter(dog, dict(make_noise=dog.bark)))
    cat = Cat()
    objects.append(Adapter(cat, dict(make_noise=cat.meow)))
    human = Human()
    objects.append(Adapter(human, dict(make_noise=human.speak)))
    car = Car()
    car_noise = lambda: car.make_noise(3)
    objects.append(Adapter(car, dict(make_noise=car_noise)))
    for obj in objects:
        print("A", obj.name, "goes", obj.make_noise())
if __name__ == "__main__":
    main()


```
### 策略模式
包括： 抽象策略，具体策略类，策略选择器。
策略选择器可以更换不同的具体策略类。

简单理解：c语言中就是传递函数指针，java没有函数指针，就封装成object传递。

### proxy

代理模式，注重对对象某一功能的流程把控和辅助。它可以控制对象做某些事，重心是为了借用对象的功能完成某一流程，而非对象功能如何。
装饰模式，注重对对象功能的扩展，它不关心外界如何调用，只注重对对象功能的加强，装饰后还是对象本身。

对于代理类，如何调用对象的某一功能是思考重点，而不需要兼顾对象的所有功能；
对于装饰类，如何扩展对象的某一功能是思考重点，同时也需要兼顾对象的其它功能，因为再怎么装饰，本质也是对象本身，要担负起对象应有的职责。

对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。他们之间的边界确实比较模糊，两者都是对类的方法进行扩展，具体区别如下：

1、装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。

2、装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；

3、装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；


装饰模式的功能实现是由上层调用者决定的，代理模式的功能已经写死了，不能够实现灵活的拓展。


### 命令模式

命令模式是利用类来实现对命令函数的封装，实现命令调用者和命令接收者之间的解耦，命令模式具体包括三部分：
1. 命令调用者（Invoker）（客户端，调用命令的函数或者类）
2. 命令（Command）（对命令接收者命令函数的封装）
3. 命令接收者（RECEIVER）（真正执行命令的地方，实现了众多命令函数）

此外还有 命令翻译器，把行为翻译成具体命令。
经典例子：遥控器遥控电视， 包括 执行人，遥控器，开机命令，电视机。

以下例子包括：
command Executor: 实际执行的主体和函数。
命令 = （主语） + 谓语（购买/出售）+宾语（股票名字）
invoker class：对应菜单，封装了多个命令，每个菜单对应一条命令。
invoker： 默认指客户端行为，点击菜单的主体。

命令模式的应用场景
当系统的某项操作具备命令语义，且命令实现不稳定（变化）时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。接收方与抽象命令呈现弱耦合（内部方法无需一致），具备良好的扩展性。

命令模式通常适用于以下场景。
请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。
系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能。
当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。
当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。

``` python
# Command Pattern with Python Code
from abc import  abstractmethod,ABCMeta

# 创建一个命令接口Order
class Order(metaclass=ABCMeta):
    @abstractmethod
    def execute(self):
        pass

# 创建一个请求类
class Stock():
    _name = "ABC"
    _quantity = 10
    def buy(self):
        print("Stock [Name : {0}, Quantity: {1}] bought.".format(self._name,self._quantity))
    def sell(self):
        print("Stock [Name : {0}, Quantity: {1}] sold.".format(self._name, self._quantity))

# 创建实现了Order接口的实体类
class BuyStock(Order):
    _abcStock = None
    def __init__(self,inStock):
        self._abcStock = inStock
    def execute(self):
        self._abcStock.buy()
class SellStock(Order):
    _abcStock = None
    def __init__(self,inStock):
        self._abcStock = inStock
    def execute(self):
        self._abcStock.sell()

# 创建命令调用类
class Broker():
    _orderList = []
    def takeOrder(self,inOrder):
        self._orderList.append(inOrder)
    def placeOrders(self):
        for aOrder in self._orderList:
            aOrder.execute()
        self._orderList.clear()

# 调用输出
if __name__ == '__main__':
    abcStock = Stock()
    buyStockOrder = BuyStock(abcStock)
    sellStockOrder = SellStock(abcStock)

    broker = Broker()
    broker.takeOrder(buyStockOrder)
    broker.takeOrder(sellStockOrder)

    broker.placeOrders()
```

命令模式&观察者模式：
命令模式发起通知方内部只有命令的对象，通过命令来完成。--通知的是命令。

观察者模式发起通知的内部是接收通知的对象，通过调用接受对象的方法来完成。--通知的是接收对象，由接收对象自己执行对应的方法。

### 备忘录模式

包括目标类，目标状态类，重建执行者类
### Facsade
> 为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：

如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。


``` python
class Computer:
    def __init__(self):
        self.cpu = None
        self.hardisc = None
        self.cpu = None

    def poweron(self):
        self.board.on()
        self.hardisc.on()
        self.cpu.on()    

c = Computer()
c.poweron()

```
Facade 可以封装复杂（用户不关心的）过程。

Facsade模式，抽象出一个接口层。
### bridge
桥接模式包含了策略模式，但比它更复杂。
桥接模式 描述了object，可以后天持有多种

对于描述两种以上范畴的系统，如果使用两层继承，两种范畴的组合将产生大量冗余继承树。
桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。
所以，桥接模式就是为了避免直接继承带来的子类爆炸。

和建造模式的区别？

建造模式出来就是成品，不再修改。
桥接模式可以继续随意修改。
 
### 观察者模式

通信分为：观察者模式和 时间循环监听。
观察者模式：有一个subject和多个观察者，subject发生改变会通知所有观察者。subject保存了所有观察者组成的聚集。
添加委托绑定  观察者动作。（函数指针，句柄）

1. A关注了B
2. B发布消息
3. B接收消息
4. B执行动作

分为几种不同执行动作：
1 在B的环境里，打断A的行为，强制执行指定动作。该动作对A和B都是同步动作。概念等同于callback。
2. B发送消息给A，然后B就不管了，A异步动作。A收到消息，执行动作。，B可以同步也可以异步

实现了观察者模式的C++库：qt, sigslot ,boost.
### MVC
通常认为MVC由三种设计模式组成：组合模式，观察者模式，策略模式。
### 图纸模式
builder模式的一种，神经网络的构建方式。记录所有layer。

### 并发模式

### misc

组合模式，处理一个到多个的对象群落。类似树的数据结构
责任链模式： 树形结构？可用于处理对象的析构顺序？




## 参考

[python-patterns](https://github.com/faif/python-patterns)
[Design_pattern_of_python](github:https://github.com/w392807287/Design_pattern_of_python)
《大话设计模式》——吴强
23种面向对象设计模式
《Python设计模式》——pythontip.com

