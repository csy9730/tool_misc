# 面向对象设计模式
23种面向对象设计模式

* 创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
* 结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
* 行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


1. Factory Method（工厂方法）
2. Abstract Factory（抽象工厂）
3.  Builder（建造者）
4. Prototype（原型）
5.  Singleton（单例）结构型
6.  Adapter Class/Object（适配器）
7.  Bridge（桥接）
8.  Composite（组合）
9.  Decorator（装饰）
10.  Facade（外观）
11.  Flyweight（享元）
12.  Proxy（代理）行为型
13.  Interpreter（解释器）
14.  Template Method（模板方法）
15.  Chain of Responsibility（责任链）
16.  Command（命令）
17.   Iterator（迭代器）
18.   Mediator（中介者）
19.   Memento（备忘录）
20.   Observer（观察者）
21.   State（状态）
22.   Strategy（策略）
23.   Visitor（访问者）

面向对象设计模式，目的在于处理对象的差异化和统一化。
* 差异化：策略模式 模板方法模式  抽象工厂模式 建造者模式, 状态机模式，
* 统一化：适配器模式、装饰器模式、代理模式、外观模式、桥接模式，命令模式，组合模式
* 其他：原型模式 单例模式 ，迭代子模式，

Factory Method（工厂方法）, Abstract Factory（抽象工厂）,基于参数生成目标类，Builder（建造者）基于配置参数（延迟给定）生成目标类，两者有什么区别？
Prototype（原型）复制构造函数，支持写时复制？
Singleton（单例）构造单例目标类。

适配器模式和 facade的区别： 使用一个wrapper的一个方法，统一多个不同object的方法，不同object的方法是并行关系,一次对应一个方法。
facade，把多个object的方法，按照串行执行，对应wrapper的一个方法。
装饰器，为object添加装饰器，增加功能，使用被装饰过的object，通过语法糖使你仍然调用原始的那个object。
proxy：使用wrapper替代原始object使用，相比比较朴素。
享元模式： 返回一个 query or new 对象， 如果查询到对象就返回，否则新建对象，允许共享同一个对象，减少内存消耗。
Composite 组合模式，类似列表，可以描述多个object。
桥接模式： 可以为不同的 接口提供共同的实体,组成一个wrapper（融合了接口和实现）。

解释器模式，状态模式、迭代子模式、
策略模式、模板方法模式、责任链模式、命令模式、
中介者模式、观察者模式、备忘录模式、访问者模式、

策略模式和适配器模式的区别： 策略模式侧重于多态，同一个接口可以更换多种策略；适配器侧重于把多态统一成同一个接口。


Adapter Class/Object（适配器）

1.   Interpreter（解释器）
2.   Template Method（模板方法）
3.   Chain of Responsibility（责任链）
4.   Command（命令）
5.    Iterator（迭代器）
6.    Mediator（中介者）
7.    Memento（备忘录）
8.    Observer（观察者）
9.    State（状态）
10.   Strategy（策略）
11.   Visitor（访问者）


## 简介

### 单例模式
单例模式，功能类似于c语言的全局变量，相比全局变量，有更加完整的初始化、析构流程，避免全局变量初始化的歧义型，具体实现分为懒汉初始化和饿汉初始化。

### 工厂模式

工厂模式的意义,就是生成对象，就是 传入一个type,返回一个对象。生成对象与new功能相当。new （不接受参数的情况下) 生成对象不具有 灵活性。也就是 工厂模式比new多了一层抽象层。
常见的例子就是工厂模式，抽象工厂，
工厂模式类似switch case 

``` python
class Shape:
    def draw(self):
        pass
class Circle(Shape):
    def draw(self):
        print("draw Circle")
class Rectangle(Shape):
    def draw(self):
        print("draw Rectangle")
class ShapeFactory:
    def getShape(typ):
        if "Circle"==typ:
            return Circle()
        elif "Rectangle"==typ:
            return Rectangle()

def demo():
    shapeFactory = ShapeFactory()
    shapeFactory.getShape("circle").draw()
    shapeFactory.getShape("Rectangle").draw()
def demo2():
    class ShapeFactory:
        factory ={"Circle":Circle,"Rectangle":Rectangle}
        @classmethod
        def get(cls, factory_name):
            return cls.factory.get(factory_name)
    shapeFactory=ShapeFactory()
    shapeFactory.get("Circle")().draw()
    shapeFactory.get("Rectangle")().draw()    
if __name__ =="__main__":
    demo()
```

策略工厂

``` python
class Shape:
    def draw(self):
        pass
class Circle(Shape):
    def draw(self):
        print("draw Circle")
class Rectangle(Shape):
    def draw(self):
        print("draw Rectangle")
class ShapeFactory:
    def getShape(typ):
        pass
class CircleFactory:
    def getShape():
            return Circle()
class RectangleFactory:
    def getShape():
            return Rectangle()

def demo():
    shapeFactory = CircleFactory()
    shapeFactory.getShape().draw()
    rectangleFactory = RectangleFactory()
    rectangleFactory.getShape().draw()
    
if __name__ =="__main__":
    demo()
```


抽象工厂包括：
抽象产品类
具体产品类
抽象工厂类
具体工厂类

``` python
class Button:
    def processEvent(self):
        pass

class Text:
    def getWholeText(self):
        pass
        
class LinuxButton(Button):
    def processEvent(self):
        print("Inside LinuxButton::processEvent() method.")
class WindowsButton(Button):
    def processEvent(self):
        print("Inside WindowsButton::processEvent() method.")

class LinuxText(Text):
    def getWholeText(self):
        print("Inside LinuxText::getWholeText() method.")

class WindowsText(Text):
    def getWholeText(self):
        print("Inside WindowsText::getWholeText() method.")
    
class AbstractFactory(Text):
    def createButton(self):
        pass
   def createText(self):
        pass    
        
class LinuxFactory(AbstractFactory):
    def createButton(self):
        return LinuxButton()
   def createText(self):
        return LinuxText()  
        
class WindowsFactory(AbstractFactory):
    def createButton(self):
        return WindowsButton()
   def createText(self):
        return WindowsText() 

def demo():
    linuxFactory = LinuxFactory();
    linuxFactory.createButton().processEvent();
    linuxFactory.createText().getWholeText();
    windowsFactory = WindowsFactory();
    windowsFactory.createButton().processEvent();
    windowsFactory.createText().getWholeText();

```

工厂模式+反射：

使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。
``` python

class Shape:
    def draw(self):
        pass
class Circle(Shape):
    def draw(self):
        print("draw Circle")
class Rectangle(Shape):
    def draw(self):
        print("draw Rectangle")
class ShapeFactory:
    def getShape(typ):
        if locals().get(typ):
            return locals().get(typ)()
            
def demo():
    shapeFactory = ShapeFactory()
    shapeFactory.getShape("circle").draw()
    shapeFactory.getShape("Rectangle").draw() 
if __name__ =="__main__":
    demo()
```
工厂模式分为：简单工厂模式，策略工厂，抽象工厂,工厂模式+反射。
区分聚合和合成
增加一个抽象层，应对变化。
开放，封闭，原则： 多态的增量开发。
李氏替换原则：针对抽象编程，而不是细节编程。


### 组装模式
builder模式：包含newer & setter
分为product，builder，director，
builder通用；director侧重专用。
builder包含 newer和setter，director包含builder和具体的setter属性。具体的setter属性可以通过参数传入。确保builder的每个组件都被正确创建。

### 装饰模式

组件拼合方法： 装饰模式和builder模式。区别：装饰对象可以任意在任意时点展示装饰，builder需要完整组装完成才能展示。
重点是不改变主体的情况下，对主体添加功能。
函数嵌套迭代调用，容易消耗栈空间。
装饰模式：  
```  js
A.decorate(B) ; 
A.func()==>{ 
    B.func(); 
    A.spec();
}
C.decorate(B); 
C.func()==>{ B.func();C.spec();};
```


### 外观模式
外观模式用于隐藏复杂的结构信息，提供扁平化接口。
``` python

class Computer:
    def open(self):
        pass
class Cpu(Computer):
    def open(self):
        print("启动CPU")
class Ddr(Computer):
    def open(self):
        print("启动内存")
class Ssd(Computer):
    def open(self):
        print("启动硬盘");

class Facade:
    def __init__(self):
        self. cpu = Cpu();
        self. ddr = Ddr();
        self. ssd = Ssd();

    def start(self):
        self.cpu.open()
        self.ssd.open()
        self.ddr.open()
    
def main():
    facade = Facade();
    facade.start();
```


### 适配器模式

可以实现把不同class 的object的attribute和methods，重命名（映射）成Adapter的统一attribute和methods。该操作无需修改原class。
需要写wrapper，新的wrapper完全调用就class/object的功能，为每个原class分别绑定方法，

``` python

import os
class Dog(object):
    def __init__(self):
        self.name = "Dog"
    def bark(self):
        return "woof!"
class Cat(object):
    def __init__(self):
        self.name = "Cat"
    def meow(self):
        return "meow!"
class Human(object):
    def __init__(self):
        self.name = "Human"
    def speak(self):
        return "'hello'"
class Car(object):
    def __init__(self):
        self.name = "Car"
    def make_noise(self, octane_level):
        return "vroom%s" % ("!" * octane_level)
class Adapter(object):
    """
    Adapts an object by replacing methods.
    Usage:
    dog = Dog
    dog = Adapter(dog, dict(make_noise=dog.bark))
    """
    def __init__(self, obj, adapted_methods):
        """We set the adapted methods in the object's dict"""
        self.obj = obj
        self.__dict__.update(adapted_methods)
    def __getattr__(self, attr):
        """All non-adapted calls are passed to the object"""
        return getattr(self.obj, attr)
def main():
    objects = []
    dog = Dog()
    objects.append(Adapter(dog, dict(make_noise=dog.bark)))
    cat = Cat()
    objects.append(Adapter(cat, dict(make_noise=cat.meow)))
    human = Human()
    objects.append(Adapter(human, dict(make_noise=human.speak)))
    car = Car()
    car_noise = lambda: car.make_noise(3)
    objects.append(Adapter(car, dict(make_noise=car_noise)))
    for obj in objects:
        print("A", obj.name, "goes", obj.make_noise())
if __name__ == "__main__":
    main()


```
### 策略模式
包括： 抽象策略，具体策略类，策略选择器。
策略选择器可以更换不同的具体策略类。

### 命令模式

命令模式是利用类来实现对命令函数的封装，实现命令调用者和命令接收者之间的解耦，命令模式具体包括三部分：
1. 命令调用者（Invoker）（客户端，调用命令的函数或者类）
2. 命令（Command）（对命令接收者命令函数的封装）
3. 命令接收者（）（真正执行命令的地方，实现了众多命令函数）

此外还有 命令翻译器，把行为翻译成具体命令。
经典例子：遥控器遥控电视， 包括 执行人，遥控器，开机命令，电视机。

以下例子包括：
command Executor: 实际执行的主体和函数。
命令 = （主语） + 谓语（购买/出售）+宾语（股票名字）
invoker class：对应菜单，封装了多个命令，每个菜单对应一条命令。
invoker： 默认指客户端行为，点击菜单的主体。


``` python
# Command Pattern with Python Code
from abc import  abstractmethod,ABCMeta

# 创建一个命令接口Order
class Order(metaclass=ABCMeta):
    @abstractmethod
    def execute(self):
        pass

# 创建一个请求类
class Stock():
    _name = "ABC"
    _quantity = 10
    def buy(self):
        print("Stock [Name : {0}, Quantity: {1}] bought.".format(self._name,self._quantity))
    def sell(self):
        print("Stock [Name : {0}, Quantity: {1}] sold.".format(self._name, self._quantity))

# 创建实现了Order接口的实体类
class BuyStock(Order):
    _abcStock = None
    def __init__(self,inStock):
        self._abcStock = inStock
    def execute(self):
        self._abcStock.buy()
class SellStock(Order):
    _abcStock = None
    def __init__(self,inStock):
        self._abcStock = inStock
    def execute(self):
        self._abcStock.sell()

# 创建命令调用类
class Broker():
    _orderList = []
    def takeOrder(self,inOrder):
        self._orderList.append(inOrder)
    def placeOrders(self):
        for aOrder in self._orderList:
            aOrder.execute()
        self._orderList.clear()

# 调用输出
if __name__ == '__main__':
    abcStock = Stock()
    buyStockOrder = BuyStock(abcStock)
    sellStockOrder = SellStock(abcStock)

    broker = Broker()
    broker.takeOrder(buyStockOrder)
    broker.takeOrder(sellStockOrder)

    broker.placeOrders()
```

### 备忘录模式

包括目标类，目标状态类，重建执行者类


### 观察者模式

通信分为：观察者模式和 时间循环监听。
观察者模式：有一个subject和多个观察者，subject发生改变会通知所有观察者。subject保存了所有观察者组成的聚集。
添加委托绑定  观察者动作。（函数指针，句柄）

1. A关注了B
2. B发布消息
3. B接收消息
4. B执行动作

分为几种不同执行动作：
1 在B的环境里，打断A的行为，强制执行指定动作。该动作对A和B都是同步动作。概念等同于callback。
2. B发送消息给A，然后B就不管了，A异步动作。A收到消息，执行动作。，B可以同步也可以异步

实现了观察者模式的C++库：qt, sigslot ,boost.
### MVC
通常认为MVC由三种设计模式组成：组合模式，观察者模式，策略模式。
### 图纸模式
线性builder，神经网络的构建方式。记录所有layer。

### 并发模式

### misc

组合模式，处理一个到多个的对象群落。类似树的数据结构
责任链模式： 树形结构？可用于处理对象的析构顺序？
Facsade模式，抽象出一个接口层。



## 参考

[python-patterns](https://github.com/faif/python-patterns)
[Design_pattern_of_python](github:https://github.com/w392807287/Design_pattern_of_python)
《大话设计模式》——吴强
23种面向对象设计模式
《Python设计模式》——pythontip.com

