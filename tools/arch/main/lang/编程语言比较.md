# 编程语言比较

## 变量


变量包括：
* name
* domain/scope
* type
* value

动词包括：
* 声明  
* 定义
* 初始化/构造函数 (init/__init__) 包括分配空间，
* 释放  (deinit/__del__)
* 类型转化 
    * 隐式转化
    * 显式转化
* 赋值函数(set)
* 读取函数(get)
* 复制函数
* 复制构造函数，（构造函数+复制函数）
* 操作符重载
    * 一元运算
    * 二元运算

隐含属性
* sizeof
* address

domain决定变量的范围，直接确定了变量是全局变量还是静态变量，还是局部变量，并且确定了局部的范围，代码执行到退出domain的范围，局部变量将会被释放。
name提供了标志符，便于人区分。
type 决定了变量的编码和解码方式，以及对应的内存的存放长度，存放位置（对齐）。
value，由程序员决定。

address: C++通过 &i 来获取变量 i 的内存地址

声明，用于方便预处理器检查代码，允许后面直接使用变量。
    声明允许使用外部全局变量（extern），没有实际操作和代价。
    声明非外部变量，将会默认初始化变量。
定义，将会执行初始化：分配空间，存放变量，设置初始值。

key/value分离特性：高阶语言才有这个特性，赋值操作时，并不修改key对应的value，新建一个value，让key指向新建的value，删除旧value。其中value的删除操作可以由编译器决定延迟执行。
左值指的是key对应的值，一般是有名变量，具体的常量值如0，1 无法担任左值。右值是value对应的部分，包括匿名变量和常量值，例如`a=b+c` 的中间过程`b+c`就是匿名变量，而a是有名变量。

赋值和复制 这两个行为对称，类似memcpy的源和目标。赋值描述的是目标的行为，复制描述的是源的行为。
赋值对应的是value的可变性，相对的是不可变性。常量值，要求值在初始化之后不可变。

复制，简单地当成memcpy是不行的，需要区分浅复制和深复制。

分配空间+赋值 和初始化赋值不同，初始化赋值是分配空间malloc同时填充初始值，两步操作合一，效率更高。
先分配空间，再赋值是两步操作，效率较低。


java语言实现了Ioc机制，可以无需管理变量的生存周期。C语言提供了最基础的变量机制，可以自动释放超出域的变量。

### 数组
索引
变长数组？

### 指针
go语言中不允许高阶指针？指针做偏移运算?

### channel
channel iobuffer

### type

指针符号和地址符，数组符号可以改变类型，推导出新的类型。
#### 泛型
泛型，可以接收任意类型。
实现机制有： union。

值/指针兼容型
这种类型，允许接收原类型和引用类型。

## 运算

算术运算符，操作数都是数值型（整型或浮点型），返回数值型
关系运算符，操作数都是数值型，返回布尔类型
逻辑运算符，操作数都是布尔类型，返回布尔类型。
位运算符，操作数是整型，返回整型。
赋值运算符，包括=，+=， -=，等类型。

## 函数

输入参数
返回值
函数名
函数值
函数地址

函数定义中的变量称为形式参数
函数参数，分为值传递和引用传递。
值传递 	值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
引用传递 	引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。


c++的成员函数，在go语言和js中，分离成语言自带的方法特性和函数，go允许函数使用接收者，js可以使用call/apply方法。


### 接口
接口使用函数作为原型，允许定义同名但实现不同的函数。
在c++中，接口依附于object，颗粒度太大，导致菱形继承以及衍生的问题非常困难，难以使用。
接口相当于，一组函数原型，类似C++的虚基类只有多个虚函数，没有成员，衍生类继承于接口。衍生类必须实现所有的虚函数，go接口必须实现所有的接口原型。
go接口支持组合。
go 把C++的object分成了struct和接口。支持struct和别的接口组合。

问题： 不同的接口如果存在同名接口函数，会名字冲突么？如何避免？

## datastruct
### iobuffer
类似迭代器，串行文件，一个单步函数（read）返回内容，一个函数判断结束标志。
### 递归调用

## 模块
import
include

c语言使用头文件和源文件分离机制。



## 高阶机制
内存分配器
内存回收器（GC, gabage collector）