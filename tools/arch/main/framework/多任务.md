# 多任务


多任务是指在同一时间内执行多个任务，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。
多任务的最大好处是充分利用CPU资源，提高程序的执行效率。
## 简介
多任务的执行方式:
* 并发
* 并行
  
并发:在一段时间内交替去执行任务。
例如:对于单核cpu处理多任务,操作系统轮流让各个软件交替执行，假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。

并行:对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。

## 详解
### 进程
一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。
注意:一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。
进程是操作系统进行资源分配的基本单位。

进程之间不共享全局变量
创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。

**Q**:假如我们就让主进程执行0.5秒钟，子进程就销毁不再执行
**A**: 可以设置守护主进程`subprocess.daemon = True`;或者在主进程退出之前让子进程销毁`subprocess.terminate()`

孤儿进程:
父进程先于子进程退出，此时子进程就会成为孤儿进程。
孤儿进程会被系统指定的进程收养，即系统进程会成为该孤儿进程新的父进程,处理孤儿进程的退出状态；
孤儿进程一定不会成为僵尸进程。

僵尸进程:
子进程先于父进程退出，并且父进程没有处理子进程退出状态，此时子进程成为僵尸进程；
僵尸进程已经结束，但是会滞留部分PCB信息在内存，大量的僵尸会消耗系统资源，应该尽量避免僵尸进程的产生。


### 线程
线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。

线程之间共享全局变量
线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机


### 比较
线程是依附在进程里面的，没有进程就没有线程。
一个进程默认提供一条线程，进程可以创建多个线程。

线程之间执行是无序的，它是由cpu调度决定的 ，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。
进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行

进程之间不共享全局变量
线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步

创建进程的资源开销要比创建线程的资源开销要大
进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位


计算机的核心CPU，是个工厂，时刻运转着，工厂里有很多个车间（进程），一个车间开工其他车间不能开工，就是说：单核CPU一次只能运行一个进程。任何时候，CPU总是运行一个进程。

而一个车间里面有很多工人（线程），协同完成一个任务。所以：一个进程可以包括多个线程。车间空间是工人共享的，一个进程中的内存空间是所有线程共享的。

但是房间大小不同个，容纳量不同，有些线程进去了，其他线程就不能再进去使用了。这就是：一个线程使用某些共享内存时，其他线程得等它结束后才能使用共享内存。

内存可以上锁，防止其他线程进来，【互斥锁】也就是防止多个线程读写同一块内存区域。

还有些共享内存比较大，可以容纳多个线程，但是也是有限的，只能容纳固定数目的线程使用。如何保证多个线程不冲突呢？内存门口有个钥匙架，如果发现钥匙架空了，那就不能再进去了【信号量】。
### 协程

协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
进程和其他两个的区别还是很明显的。
协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

相比于前面的进程和线程，协程是一种用户态的轻量级线程。协程的调度由用户控制，**拥有自己独立的寄存器上下文和栈。**协程的切换效率比线程还要高！

介绍完协程，我们来说一下协程和线程的区别

1. 线程程是由CPU调度，而协程是由用户调度
2. 线程存在安全问题，协程比线程较安全
3. 线程可能并行，协程必然错开执行


打个比方吧，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。