# DDD


## entity&value Object
首先对于实体Entity，实体核心是用唯一的标识符来定义，而不是通过属性来定义。即即使属性完全相同也可能是两个不同的对象。同时实体本身有状态的，实体又演进的生命周期，实体本身会体现出相关的业务行为，业务行为会实体属性或状态造成影响和改变。

真正的现实世界，每个事物都一定会有唯一的标识，关键点是我们实际的业务场景和需求是否需要管理到唯一标识。书里面举了一个例子，当我们发放的门票上有座位号的时候，座位需要作为独立的实体，座位号是唯一的标识。而当先到先座模式下，我们只关心剩余座位数，那么座位号并不是唯一标识。这跟我们的业务需求有关。

为每个对象都分配一个id的成本太高了。

而对于值对象Value Object，它用于描述领域的某个方面本身没有概念标识的对象，值对象被实例化后只是提供值或叫设计元素，我们只关心这些设计元素是什么？而不关心这些设计元素是谁。书里面谈到颜色，数字是常见的值对象。这种对象无状态，本身不产生行为，不存在生命周期演进。

是否为值对象跟实际的业务场景仍然关系密切。书里面又举了地址的例子，当地址是值对象的时候，地址本身无状态，可以被多个实际有状态的实体使用，地址不存在太多的生命周期演进场景下地址为值对象。而对于本身行政区域管理软件中，地址本身存在状态，存在根据行政区域规划变化而演进的过程，因此地址为实体。
## 事务脚本模式

贫血模型 和充血模型关系？

贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个特点： 

- 它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。

- 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。

- 事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱



## 建模
如何设计开发产品？
首先需要建模，
领域专家，产品经理，架构师，开发心中都有不同的模型。需要达成共识，个人都有不同领域专精，共识需要反复提炼同步。


首先要解释的是“设计”这个词，这个“设计”不是我们脑子里一般泛指的设计，而是指传统软件建模中的一个阶段，传统的建模理论把软件的开发分为4个阶段，分别是“业务建模”、“需求”、“分析”和“设计”。我们来看看《UML模式和应用》中对分析和设计的定义。

分析（analysis）强调的是对问题和需求的调查研究，而不是解决方案
设计（design）强调的是满足需求的概念上的解决方案（在软件和硬件方面），而不是其实现。
有益的分析和设计可以概括为：做正确地事（分析）和正确地做事（设计）


有时可能需要使用对象模型以外的建模，例如规则引擎，工作流，数学密集型

## flow

领域专家提供应用业务场景等知识经验。
产品经理设计原型，剪裁功能。
架构师专注分解结构，还需要考虑编程实现。
开发根据架构文档，执行开发。

专家知识 到 架构模型有很大的跳跃，架构必须考虑实现方法，所以在中间在增加一个共识模型。

瀑布，敏捷，架构师独角戏

network，dataset，和trainer关系。
predictor和forward的区别



## sql
数据库，细粒度实体的关联，非常消耗数据库读写性能，尽量削弱关联，多使用单向关联，属性默认关联排除其他属性关联，filter。


复杂实体，需要引入工厂，聚合

聚合，描述根object，嵌套其它object，

A对象和B属性对象之间的关系， B作为嵌套属性，可以直接引用(读取A的属性B)，属性方法查询(动态方法，遍历B类查询a)，因为变化发生在B类。

B表更新，同步更新A表，阻塞a读取。分离成B表自由更新，不触发A表更新，读取a表时，间接查询B表。
B表相当于临时对象，类似value object。

读写都是操作，如何定义操作的影响域，限制影响域


区分 new工厂和rebuild 工厂。new和query尽量区分开来。new对应对象的起点，quert对应对象的中继。
repo 仓库，对应对象的从数据库的查询，检出，重建，并返回。持久化保存。


映射存储，oss
有时不得不牺牲规范化，使用非规范化，容许存在多个对象副本

## 领域事件

事件是表示发生在过去的事情，所以在命名上推荐使用Domain Name + 动词的过去式 + Event，这样可以更准确地表达业务语义。例如，在银行转账的例子中，对于转账成功和失败我们都需要发出事件通知，可以定义两个领域事件如下。（1）MoneyTransferedEvent：表示转账成功发出的事件。（2）MoneyTransferFailedEvent：表示转账失败发出的事件。

事件内容在计算机术语中叫作payload，有以下两种形式。（1）自恰（Enrichment）：就是在事件的payload中尽量多放数据，这样consumer不需要回查就能处理消息，也就是自恰地处理消息。（2）回查（Query-Back）：这种方式是只在payload放置id属性，然后consumer通过回调的形式获取更多数据。这种形式会加重系统的负载，可能会引起性能问题。

## 领域服务
领域服务有些领域中的动作是一些动词，看上去并不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单地把它们合并到某个实体或者值对象中。当这样的行为从领域中被识别出来时，推荐的实践方式是将它声明成一个服务。这样的对象不再拥有内置的状态，其作用仅仅是为领域提供相应的功能。Service往往是以一个活动来命名，而不是Entity来命名。例如在银行转账的例子中，转账（transfer）这个行为是一个非常重要的领域概念，但是它发生在两个账号之间，归属于账号Entity并不合适，因为一个账号Entity没有必要去关联它需要转账的账号Entity。在这种情况下，使用MoneyTransferDomainService就比较合适了。识别领域服务，主要看它是否满足以下3个特征。（1）服务执行的操作代表了一个领域概念，这个领域概念无法自然地隶属于一个实体或者值对象。（2）被执行的操作涉及领域中的其他对象。（3）操作是无状态的。
## 聚合根
聚合根（Aggregate Root）是DDD中的一个概念，是一种更大范围的封装，会把一组有相同生命周期、在业务上不可分割的实体和值对象放在一起，只有根实体可以对外暴露引用，这也是一种内聚性的表现。确定聚合边界要满足固定规则（Invariant），是指在数据变化时必须保持的一致性规则，具体规则如下。● 根实体具有全局标识，最终负责检查规定规则。 
● 聚合内的实体具有本地标识，这些标识在Aggregate内部才是唯一的。 
● 外部对象不能引用除根Entity之外的任何内部对象。 
● 只有Aggregate的根Entity才能直接通过数据库查询获取，其他对象必须通过遍历关联来发现。 
● Aggegate内部的对象可以保持对其他Aggregate根的引用。
● Aggregate边界内的任何对象在修改时，整个Aggregate的所有固定规则都必须满足。

### UBIQUITOUS LANGUAGE
在与领域专家进行交流的时候，经常会有那么一种情况，就是领域专家说的话开发人员听不懂，开发人员说的话领域专家也不能很好的理解，这样就导致了沟通的效率低下。所以在交流的时候，双方需要对同一个概念有一个统一的描述和理解，并且这些UBIQUITOUS LANGUAGE不仅仅在与领域专家交流的时候使用，并且在领域建模和后续的实现都要持续的使用下去。要让从业务专家到开发人员都能对这些词汇概念有统一的认识。
## misc
心智模型（mental model）
边界上下文


会话，一个请求和一个响应，似乎像函数的输入和返回。但会话强调的是一问一答的整个流程，是个容器，一问一答的内容才是会话的内容 

网络请求无状态，是指输入和输出无状态，但是过程有状态有副作用。

有时候需要牺牲一些分层，增加领域层的内聚。分层牺牲了许多，实体需要穿透多个层来表达，增加了开发成本，理解困难。


什么是规则rule 什么是策略 policy 


约束，规则 是静态的，必然生效的。而不能理解成动态的。和pipeline有显著区别。

specification 类似输入validator



OOA 和DDD的关系？
DDD是OOA的最佳实践？