# [login shell与non-login shell的区别](https://www.cnblogs.com/webnote/p/5876411.html)

Bash应该是我们每天日常工作接触最多的东西了，就像我们最忠实的朋友，我们有必要了解一下这位朋友的“习性”。
Bash有几种不同的运行模式，login shell与non-login shell，interactive shell与non-interactive shell（比如执行shell脚本）。这两种分类方法是交叉的，也就是说一个login shell可能是一个interactive shell，也可能是个non-interactive shell。
在下列情况下，我们可以获得一个login shell：


login shell与non-login shell的主要区别在于它们启动时会读取不同的配置文件，从而导致环境不一样。

- interactive shell 脚本模式
- non-interactive shell 会话模式
- login shell 登录模式 ~~使用用户配置的环境变量覆盖当前终端的环境变量~~
- non-login shell 非登录模式, 不需要重复登录， ~~使用当前终端的环境变量~~

两种模式组合：
- login interactive shell
    - 通过网络ssh登录
    - 本地终端登录
    - 在终端下使用`bash --login`
    - `su -l user`
- non-interactive shell
    - 脚本中使用 `bash --login`
- non-login interactive shell
    - `su  user`
- non-login non-interactive shell
    - `bash -c “CMD”`
    - `ssh server -- command`


1. 登录系统时获得的顶层shell，无论是通过本地终端登录，还是通过网络ssh登录。这种情况下获得的login shell是一个交互式shell。
2. 在终端下使用--login选项调用bash，可以获得一个交互式login shell。
3. 在脚本中使用--login选项调用bash（比如在shell脚本第一行做如下指定：`#!/bin/bash --login`），此时得到一个非交互式的login shell。
4. 使用`su -`切换到指定用户时，获得此用户的login shell。如果不使用"-"，则获得non-login shell。

- /etc/profile 全局配置，
- /etc/bash.bashrc
- ~/.bashrc 
- ~/.bash_profile , 一般~/.bash_profile 会调用~/.bashrc脚本。
- ~/.bash_login, login shell时读取并执行
- ~/.profile
- ~/.bash_logout,  login shell退出时读取并执行
- ~/.shrc
- ~/.zshrc

#### 环境变量

- PS1
    - ${debian_chroot:+($debian_chroot)}\u@\h:\w\$
- BASH   /bin/bash
- SHELL  /bin/bash
- SHLVL  终端嵌套深度？
- HOME
- PWD
- TERM  
    - cygwin
    - dumb

### login shell



login shell启动时首先读取/etc/profile全局配置，然后依次查找~/.bash_profile、~/.bash_login、~/.profile三个配置文件，并且读取第一个找到的并且可读的文件。login shell退出时读取并执行~/.bash_logout中的命令。

1. /etc/profile
2. ~/.bash_profile、~/.bash_login、~/.profile



一般~/.bash_profile 会调用~/.bashrc脚本。

#### /etc/profile

wsl

```bash
# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))
# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).

if [ "${PS1-}" ]; then
  if [ "${BASH-}" ] && [ "$BASH" != "/bin/sh" ]; then
    # The file bash.bashrc already sets the default PS1.
    # PS1='\h:\w\$ '
    if [ -f /etc/bash.bashrc ]; then
      . /etc/bash.bashrc
    fi
  else
    if [ "`id -u`" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi
  fi
fi

if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do
    if [ -r $i ]; then
      . $i
    fi
  done
  unset i
fi
```



#### ~/.bash_profile

git bash

```bash
# generated by Git for Windows
test -f ~/.profile && . ~/.profile
test -f ~/.bashrc && . ~/.bashrc
```



#### ~/.profile

wsl

```bash
# ~/.profile: executed by Bourne-compatible login shells.

if [ "$BASH" ]; then
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
fi

mesg n || true
```





### non-login shell

non-login shell就是取得bash不需要重复登录，就像你在桌面视图中用ctrl+alt+T启动的shell输入窗口就是non-login shell。还有就是你在shell窗口直接su切换的用户，都属于non-login shell。

non-login shell只会读取/etc/bash.bashrc, ~/.bashrc文件，具体步骤和上边一样。

如果我们修改了我们的~/.bashrc如果想让配置立即生效，我们只需要用source命令。例如：`source ~/.bashrc`



交互式的non-login shell启动时读取~/.bashrc资源文件。非交互式的non-login shell不读取上述所有配置文件，而是查找环境变量`BASH_ENV`，读取并执行BASH_ENV指向的文件中的命令。



### interactive shell 

interactive shell 是交互式shell, 顾名思义就是用来和用户交互的, 提供了命令提示符可以输入命令.

###  non-interactive shell

non-interactive shell 则一般是通过 `bash -c “CMD”` 来执行的bash.

**该模式下不会执行任何的 rc 文件**



### bashrc 和 profile 的区别

看了之前那么多种状态组合, 最关键的问题是, 究竟 bashrc 和 profile 有什么区别呢?

#### profile

其实看名字就能了解大概了, profile 是某个用户唯一的用来设置环境变量的地方, 因为用户可以有多个 shell 比如 bash, sh, zsh 之类的, 但像环境变量这种其实只需要在统一的一个地方初始化就可以了, 而这就是 profile.

#### bashrc

bashrc 也是看名字就知道, 是专门用来给 bash 做初始化的比如用来初始化 bash 的设置, bash 的代码补全, bash 的别名, bash 的颜色. 以此类推也就还会有 shrc, zshrc 这样的文件存在了, 只是 bash 太常用了而已.

### example

### SSH login, `sudo su - [USER]` 或者 mac 下开启终端

ssh 登入和 `su -` 是典型的 interactive login shell, 所以会有 PS1 变量, 并且会执行



### 在命令提示符状态下输入 `bash` 或者 ubuntu 默认设置下打开终端

这样开启的是 interactive no-login shell, 所以会有 PS1 变量, 只会执行bashrc



##### 通过 `bash -c “CMD”` 或者 `bash BASHFILE` 命令执行的 shell

这些命令什么都不会执行, 也就是不设置 PS1 变量, 不执行任何 RC 文件



### 最特殊! 通过`ssh server  “CMD”` 执行的命令 或 通过程序执行远程的命令

这是最特殊的一种模式, 理论上应该既是 非交互 也是 非登入的, 但是实际上他不会设置 PS1, 但是还会执行~/.bashrc



### sh

如果使用命令"sh"调用bash，bash会尽可能保持向后兼容。作为login shell启动时，bash依次读取/etc/profile和~/.profile配置文件。作为non-login shell启动时，bash读取环境变量ENV指向的文件。
通常我们要定制一些配置时，将配置写在~/.bashrc中，然后在~/.bash_profile中读取~/.bashrc，这样可以保证login shell和交互式non-login shell得到相同的配置。至于/etc/profile就不要轻易去改啦，毕竟会影响系统全局的配置。

## demo



下面做个简单的实验来验证上面的描述。在~/.bash_profile中设置如下变量：

```
lshell="login shell will see this message"
```

分别启动一个交互式non-login shell和交互式login shell，查看lshell变量：



```bash
[sw@gentoo ~]$ bash
[sw@gentoo ~]$ echo $lshell

[sw@gentoo ~]$ exit
exit
[sw@gentoo ~]$ bash --login
[sw@gentoo ~]$ echo $lshell
login shell will see this message
[sw@gentoo ~]$ exit
logout
```









分类: [centos](https://www.cnblogs.com/webnote/category/862365.html)