# [交叉编译中的build、host和target](https://www.cnblogs.com/electron/p/3548039.html)



**build、host和target**

   在交叉编译中比较常见的一些参数就是build、host和target了，正确的理解这三者的含义对于交叉编译是非常重要的，下面就此进行解释
　　--build=编译该软件所使用的平台
　　--host=该软件将运行的平台
　　--target=该软件所处理的目标平台

　　我们以 gcc 为例子来 讲解 这三者的作用
　　在gcc编译中我们使用
　　./configure --build=编译平台　--host=运行平台　--target=目标平台　[各种编译参数]
　　来配置gcc的源代码，以让其编译出我们需要的gcc编译器。

　　那么在这组配置参数中：
　　　　--build：
　    　　表示目前我们正在运行的平台名称是什么，如果当前我们是在intel的pentium机器中编译该系统，那么我们的--build就可能是 i686-pc-linux-gnu，当然如果我们在其它种类的机器上编译那么这个build就应该是那个机器所对应的平台名称。
　　　　　该参数在不指定的情况下将自动尝试猜测目前平台的名称。

　　　　--host：
　 　 　　表示我们把这个编译好的gcc在什么样的平台下运行，在交叉编译过程中这个需要我们来指定，因为机器自己是不能知道我们心里是怎么想的，那 么我们可以明确的告诉它，我们要做出来的程序是运行在“龙芯”上的，但是目前还不能直接指定“龙芯”，因此我们这里指定为mips64el- unknown-linux-gnu（如果你省点事情那么就用这个名字好了，如果你想用个有个性的名字，那么请你想明白它的含义再动手，并且做好后面的过 程需要多出一些手续的麻烦的心理准备）。
　　　　--host也可以不指定，那么host将自动使用build来定义自己，不过那将不再是交叉编译。
　　　　注：--build和--host在不同的时候就被配置文件认定为交叉编译方式。

　　　　--target：
　　　　　该参数的目的是让配置程序知道这个软件被编译后使用来处理什么平台上的文件的。
　　　　　target这个参数只有在为数不多的几个包中有用处，虽然在./configure --help中经常能看到该参数，但实际上绝大多数软件包都是不需要该参数的。
　 　　　从这个参数的含义来看，说明其处理的目标只有在不同平台下表现为不同的时候才有作用，而这些文件通常都跟目标平台 的指令系统直接或间接有关：比如可执行文件，对于不同平台下使用的可执行文件的编码可以是完全不同的，因此必须使用 对应能处理该编码的程序才能正确处理，而如果错误的使用则可能导致程序错误或者破坏文件，对于这样要处理不同平台下会 出现不同编码的软件，我们就应当对它指定目标平台，以免另其错误处理；而对于文本文件，对于不同的平台同样的内容表达的 含义都是相同的，因此我们不需要专门针对平台来处理，这样的软件我们就可以不必对它指定需要处理的平台了。

​    我们来总结一下：
　　　　build：自动测试在用平台名称，若无法检测出来则需要指定。
　　　　host：若无指定，自动使用build的结果。
　　　　build和host相同时表示本地编译，若不相同则表示交叉编译。
　　　　target：表示需要处理的目标平台名称，若无指定使用host相同名称，gcc、binutils等于平台指令相关软件有此参数，多数软件此参数无用处。

​    综合的例子：
​        我们需要在x86下编译一个运行于arm上的编译器gcc，这个gcc产生mips平台的目标代码。那么我们的配置方式是：
​        --build=x86   --host=arm    --target=mips
​        （仅是示意，方便理解，具体写法请google）



分类: [Linux](https://www.cnblogs.com/electron/category/537475.html), [C语言](https://www.cnblogs.com/electron/category/537476.html)