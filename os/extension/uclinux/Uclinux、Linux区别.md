# Uclinux、Linux区别



[StudyTaoo](https://blog.csdn.net/linux12121) 2018-09-24 23:48:48 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png) 3468 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png) 收藏 4

分类专栏： [Linux](https://blog.csdn.net/linux12121/category_7015304.html) 文章标签： [Uclinux](https://www.csdn.net/tags/MtjaQg5sNTk3My1ibG9n.html) [linux](https://www.csdn.net/tags/MtjaQg5sMDY0MC1ibG9n.html) [区别](https://www.csdn.net/tags/MtTaEg0sNDkyNDctYmxvZwO0O0OO0O0O.html)



### 一、名字含义：

在uClinux这个英文单词中u表示Micro，小的意思，C表示Control，控制的意思， 所以uClinux就是**Micro-Control-Linux**，字面上的理解就是"针对微控制领域而设计的Linux系统"。 

### 二、ucLinux与linux区别？

- 没有虚存管理
- 不能运行时增加进程栈
- 不支持分页
- 可执行程序不是elf,   而是flat
- 不能用fork,   而是用vfork
- RAMDISK  

uClinux是针对控制领域的嵌入式linux操作系统，它从Linux 2.0/2.4内核派生而来，沿袭了主流Linux的绝大部分特性。**适合不具备内存管理单元(MMU)的微处理器/微控制器。没有MMU支持是 uClinux与主流Linux的基本差异。** 

对uCLinux 来说，其设计针对没有MMU的处理器，不能使用处理器的虚拟内存管理技术。uCLinux仍然采用存储器的分页管理，系统在启动时把实际存储器进行分页。 在加载应用程序时程序分页加载。但是由于没有MMU管理，所以实际上uCLinux采用实存储器管理策略。uCLinux系统对于内存的访问是直接的，所 有程序中访问的地址都是实际的物理地址。操作系统对内存空间没有保护，各个进程实际上共享一个运行空间。一个进程在执行前，系统必须为进程分配足够的连续 地址空间，然后全部载入主存储器的连续空间中。  

### **2.1、内存保护**

没有内存保护(Memory Protection)的操作会导致这样的结果：

即使由无特权的进程来调用一个无效指针，也会触发一个地址错误，并潜在地引起程序崩溃，甚至导致系统的挂 起。显然，在这样的系统上运行的代码必须仔细编程，并深入测试来确保健壮性和安全。

对于普通的Linux来说，需要运行不同的用户程序，如果没有内存保护将大大降低系统的安全性和可*性；然而对于嵌入式uClinux系统而言，由 于所运行的程序往往是在出厂前已经固化的，不存在危害系统安全的程序侵入的隐患，因此只要应用程序经过较完整的测试，出现问题的概率就可以控制在有限的范 围内。  

### 2.2、虚拟内存

没有虚拟内存(Virtual Memory)主要导致下面几个后果：

首先，由内核所加载的进程必须能够独立运行，与它们在内存中的位置无关。 实现这一目标的第一种办法是一旦程序被加载到RAM中，那么程序的基准地址 就“固定”下来；另一种办法是产生只使用相对寻址的代码（称为“位置无关代码”，Position Independent Code，简称PIC）。uClinux对这两种模式都支持。

其次，要解决在扁平(flat)的内存模型中的内存分配和释放问题。非常动态的内存分配会造成内存碎片，并可能耗尽系统的资源。对于使用了动态内存 分配的那些应用程序来说，增强健壮性的一种办法是用预分配缓冲区池(Preallocated buffer pool)的办法来取代malloc()调用。

由于uclinux中不使用虚拟内存，进出内存的页面交换也没有实现，因为不能保证页面会被加载到RAM中的同样位置。在普通计算机上，操作系统允 许应用程序使用比物理内存(RAM)更大的内存空间，这往往是通过在硬盘上设立交换分区来实现的。但是，在嵌入式系统中，通常都用FLASH存储器来代替 硬盘，很难高效地实现内存页面交换的存取，因此，对运行的应用程序都限制其可分配空间不大于系统的RAM空间。  

注意：多任务并没有受影响。哪些旧式的、广泛使用fork()的网络后台程序（daemon）的确是需要修改的。由于子进程运行在和父进程同样的地 址空间内，在一些情况下，也需要修改两个进程的行为。

很多现代的程序依赖子进程来执行基本任务，使得即时在进程负载很重时，系统仍可以保持一种“可交互”的状态，这些程序可能需要实质上的修改来在 uClinux下完成同样的任务。如果一个关键的应用程序非常依赖这样的结构，那就不得不对它重新编写了。

假设有一个简单的网络后台程序(daemon)，大量使用了fork()。这个daemon总监听一个知名端口（或套接字）等待网络客户端来连接。 当客户端连接时，这个daemon给它一个新的连接信息（新的socket编号），并调用fork()。子进程接下来就会和客户端在新的socket上进 行连接，而父进程被释放，可以继续监听新的连接。

uClinux 既没有自动生长的堆栈，也没有brk()函数，这样，用户空间的程序必须使用mmap() 命令来分配内存。为了方便，在uclinux的C语言库中所实现的malloc()实质上就是一个mmap()。在编译时，可以指定程序的堆栈大小。

最后，uClinux目标板处理器缺乏内存管理的硬件单元，使得Linux的系统接口需要作些改变。有可能最大的不同就是没有fork()和 brk()系统调用。调用fork()将复制出进程来创建一个子进程。在Linux下，fork()是使用copy-on-write页面来实现的。由于 没有MMU， uclinux不能完整、可*地复制一个进程，也没有对copy-on-write的存取。为了弥补这一缺陷，uClinux实现了vfork()，当父 进程调用vfork()来创建子进程时，两个进程共享它们的全部内存空间，包括堆栈。子进程要么代替父进程执行（此时父进程已经sleep）直到子进程调 用exitI()退出，要么调用exec()执行一个新的进程，这个时候将产生可执行文件的加载。即使这个进程只是父进程的拷贝，这个过程也不能避免。当 子进程执行exit()或exec()后，子进程使用wakeup把父进程唤醒，父进程继续往下执行。  

通用架构的内核变化:

在uCLinux的发布中,/linux/mmnommu目录取代了/linux/mm目录.前者是修改后的内存管理子系统 被修改,去除了MMU的硬件依赖,并在内核软件自身提供基本的内存管理函数.

很多子系统需要重新修改,添加或重写.内核和用户内存分配及释放进程 必须重新实现,对透明交互/页面调度的支持也被去除. 内核中,加入了支持"内核无关代码(PIC)"的程序支持模块,并使用了新的二进制目标代码 格式,称扁平格式,用来支持PIC(有非常紧凑的头部).

内核也提供了支持ELF格式的程序加载模块,用来支持使用固定基准地址的可执行程序.两种模式各 有利弊,传统的PIC运行快,代码紧凑,但有代码大小限制.例如Motorola 68K架构的16位相对跳转限制了PIC程序不能超过32KB大小,而采用运行期固定基准地址的方法上市的程序代码没有了大小限制,但当陈旭被内核加载后 导致了较多的系统开销.对于内核开发者来说,uCLinux基本上与Linux没有区别,唯一的区别就是不能利用MMU提供的内存管理.实际上这对内核并 没有影响. Linux下所有标准的可执行文件的格式在uCLinux并不被支持,因为这些格式也用到了虚拟内存的一些功能.uCLinux使用的 是另外一种扁平格式.扁平格式是一种简洁高效的可执行文件格式,它值包含可执行的代码和数据,还有一些把可执行文件加载到内存任意位置所需要的可重定位的 信息.  

总结：在应用程序移植到uClinux， 以及自己写代码的过程中，我们将始终围绕这几个特性来做：

1、在configure时， 如果可能则需要在configure时，选上—disable-shared和—enable-static.

2、将 源代码中所有出现的fork()改成vfork();

3、在Makefile中 的交叉编译器和编译选项，链接选项里加上-Wl,-elf2flt。 尽管这只是一个链接选项，但我 还是小心地在LDFLAGS和CFLAGS， 甚至在CC中指定了该选项。    

改选项是将ELF格式转换成uClinux所 能识别的FLAT格式。在做这个转换过程，我们是不能对ELF文 件使用strip去除一些信息，更有甚者不能使用-O2 选 项来优化代码。因为去掉的某些信息可能导致最终生成的FLAT格式文件运行出现问题。   