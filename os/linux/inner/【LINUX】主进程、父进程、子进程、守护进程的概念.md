# [【LINUX】主进程、父进程、子进程、守护进程的概念](https://www.cnblogs.com/huxiaoyun90/p/4843260.html)



## 一、摘要

> 详解父进程、子进程、守护进程的区别，例子稍候补充

1. 主进程
   程序执行的入口，可以理解为常用的main 函数

2. 父进程
   对于子进程而言， 子进程的创造者，可有多个子进程。 任何进程都有父进程，追根溯源是系统启动程序。对于我们一般写的程序，主进程是最初始的父进程。

3. 子进程
   对于父进程而言， 父进程创建的进程， 子进程只能对应一个父进程。

4. 守护进程
   我们常言的daemon 进程，是子进程的一种状态，标记子进程与父进程同死。如果没有标记daemon ， 则杀死父进程，与子进程的运行状态没有半分影响。

5. 僵尸进程
   因为某些子进程没有设置daemon 属性，如果杀死父进程，其子进程将会变成“僵尸进程”。僵尸进程的父进程将成为init 进程的子进程。

   > 为避免僵尸进程，一般：
   >
   > - 设置父进程的SIGCHLD信号处理函数为 SIG_IGN (忽略信号)
   > - fork 两次并杀次以及子进程，令二级子进程成为僵尸进程，成为init子进程，并被清理



## 守护进程

守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。

内核守护进程的父进程并非是 init进程。对于用户层守护进程， 因为它真正的父进程在 fork 出子进程后就先于子进程 exit 退出了，所以它是一个由 init 继承的孤儿进程。成为了孤儿进程，可以延长它的生成周期。



在对应的父进程结束执行后，进程就会变成孤儿进程，但之后会立即由init进程“收养”为其子进程。

某一子进程终止执行后，若其父进程未提前调用wait，则内核会持续保留子进程的退出状态等信息，以使父进程可以wait获取之。而因为在这种情况下，子进程虽已终止，但仍在消耗系统资源，所以其亦称僵尸进程。wait常于SIGCHLD信号的处理函数中调用。

**创建守护进程的过程：**  

1. 调用fork创建子进程。父进程终止，让子进程在后台继续执行。
2. 子进程调用setsid产生新会话期并失去控制终端调用setsid()使子进程进程成为新会话组长和新的进程组长，同时失去控制终端。
3. 忽略SIGHUP信号。会话组长进程终止会向其他进程发该信号，造成其他进程终止。
4. 调用fork再创建子进程。子进程终止，子子进程继续执行，由于子子进程不再是会话组长，从而禁止进程重新打开控制终端。
5. 改变当前工作目录为根目录。一般将工作目录改变到根目录，这样进程的启动目录也可以被卸掉。
6. 关闭打开的文件描述符，打开一个空设备，并复制到标准输出和标准错误上。 避免调用的一些库函数依然向屏幕输出信息。
7. 重设文件创建掩码清除从父进程那里继承来的文件创建掩码，设为0。
8. 用openlog函数建立与syslogd的连接。



守护进程与后台运行程序（即加＆启动的程序）的区别。
最大的区别有几点：
(a)守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端，在终端未关闭前还是会往终端输出结果
(b)守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以nohup command & 格式运行才能避免影响
(c)守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没改变。