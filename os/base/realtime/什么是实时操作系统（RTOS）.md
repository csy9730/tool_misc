# 什么是实时操作系统（RTOS）

[北极](https://www.zhihu.com/people/bei-ji-85)



中央处理器 (CPU)等 3 个话题下的优秀答主



435 人赞同了该文章

在维基百科上，实时操作系统（RTOS）的定义如下：

> **实时操作系统**（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。
> 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。

[https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fzh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)

经常跟实时操作系统一起讲的，还有**嵌入式操作系统**这个概念，但实际上这是完全不同的两种东西，虽然大多数实时操作系统都是嵌入式操作系统，但嵌入式操作系统并不全都是实时的。

对于实时操作系统有一些常见的误区，比如：速度快，吞吐量大，代码精简，代码规模小等等。其实这些都不算是实时操作系统的特性，别的操作系统也可以做到。

只有“**实时性**”才是RTOS的最大特征，其它的都不算是。

维基百科上关于实时性的定义：

> 实时运算（Real-time computing）是计算机科学中对受到“实时约束”的计算机硬件和计算机软件系统的研究，实时约束像是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格的时间限制内响应。

[https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97)

实时操作系统中都要包含一个**实时任务调度器**，这个任务调度器与其它操作系统的最大不同是强调：严格按照优先级来分配CPU时间，并且时间片轮转**不是**实时调度器的一个必选项。

提出实时操作系统的概念，可以至少解决两个问题：一个是早期的CPU任务切换的开销太大，实时调度器可以避免任务频繁切换导致CPU时间的浪费；另一个是在一些特殊的应用场景中，必须要保证重要的任务优先被执行。

在这样的背景下，实时操作系统就被设计出来了，典型的实时操作系统有VxWorks，RT-Thread，uCOS，QNX，WinCE等。

实时任务调度器是实时操作系统的一个必选项，但不代表只要设计出来一个实时调度器就足够了。事实上设计一个实时调度内核并不是一个多么复杂的任务，实时操作系统的特性是在整个操作系统的设计思路上都要时刻关注实时性。

这些设计思路包括：

**1. 实时的消息、事件处理机制。**

常规的操作系统中，消息队列都是按照FIFO（先进先出）的方式进行调度，如果有多个接受者，那么接受者也是按照FIFO的原则接受消息（数据），但实时操作系统会提供基于优先级的处理方式：两个任务优先级是分别是10和20，同时等待一个信号量，如果按照优先级方式处理，则优先级为10的任务会优先收到信号量。

**2. 提供内核级的优先级翻转处理方式**

实时操作系统调度器最经常遇到的问题就是优先级翻转，因此对于类似信号量一类的API，都能提供抑止优先级翻转的机制，防止操作系统死锁。

**3. 减少粗粒度的锁和长期关中断的使用**

这里的锁主要是指自旋锁(spinlock)一类会影响中断的锁，也包括任何关中断的操作。在Windows和Linux的驱动中，为了同步的需要，可能会长期关闭中断，这里的长期可能是毫秒到百微秒级。但实时操作系统通常不允许长期关中断。

对于非实时操作系统来说，如果收到一个外部中断，那么操作系统在处理中断的整个过程中可能会一直关中断。但实时操作系统的通常做法是把中断作为一个事件通告给另外一个任务，interrupt handler在处理完关键数据以后，立即打开中断，驱动的中断处理程序以一个高优先级任务的方式继续执行。

**4. 系统级的服务也要保证实时性**

对于一些系统级的服务，比如文件系统操作，非实时系统会缓存用户请求，并不直接把数据写入设备，或者建立一系列的线程池，分发文件系统请求。但实时系统中允许高优先级的任务优先写入数据，在文件系统提供服务的整个过程中，高优先级的请求被优先处理，这种高优先级策略直到操作完成。

这种设计实际上会牺牲性能，但实时系统强调的是整个系统层面的实时性，而不是某一个点（比如内核）的实时性，所以系统服务也要实时。

由于应用场景的差异，会出现有些用户需要实时性的驱动，有些用户需要高性能的驱动，因此实时操作系统实际上要提供多种形式的配置以满足不同实时性需求的用户。

**5. 避免提供实时性不确定的API**

多数实时操作系统都不支持虚拟内存（page file/swap area），主要原因是缺页中断（page fault）会导致任务调度的不确定性增加。实时操作系统很多都支持分页，但很少会使用虚拟内存，因为一次缺页中断的开销十分巨大（通常都是毫秒级），波及的代码很多，导致用户程序执行的不确定性增加。

实时操作系统的确定性是一个很重要的指标，在某些极端场景下，甚至会禁用动态内存分配（malloc/free），来保证系统不受到动态的任务变化的干扰。

**6. 提供针对实时系统调度的专用API**

比如ARINC 653标准中就针对任务调度等作出了一系列的规定，同时定义了特定的API接口和API行为，这些API不同于POSIX API，如果实时系统要在航空设备上使用，就可能需要满足ARINC 653的规范。

**7. 降低系统抖动**

由于关中断等原因，通常情况下，操作系统的调度器不会太精确的产生周期性的调度，比如x86早期的默认60的时钟周期（clock rate），抖动范围可能在15-17ms之间。但一个设计优秀的实时操作系统能把调度器的抖动降低到微秒甚至百纳秒一级，在像x86这种天生抖动就很大的架构上，降低系统抖动尤其重要。

**8. 针对实时性设计的SMP和虚拟化技术**

SMP（多核）场景的实时调度是很困难的，这里还涉及到任务核间迁移的开销。针对SMP场景，多数实时操作系统的设计都不算十分优秀，但比起普通操作系统来说，其实时性已经好很多了。

同时实时操作系统的虚拟化能从hypervisor层面上提供虚拟机级别的实时调度，虚拟机上可以是另外一个实时系统，也可以是一个非实时系统。

\-------------------------------------------

从以上的特点上看，前面提到的常见的错误认识：速度快，吞吐量大，代码精简，代码规模小，都不是实时操作系统的特征：

非实时操作系统也可以很快，实时操作系统也可能很慢；
通常来说实时操作系统的吞吐量会大一些，但非实时系统也可以做到吞吐量更大；
实时操作系统一般都比非实时操作系统要小，但规模大的实时操作系统也是存在的；
而且由于可能需要针对不同用户提供不同等级的实时服务，实时操作系统可能并不是那么精简的……

由于设备性能的发展，原来很多实时性要求高的场景，已经切换到普通的操作系统了。Linux在嵌入式设备上的推广，使用实时操作系统的很多设备已经改用Linux了，因为硬件性能的提升会让系统延迟降低到一个用户可以接受的程度。

但在某些特定的场景下，比如工业自动化、机器人、航空航天、军工领域等，仍然对实时操作系统有需求，并且应该会长期存在。

同时，由于实时操作系统的特性，它并不是一个应用场景广泛的系统，一些人认为学嵌入式就是学实时操作系统，这种认识其实是不正确的，现在嵌入式开发，不一定需要在实时操作系统下完成。





编辑于 2020-06-02

实时操作系统

维基百科

Linux

赞同 435

45 条评论

分享