# 并行程序设计-哲学家就餐问题

[![img](https://upload.jianshu.io/users/upload_avatars/25989339/4c5945b6-426a-44ea-995f-04e69214368e?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/7856f577f69e)

[pshawn](https://www.jianshu.com/u/7856f577f69e)关注

0.3882021.03.09 01:21:17字数 1,549阅读 529

### 一、问题描述

五个沉默的哲学家围坐在一个圆桌旁，桌上放着几碗意大利面。叉子被放置在每一对相邻的哲学家之间。每个哲学家必须交替地思考和进餐。然而，哲学家只能在有左右叉子的情况下才能吃意大利面。每个叉子只能被一个哲学家拿着，所以一个哲学家只能在没有被另一个哲学家使用的情况下使用它。当一位哲学家吃完饭后，他们需要把两把叉子放下，这样其他人就可以享用这些叉子了。哲学家只能在他们有空的时候拿右手或左手的叉子，在拿两副叉子之前他们不能开始吃东西。每个哲学家有3种状态{thinking，trying，eating}。吃东西不受剩余的意大利面或胃空间的限制，假设有一个无限的供给和一个无限的需求。问题是如何设计一种行为准则(并发算法)，以确保没有哲学家挨饿；也就是说，每一种都可以永远在吃饭和思考之间交替，假设没有一个哲学家可以知道其他人什么时候可能想吃饭或思考。

### 二、概要设计

编程语言使用IEEE Posix Thread库与C语言实现。本次实验采用多线程解决哲学家就餐问题。由于哲学家的刀叉是共享变量，所以使用信号量实现互斥。线程个数(-n)即为哲学家个数，同时为每个叉子定义对应的信号量。每个哲学家在试图使用餐叉的时候需要先进行sem_wait，当拿到两个餐叉后，哲学家就能eating，eating完之后使用sem_post解锁这两个餐叉。

### 三、避免死锁的策略

#### method1：

**解法**：允许最多 thread_count - 1 个哲学家同时进入餐厅尝试获取餐叉，剩下的一个哲学家只有在有人吃完出去的时候才进去。这样就能保证起码有一个人能够同时获得两个餐叉，从而eating，避免大家都处于trying的状态。这种解法也能理解为引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉。当同时有 thread_count - 1 个餐叉被请求时，若是其他哲学家请求最后一个餐叉，服务生会让他等待。

**实现方法**：增加一个信号量sem_waiter，其初始值为thread_count - 1，每个线程trying时会先sem_wait(&sem_waiter)，在请求到两个餐叉并且eating后，再解锁两个叉子并使用sem_post(&sem_waiter)通知服务生。

#### method2：

**解法**：使用非对称解决方案。即单号的哲学家先拿起左边的叉子，接着右边的叉子；而双号的哲学家先拿起右边的叉子，接着左边的叉子。

**实现方法**：获取当前线程的编号，如果是奇数号线程就先请求左边的餐叉，然后请求右边的餐叉；如果是偶数好线程就先请求右边的餐叉，然后请求左边的餐叉。

### 四、实验

编译：gcc -g -Wall -o philosopher philosopher.c -lpthread

运行：./philosopher -normal n 哲学家个数 ./philosopher -method1 n 哲学家个数 ./philosopher -method2 n 哲学家个数

### 五、分析

#### 1. -normal

正常状态下哲学家遵守以下规则：

- 哲学家在左边的叉子可用（没有其他人拿起）之前处于思考状态。如果左边的叉子可用，就拿起来。

- 哲学家等待右边的叉子可用。如果右边的叉子可用，就拿起来。

- 如果两个叉子都已经拿起来，开始吃意大利面，每次吃面都花费同样的时间。

- 吃完后先放下左边的叉子。

- 然后放下右边的叉子。

- 开始思考（进入一个循环）

  但这种解法是失败的，当每个哲学家都拿起左侧的叉子，等待右侧的叉子可用时，就会进入死锁状态，每个哲学家将永远都在等待（右边的）另一个哲学家放下叉子。

#### 2. -method1

至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。以下将sem_waiter作为信号量，只允许thread_count - 1个哲学家同时进入餐厅就餐，这样就能保证至少有一个哲学家可以就餐，而申请进入餐厅的哲学家进入sem_waiter的等待队列，根据FIFO的原则，总会进入到餐厅就餐，因此不会出现饿死和死锁的现象。

#### 3.-method2

规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。而申请不到的哲学家进入阻塞等待队列，根FIFO原则，则先申请的哲学家会较先可以吃饭，因此不会出现饿死的哲学家。

### 六、源代码



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <string.h>

long thread_count;   //线程个数，即哲学家个数
sem_t *sem_fork;    //定义一组餐叉的信号量
sem_t sem_waiter;   //method1中用到的信号量，用于确保至少一个人不能进餐

void *Philo_normal(void *rank);    //一般方法，会陷入死锁
void *Philo_method1(void *rank);   //方法1，服务生方法
void *Philo_method2(void *rank);   //方法2，非对称解决方案

int main(int argc, char *argv[])
{
 long thread;
 pthread_t *thread_handles;
 //获取线程个数，本实验中也代表哲学家人数
 thread_count = strtol(argv[2], NULL, 10);

 thread_handles = malloc (thread_count * sizeof(pthread_t));
 sem_fork = malloc (thread_count * sizeof(sem_t));

 //初始化waiter信号量
 sem_init(&sem_waiter, 0, thread_count-1);

 //初始化所有叉子信号量
 for(long i = 0; i < thread_count; i ++ ){
 sem_init(&sem_fork[i], 0, 1); 
 }

 //创建线程
 for(thread = 0; thread < thread_count; thread++ ){ 
 //根据参数进入相应的处理函数
 if(strcmp(argv[1], "-normal") == 0) 
 pthread_create(&thread_handles[thread], NULL, Philo_normal, (void *)thread);
 else if(strcmp(argv[1], "-method1") == 0)
 pthread_create(&thread_handles[thread], NULL, Philo_method1, (void *)thread);
 else if(strcmp(argv[1], "-method2") == 0)
 pthread_create(&thread_handles[thread], NULL, Philo_method2, (void *)thread);
 }

 //停止线程
 for(thread = 0; thread < thread_count; thread ++ )
 pthread_join(thread_handles[thread], NULL);

 //销毁餐叉信号量
 for(long i = 0; i < thread_count; i ++ ){
 sem_destroy(&sem_fork[i]);
 }

 //销毁服务生信号量
 sem_destroy(&sem_waiter); 

 //释放空间
 free(thread_handles);
 free(sem_fork);
 return 0;
}

//一般方法，会陷入死锁
void *Philo_normal(void *rank)
{
 long my_rank = (long)rank;
 long my_left_fork, my_right_fork;     //表示每个哲学家左右的叉子
 my_left_fork = my_rank;
 my_right_fork = (my_rank + 1) % thread_count;
 while(1){
 printf("Philosopher %ld is thinking\n", my_rank);
 //把进程挂起一段时间， 单位是微秒（百万分之一秒）；
 //usleep( (rand()%91 + 10)*1000 ); 
 //本来应该随机挂起10-100ms,这里为了更快的检测死锁，将时间改为固定的50ms
 usleep(50);

 printf("Philosopher %ld is trying\n", my_rank);
 sem_wait(&sem_fork[my_left_fork]);
 sem_wait(&sem_fork[my_right_fork]);

 printf("Philosopher %ld is eating\n", my_rank);

 //usleep( (rand()%91 + 10)*1000 ); 
 usleep(100);

 sem_post(&sem_fork[my_left_fork]);
 sem_post(&sem_fork[my_right_fork]);
 }
}

//方法1，服务生方法
void *Philo_method1(void *rank)
{
 long my_rank = (long)rank;
 //哲学家左右的叉子
 long my_left_fork, my_right_fork;
 my_left_fork = my_rank;
 my_right_fork = (my_rank + 1) % thread_count;

 while(1){
 printf("Philosopher %ld is thinking\n", my_rank);
 //usleep( (rand()%91 + 10)*1000 );     //think 10-100 ms
 usleep(50);

 printf("Philosopher %ld is trying\n", my_rank);
 //添加一个waiter信号量确保每个时刻最少一个人没有进去就餐
 sem_wait(&sem_waiter);
 sem_wait(&sem_fork[my_left_fork]);
 sem_wait(&sem_fork[my_right_fork]);

 printf("Philosopher %ld is eating\n", my_rank);
 //usleep( (rand()%91 + 10)*1000 );    //eating 10-100 ms
 usleep(100);

 sem_post(&sem_fork[my_left_fork]);
 sem_post(&sem_fork[my_right_fork]);

 sem_post(&sem_waiter);
 }
}

//方法2，非对称解决方案
void *Philo_method2(void *rank)
{
 long my_rank = (long)rank;
 //表示哲学家左右的叉子
 long my_left_fork, my_right_fork;
 //奇数先左叉后右叉，偶数先右叉后左叉
 if(my_rank % 2 == 1){
 my_left_fork = (my_rank + 1) % thread_count;
 my_right_fork = my_rank;
 }
 else{
 my_left_fork = my_rank;
 my_right_fork = (my_rank + 1) % thread_count;
 }
 while(1){
 printf("Philosopher %ld is thinking\n", my_rank);
 //usleep( (rand()%91 + 10)*1000 );     //think 10-100 ms
 usleep(50);

 printf("Philosopher %ld is trying\n", my_rank);
 sem_wait(&sem_fork[my_left_fork]);
 sem_wait(&sem_fork[my_right_fork]);

 printf("Philosopher %ld is eating\n", my_rank);
 //usleep( (rand()%91 + 10)*1000 );    //eating 10-100 ms
 usleep(100);

 sem_post(&sem_fork[my_left_fork]);
 sem_post(&sem_fork[my_right_fork]);
 }
}
```

### 七、参考

维基百科-Dining_philosophers_problem：[http://en.wikipedia.org/wiki/Dining_philosophers_problem](https://links.jianshu.com/go?to=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDining_philosophers_problem)

哲学家就餐问题解释：[https://wenku.baidu.com/view/df1a6a4e2b160b4e767fcf4c.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwenku.baidu.com%2Fview%2Fdf1a6a4e2b160b4e767fcf4c.html)