# 并发和并行
## 并发

### 乱序
乱序并行为什么可以提速？

### 异步任务
异步任务的结果：
- finished：
	- success
	- fail，EXCEPTION
	- cancelled
- timeout
	- uncompleted


## 同步
线程同步机制
进程同步机制
### 并发
Concurrency

### 竞态
Race Conditions
### 临界区
Critical Sections
### 同步机制

锁、信号量、条件变量

- 锁
  - 自旋锁 spin lock
  - 读写锁 rwlock
- 信号量 semaphore
- 互斥体 mutex
- 条件变量 condition_variable
- 原子指令 atomic


### 乱序编译

乱序编译 （不访问外设寄存器下）对于单核单进程是透明的，但是对于多核多线程的情况下，就需要考虑乱序导致的问题。
#### volatile

#### 编译屏障

### 乱序执行
Out of Order Execution
### 多核同步
arm 处理器提供了：
- DMB 数据内存屏障
- DSB 数据同步屏障
- ISB 指令同步屏障


### 外设同步

linux内核编程中提供了：
- 读写屏障 mb()
- 读屏障 rmb()
- 写屏障 wmb()
- __iormb()
- __iowmb()


### 中断屏蔽

#### 原子指令
arm 处理器提供汇编指令：ldrex和strex

linux提供了原子操作
``` c
atomic_t v=ATOMIC_INIT(0)

atomic_read(atomic_t *v);
atomic_add(int i, atomic_t *v);

int atomic_inc_and_test(atomic_t *v);
```

原子操作只能用于整数加减法和位运算
#### 自旋锁
spin lock

自旋锁是同步等待过程，所以如果临界区太大，会降低系统性能。

自旋锁可能导致系统死锁

锁定区中不能调用进程调度函数。

#### 读写锁
读写锁 rwlock

读写自旋锁，颗粒度比自旋锁更小。支持一个写进程多读进程，支持多个读进程并行，不支持读写并行。

读写锁拥有读状态加锁、写状态加锁、不加锁三种状态。只有一个线程可以占有写状态的锁，但可以多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。

|当前状态|读操作|写操作|
|--|--|--|
|不加锁状态下|加读锁|加写锁|
|加读锁|支持|拒绝|
|加写锁|拒绝|拒绝|


读写锁三个特征：

- 多个读者可以同时进行读
- 写者必须互斥，只允许一个写者写，也不能读者写者同时进行
- 写者优先于读者，一旦有写者，则后续读者必须等待，唤醒时优先考虑写者
#### 顺序锁
seqlock
顺序锁是读写锁的一种优化。支持读写并行，此时读进程要重新读取新写入数据。
#### RCU
read-copy-update。

#### 递归锁
同一个线程可以多次获得该资源锁，别的线程必须等待该线程释放所有次数的锁才能获得。
#### 信号量
semaphore
#### 互斥量
mutex

共享资源的使用是互斥的，即一个线程获得资源的使用权后就会将改资源加锁，使用完后会将其解锁，所以在使用过程中有其它线程想要获取该资源的锁，那么它就会被阻塞陷入睡眠状态，直到该资源被解锁才会别唤醒，如果被阻塞的资源不止一个，那么它们都会被唤醒，但是获得资源使用权的是第一个被唤醒的线程，其它线程又陷入沉睡。
#### 完成量
completion
### 进程同步
### 线程同步

- 一个线程写，另一个线程读，简称一写一读
- 多个线程写，一个线程读，简称多写一读
- 一个线程写，多个线程读，简称一写多读。
- 多个线程写，多个线程读，简称多写多读。


#### 无锁编程

常用机制：
全局变量，共享指针机制，乒乓缓存，


#### 乒乓缓存
乒乓缓存是一种双缓存机制，用来加速同时存在I/O操作以及数据处理操作的设备。一个缓存用来保存旧版本的数据供读设备读取，与此同时，另一个缓存保存写设备产生的新版本数据。当新数据完成时，读设备和写设备将会交换两个缓存，双缓存机制将会提高设备的吞吐量，最终有助于避免瓶颈的产生。

> A Ping Pong Buffer is a double buffer that is used to speed up a device that can overlap the I/O operation with the data processing operation. One buffer is used to hold a block of data so that a reader device will see a complete (old) version of the data, while in the other buffer a writer device is creating a new (partial) version of data. When the new block of data is complete and self consistent, the reader and the writer device will alternate the two buffers. As a result, the usage of double buffer increases the overall throughput of a device and helps to prevent eventual bottlenecks.


问题：
当写进程和读进程都空闲时，显然是最佳的交换时机。
但是如果，写进程进入空闲，读进程仍然忙碌，此时该如何处理？
如果强行交换缓存，此时读进程读取的无效数据如何处理？或者怎么处理读取的野指针或悬垂指针的问题

可以考虑先空闲的一方等待后空闲的一方，当双方都空闲时，交换缓存区

- **双缓冲区都在使用的状态（并发读写）**。大多数情况下，生产者和消费者都处于并发读写状态。假设生产者写入A，消费者读取B。在此状态下，生产者拥有锁La，消费者拥有锁Lb。由于两个缓冲区都处于独占状态，故每次读写缓冲区中的元素都不需要再进行加锁、解锁操作。
- **单个缓冲区空闲状态**。由于两个并发实体的速度会有差异，必然会出现一个缓冲区已经操作完，而另一个尚未操作完。假设生产者快于消费者，此时，当生产者把A写满时，生产者要先释放La（表示它已经不再操作A），然后尝试获取Lb。由于B还没有读空，Lb还被消费者持有，所以生产者进入等待状态。
- **缓冲区切换**。过了一段时间，消费者B也把B读完。此时，消费者也先释放Lb，然后尝试获取La。由于La刚才已经被生产者释放，所以消费者能立即拥有La并开始读取A的数据。而由于Lb被消费者释放，所以刚才等待的生产者会苏醒过来并拥有Lb，然后生产者继续往B写入数据。


#### 多缓冲
#### 环形缓冲区

双缓冲的扩展，变成了多缓冲（队列）。
多缓冲（队列），可以改成多缓冲（环）。这是就变成了环形缓冲区。
## misc

### 生产者消费者模型
生产者和消费者的速度一般不一致，为了使双方速度均衡，效率最大化，可以增大缓冲区的数量，增加生产者和消费者的数量，配平两者的数量来平衡处理速度。
