# IPC

simplex： 单工 单工（simplex）指仅能单方向传输数据。通信双方中，一方固定为发送端，一方则固定为接收端。信息只能沿一个方向传输，使用一根传输线。
half-duplex：半双工，许二台设备之间的双向资料传输，但不能同时进行。因此同一时间只允许一设备传送资料，若另一设备要传送资料，需等原来传送资料的设备传送完成后再处理。
Duplex：全双工 允许二台设备间同时进行双向资料传输。一般的电话、手机就是全双工的系统，因为在讲话时同时也可以听到对方的声音。
## IPC

进程间通信又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:
1. 低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)
2. 高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).


- 共享存储器
    - share memory
    - map
    - 文件（非主流方式）
- 消息
    - signal
    - message Queues
- 管道通信（pipe文件）
    - pipe
    - named pipe (FIFO)
- socket
    - unix socket
    - socket
- semaphore


- 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
- 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

## 同步


各个线程可以访问进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。数据之间的相互制约包括
1、直接制约关系，即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系
2、间接制约关系，即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步

### sync
- mutex lock
- condition
- semophore 信号量
- event 事件
- 临界区 Ccritical Section


锁操作的特点：
1. 程序中分布大量的同步操作，管理困难
2. 锁和资源是分离的，加锁和解锁是君子协定，不具有强约束性，程序员可能不做解锁直接访问资源。

#### 锁和资源

 当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。

所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。
因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。

锁和资源是分离的，锁是君子协定，并没有强制约束力。

#### mutex
PS:1、互斥量由于也有线程所有权的概念，故也只能进行线程间的资源互斥访问，不能由于线程同步；
2、由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了"遗弃"问题


### join 
#### join()
在很多情况下，主线程创建并启动子线程后，如果子线程要进行很耗时的计算，那么主线程将比子线程先结束，但是主线程需要子线程的计算的结果来进行自己下一步的计算，这时主线程就需要等待子线程，java中提供可join()方法解决这个问题。

join()方法的作用是：在当前线程A调用线程B的join()方法后，会让当前线程A阻塞，直到线程B的逻辑执行完成，A线程才会解除阻塞，然后继续执行自己的业务逻辑，这样做可以节省计算机中资源。

### ITC

线程间通信
- 共享存储 + 同步机制
	- 全局变量，配合上同步机制（加锁）。
    	- java中，volatile 作为同步机制
    	- mutex lock 作为同步机制
    	- wait/notify 作为同步机制
	- 共享内存，配合上同步机制(mutex lock)
- 管道(JVM提供的机制 )
    - Java提供了四个类来实现管道，分别是PipedReader、PipedWriter、PipedInputStream和PipedOutputStream
- 信号槽（QT框架提供的机制）
	- 同线程，直接调用
	- 跨线程，进入槽队列
- 使用消息实现通信(Windows)
    - 在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信


#### 管道流
管道输入/输出流的形式

管道流是是一种使用比较少的线程间通信方式，管道输入/输出流和普通文件输入/输出流或者网络输出/输出流不同之处在于，它主要用于线程之间的数据传输，传输的媒介为管道。

管道输入/输出流主要包括4种具体的实现：PipedOutputStrean、PipedInputStrean、PipedReader和PipedWriter，前两种面向字节，后两种面向字符。

## 指令

锁的颗粒度：
原子指令，自旋锁，互斥体

- 自旋锁
- 读写锁，多个多操作之间不会互相冲突，写操作和其他操作（读操作或写操作）都冲突。
- 序列锁，写操作和读操作不冲突，写操作维护一份写副本，等到读操作结束，就使写副本生效，读操作程序要重新读取新写入。

## 应用/库

开箱即用的带锁的（线程安全的）数据结构
- queue 队列
- pipe 管道
- lock


### 队列
python 的 queue 使用系统的pipe完成
总结：
 （1）队列只适合两个线程并行使用，一个压入数据(生产者），一个弹出数据（消费者）
 （2）队列是没有锁的并行，没有死锁的危险
 （3）队列中head和tail只有在计算结束之前的时候才能进行自增运算
### pipe
适用于，两个线程并行使用，半双通通信模式。
### ringbuffer
环形缓冲区ringbuffer

## misc

wait_until_pop()
wait_until_pushable()

await() / signal() wait() / notify()
