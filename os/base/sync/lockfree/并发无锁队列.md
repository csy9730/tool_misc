
# [并发无锁队列学习之一【开篇】](http://www.cnblogs.com/Anker/p/3823572.html)

[并发无锁队列](https://www.cnblogs.com/alantu2018/p/8469168.html)

## **1、前言**

　　

　　队列在计算机中非常重要的一种数据结构，尤其在操作系统中。队列典型的特征是先进先出（FIFO），符合流水线业务流程。在进程间通信、网络通信之间经常采用队列做缓存，缓解数据处理压力。结合自己在工作中遇到的队列问题，总结一下对不同场景下的队列实现。根据操作队列的场景分为：单生产者——单消费者、多生产者——单消费者、单生产者——多消费者、多生产者——多消费者四大模型。其实后面三种的队列，可以归纳为一种多对多。根据队列中数据分为：队列中的数据是定长的、队列中的数据是变长的。

## **2、队列操作模型**

**（1）单生产者——单消费者**

![img](https://images0.cnblogs.com/i/305504/201407/032359436219527.png)

**（2）多生产者——单消费者**

![img](https://images0.cnblogs.com/i/305504/201407/032359521522234.png)

**（3）单生产者——多消费者**

![img](https://images0.cnblogs.com/i/305504/201407/040002213714187.png)

**（4）多生产者——多消费者**

![img](https://images0.cnblogs.com/i/305504/201407/040002340129083.png)

## **3、队列数据定长与变长**

**（1）队列数据定长**

![img](https://images0.cnblogs.com/i/305504/201407/040006254498454.png)

**（2）队列数据变长**

![img](https://images0.cnblogs.com/i/305504/201407/040006341375676.png)

## **4、并发无锁处理**

**（1）单生产者——单消费者模型**

　　此种场景不需要加锁，定长的可以通过读指针和写指针进行控制队列操作，变长的通过读指针、写指针、结束指针控制操作。具体实现可以参考linux内核提供的kfifo的实现。可以参考：

http://blog.csdn.net/linyt/article/details/5764312

**（2）（一）多对多（一）模型**

　　正常逻辑操作是要对队列操作进行加锁处理。加锁的性能开销较大，一般采用无锁实现。无锁实现原理是CAS、FAA等机制。定长的可以参考：

http://coolshell.cn/articles/8239.html

变长的可以参考intel dpdk提供的rte_ring的实现。

http://blog.csdn.net/linzhaolover/article/details/9771329

 

 
