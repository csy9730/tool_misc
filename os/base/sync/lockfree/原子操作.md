# 原子操作
## C++ 原子操作
所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。

在以往的C++标准中并没有对原子操作进行规定，我们往往是使用汇编语言，或者是借助第三方的线程库，例如intel的pthread来实现。在新标准C++11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。

i++和++i是否为原子操作，不是。
## asm 原子操作

因为不同核心使用的缓存是不同的，其中一个核心对缓存的操作，在没有手工刷新缓存的情况下，通常要等待几个到几十时钟周期左右才会同步其它核心中，如果要访问的内存数据在同一块缓存上，那么就会出现结果不一致。所以，表面上看操作似乎是原子的，但实际上数据未必就是正确的，CPU到内存之间隔着多道缓存，不加锁前缀的情况下无法保证数据一致性。即使是单核心CPU，也不一定真就能保证正确性，万一有DMA或者中断呢？唯一能确定是原子操作的，恐怕只有读写寄存器了。


汇编指令也也只是在描述CPU的行为，而没有具体到每一个细节步骤。操作是否是原子的，不是由汇编指令决定的，而是由CPU如何处理这些指令决定的。1.有些汇编指令实际上是伪指令，可能对应多条真实的二进制指令，或者只是另外一个指令的语法糖。2.对于实际的物理硬件可以认为是由时序驱动的，在一个时钟周期里硬件的各个部分可以并行工作——结果就是多步骤行为完全是能够在一个时钟周期里被完成的。而且不能排除一个功能需要多个时钟周期才能完成。3.中断的实现方式也会影响这一结果。CPU究竟在什么时刻，通过什么方式来响应中断，也会影响一项操作是否会被中断打断。



汇编语言->机器语言->微程序->微指令->逻辑电路
简单的说，一条汇编语言指令对应的是一段由CPU生产商写好并固化在CPU内部的程序。所以，它可以在非常多的地方被打断。具体情况取决于CPU实现方式。

早先的CPU的汇编一条指令确实是原子操作。可是后来的指令变啦，比如X86的块操作、SIMD之类的指令都不再是原子操作了。