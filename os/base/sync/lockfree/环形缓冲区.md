# 环形缓冲区



<https://blog.csdn.net/p23onzq/article/details/80750745>

.<https://blog.csdn.net/blade2001/article/details/7094232/>

正在造轮子，同时不停地在找哪里有这个轮子

原因：

当有大量数据的时候，我们不能存储所有的数据，那么计算机处理数据的时候，只能先处理先来的，那么处理完后呢，就会把数据释放掉，再处理下一个。那么，已经处理的数据的内存就会被浪费掉。因为后来的数据只能往后排队，如过要将剩余的数据都往前移动一次，那么效率就会低下了，肯定不现实，所以，环形队列就出现了。

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rcIZQGIkZaMLn6IPyZvLxg9Mu7zOe4LkgNXLTsiaibiavtCXyFpUJyiaLxSagm7FuQxq4Z3u2sAxbqMjo9mTTdc5wA/640?wx_fmt=png)环形队列

目的：避免频繁的内存创建取消、分配。内存一直只用了一块。

 

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rcIZQGIkZaMLn6IPyZvLxg9Mu7zOe4Lkr0LicRvFRnwSBGYOyiaOSvv8bugrhB8lUicib53R6KzicLrYTa7L4HCpuCg/640?wx_fmt=png)

在发送线程使用的是普通队列。在发送任务处理的事件循环线程用的是环形队列。

即 一个环形缓冲区.
 

消息队列解决了 锁调用太频繁的问题，另一个让人有些苦恼的大概是这太多的内存分配和释放操作了。频繁的内存分配不但增加了系统开销，更使得内存碎片不断增多，非常不利于我们的服务器长期稳定运行。也许我们可以使用内存池，比如SGI STL中附带的小内存分配器。但是对于这种按照严格的先进先出顺序处理的，块大小并不算小的，而且块大小也并不统一的内存分配情况来说，更多使用的是一种叫做环形缓冲区的方案，

按照严格的先进先出顺序进行处理，这是环形缓冲区的使用必须遵守的一项要求。也就是，大家都得遵守规定，追的人不能从桌子上跨过去，跑的人当然也不允许反过来跑。至于为什么，不需要多做解释了吧。

　　环形缓冲区是一项很好的技术，不用频繁的分配内存，而且在大多数情况下，内存的反复使用也使得我们能用更少的内存块做更多的事。
 
　　在网络IO线程中，我们会为每一个连接都准备一个环形缓冲区，用于临时存放接收到的数据，以应付半包及粘包的情况。在解包及解密完成后，我们会将这个数据包复制到逻辑线程消息队列中，如果我们只使用一个队列，那这里也将会是个环形缓冲区，IO线程往里写，逻辑线程在后面读，互相追逐。

在通信程序中，经常使用环形缓冲区作为数据结构来存放通信中发送和接收的数据。环形缓冲区是一个先进先出的循环缓冲区，可以向通信程序提供对缓冲区的互斥访问。

1、环形缓冲区的实现原理

环形缓冲区通常有一个读指针和一个写指针。读指针指向环形缓冲区中可读的数据，写指针指向环形缓冲区中可写的缓冲区。通过移动读指针和写指针就可以实现缓冲区的数据读取和写入。在通常情况下，环形缓冲区的读用户仅仅会影响读指针，而写用户仅仅会影响写指针。如果仅仅有一个读用户和一个写用户，那么不需要添加互斥保护机制就可以保证数据的正确性。如果有多个读写用户访问环形缓冲区，那么必须添加互斥保护机制来确保多个用户互斥访问环形缓冲区。

图1、图2和图3是一个环形缓冲区的运行示意图。图1是环形缓冲区的初始状态，可以看到读指针和写指针都指向第一个缓冲区处；图2是向环形缓冲区中添加了一个数据后的情况，可以看到写指针已经移动到数据块2的位置，而读指针没有移动；图3是环形缓冲区进行了读取和添加后的状态，可以看到环形缓冲区中已经添加了两个数据，已经读取了一个数据。

环形缓冲区所有的push和pop操作都是在一个固定 的存储空间内进行。而队列缓冲区在push的时候，可能会分配存储空间用于存储新元素；在pop时，可能会释放废弃元素的存储空间。所以环形方式相比队列方式，少掉了对于缓冲区元素所用存储空间的分配、释放。这是环形缓冲区的一个主要优势。

使用链表的方式，正好和数组相反。链表省去了头尾相连的特殊处理。但是链表在初始化的时候比较繁琐，而且在有些场合（比如后面提到的跨进程的IPC）不太方便使用。

　　◇读写操作
　　环形缓冲区要维护两个索引，分别对应写入端（W）和读取端（R）。写入（push）的时候，先确保环没满，然后把数据复制到W所对应的元素，最后W指向下一个元素；读取（pop）的时候，先确保环没空，然后返回R对应的元素，最后R指向下一个元素。

　　◇判断“空”和“满”
　　上述的操作并不复杂，不过有一个小小的麻烦：空环和满环的时候，R和W都指向同一个位置！这样就无法判断到底是“空”还是“满”。大体上有两种方法可以解决该问题。

　　办法1：始终保持一个元素不用
　　当空环的时候，R和W重叠。当W比R跑得快，追到距离R还有一个元素间隔的时候，就认为环已经满。当环内元素占用的存储空间较大的时候，这种办法显得很土（浪费空间）。

　　办法2：维护额外变量
　　如果不喜欢上述办法，还可以采用额外的变量来解决。比如可以用一个整数记录当前环中已经保存的元素个数（该整数>=0）。当R和W重叠的时候，通过该变量就可以知道是“空”还是“满”。

　　◇元素的存储
　　由于环形缓冲区本身就是要降低存储空间分配的开销，因此缓冲区中元素的类型要选好。尽量存储值 类型的数据，而不要存储指针（引用） 类型的数据。因为指针类型的数据又会引起存储空间（比如堆内存）的分配和释放，使得环形缓冲区的效果打折扣。
 

一个例子“”：

``` cpp
char RecvBuf[128 * 1024];   //接收缓冲区，读写索引方式   
char SendBuf[MAX_SEND_CELL_NUM * sizeof(SendCell)];  //发送缓冲区，自定格式，每个节点存储 缓冲位置，缓冲长度，读取位置     
size_t  SendReadIndex;    //环形数组
size_t  SendWriteIndex;        
size_t RecvReadIndex;
size_t RecvWriteIndex;
static const size_t MAX_SEND_CELL_NUM = 1536;
size_t  TotalSendCellNum;
/* 环形缓冲区的地址编号计算函数，如果到达唤醒缓冲区的尾部，将绕回到头部。
环形缓冲区的有效地址编号为：0到(NMAX-1)
*/
 static void NextSendIndex(size_t& pos)
{
    if(++pos >= MAX_SEND_CELL_NUM)
        pos = 0;
    return;
}
```

接收到数据时需要做一个缓存的，因为处理的可能会很慢。

串口环形缓冲区收发：在很多入门级教程中，我们知道的串口收发都是：接收一个数据，触发中断，然后把数据发回来。这种处理方式是没有缓冲的，当数量太大的时候，亦或者当数据接收太快的时候，我们来不及处理已经收到的数据，那么，当再次收到数据的时候，就会将之前还未处理的数据覆盖掉。那么就会出现丢包的现象了，对我们的程序是一个致命的创伤。

那么如何避免这种情况的发生呢，很显然，上面说的一些队列的特性很容易帮我们实现我们需要的情况。将接受的数据缓存一下，让处理的速度有些许缓冲，使得处理的速度赶得上接收的速度，上面又已经分析了普通队列与环形队列的优劣了，那么我们肯定是用环形队列来进行实现了。下面就是代码的实现：


``` cpp
#define CIRCLEBUFFER_SIZE    8
unsigned char CircleBuffer[CIRCLEBUFFER_SIZE];
unsigned char WriteIndex = 0;
unsigned char ReadIndex = 0;
unsigned char LeftSize = 0;
//检查是否有到数组末尾了
unsigned char Check_CircleBuffer(unsigned char i)
{
    return(i + 1) ==  CIRCLEBUFFER_SIZE?0:i+1; 
}
//从环形数组里读取数据
unsigned char Read_CircleBuffer_Data(void)
{
    unsigned char Pos;
    if(LeftSize > 0)
    {
        Pos = ReadIndex;
        ReadIndex = Check_CircleBuffer(ReadIndex);
        LeftSize--;
        return CircleBuffer[Pos];
    }
    return 0;
}
//往环形数组内写入数据
void Write_CircleBuffer_Data(unsigned char Data)
{
    if(LeftSize < CIRCLEBUFFER_SIZE)
    {
        CircleBuffer[WriteIndex] = Data;
        WriteIndex = Check_CircleBuffer(WriteIndex);
        LeftSize++;
    }
}
void main(void)
{
    Write_CircleBuffer_Data(1);
    Read_CircleBuffer_Data();
}
```

 